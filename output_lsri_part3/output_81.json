{
  "acknowledgement": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Acknowledgements",
        "parent_header": [
          "TextFormats"
        ],
        "type": "Text_excerpt",
        "value": "This software has been originally created in context of the DFG project GO 3192/1-1\n\u201cAutomated characterization of microbial genomes and metagenomes by collection and verification of association rules\u201d.\nThe funders had no role in study design, data collection and analysis.\n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "header_analysis"
    }
  ],
  "application_domain": [
    {
      "confidence": 43.38,
      "result": {
        "type": "String",
        "value": "Natural Language Processing"
      },
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9321282038124095,
      "result": {
        "type": "String",
        "value": "Semantic web"
      },
      "technique": "supervised_classification"
    }
  ],
  "citation": [
    {
      "confidence": 1,
      "result": {
        "format": "cff",
        "type": "File_dump",
        "value": "cff-version: 1.2.0\nmessage: \"Please cite this software using the metadata from 'preferred-citation'.\"\ntitle: \"TextFormats\"\nauthors:\n- family-names: \"Gonnella\"\n  given-names: \"Giorgio\"\n  orcid: \"https://orcid.org/0000-0003-3900-5397\"\nversion: 1.2.3\ndate-released: 2023-02-15\nurl: \"https://github.com/ggonnella/textformats\"\npreferred-citation:\n  type: article\n  authors:\n  - family-names: \"Gonnella\"\n    given-names: \"Giorgio\"\n    orcid: \"https://orcid.org/0000-0003-3900-5397\"\n  doi: \"10.1371/journal.pone.0268910\"\n  journal: \"PLoS ONE\"\n  issue: 17\n  volume: 5\n  start: e0268910\n  day: 26\n  month: 5\n  year: 2022\n  title: \"TextFormats: Simplifying the definition and parsing of text formats in bioinformatics.\"\n  pmcid: PMC9135226\n\n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/CITATION.cff",
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Citation",
        "parent_header": [
          "TextFormats"
        ],
        "type": "Text_excerpt",
        "value": "If you use this software, please cite: Gonnella G. (2022).\nTextFormats: Simplifying the definition and parsing of text formats in\nbioinformatics. PloS one, 17(5), e0268910.\nhttps://doi.org/10.1371/journal.pone.0268910\n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "header_analysis"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/ggonnella/textformats"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2021-10-25T09:31:05Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2023-08-06T22:09:47Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 0.9963626332613842,
      "result": {
        "original_header": "TextFormats",
        "type": "Text_excerpt",
        "value": "TextFormats is a library for rapidly defining and using text formats for\nstructured data, and allows for rapid prototyping of parsers for\nsuch file formats in Nim, Python and C/C++. \nGiven a format definition, expressed in a simple declarative language (TFSL,\nText Formats Specification Language), the library provides functions for\nswitching from the text representation of the data (\"encoded string\") to the\nactual data it represents (\"decoded data\") and vice-versa. \nThe definition of the formats in TFSL is human readable and reduces the\nrequirement of complex regular expression. As opposed to lexers or regular\nexpressions, it does not only validates and splits different parts of a format,\nbut converts them to data in built-in scalar and compound datatypes, allowing\nfor fine tuning of the conversion.\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8912566662452687,
      "result": {
        "original_header": "Python",
        "type": "Text_excerpt",
        "value": "The Python API of TextFormats is documented in the\n[Python API manual](https://github.com/ggonnella/textformats/blob/main/manuals/Python_API.md)\nand [cheatsheet](https://github.com/ggonnella/textformats/blob/main/cheatsheets/Python_API.md)\nand can be installed using:\n```\npip install textformats\n```\n \nIf a binary package compatible with the system is available, it will\nbe downloaded and installed. Nim installation is not required. \nExample applications based on the Python API are available in the git repository\n[here](https://github.com/ggonnella/textformats/tree/main/python/examples)\nand [here](https://github.com/ggonnella/textformats/tree/main/python/benchmarks).\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9266266275238648,
      "result": {
        "original_header": "Nim",
        "type": "Text_excerpt",
        "value": "The Nim API of TextFormats is documented in the\n[Nim API manual](https://github.com/ggonnella/textformats/blob/main/manuals/Nim_API.md)\nand [cheatsheet](https://github.com/ggonnella/textformats/blob/main/cheatsheets/Nim_API.md).\nand is installed using:\n```\nnimble install textformats\n```\n \nExample applications based on the Nim API are available in the git repository\n[here](https://github.com/ggonnella/textformats/tree/main/examples)\nand [here](https://github.com/ggonnella/textformats/tree/main/benchmarks).\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9335048759804359,
      "result": {
        "original_header": "C/C++",
        "type": "Text_excerpt",
        "value": "The C API of TextFormats is documented in the\n[C API manual](https://github.com/ggonnella/textformats/blob/main/manuals/C_API.md)\nand [cheatsheet](https://github.com/ggonnella/textformats/blob/main/cheatsheets/C_API.md)\nand is obtained by cloning the\n[git repository](https://github.com/ggonnella/textformats.git).\nFurthermore [Nim compiler version >= 1.6.0 must be installed](https://github.com/ggonnella/textformats/blob/main/manuals/howto_install_nim.md) \nThe C API are in the in the ``C`` directory of the git repository.\nExample applications based on the C API are available in the git repository\n[here](https://github.com/ggonnella/textformats/tree/main/C/examples)\nand [here](https://github.com/ggonnella/textformats/tree/main/C/benchmarks).\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9150592646495768,
      "result": {
        "original_header": "Command line tools",
        "type": "Text_excerpt",
        "value": "The CLI tools developed with TextFormats allows the use of the library\nfrom the command line (e.g. in Bash scripts). For using it, the\n[Nim compiler version >= 1.6.0 must be installed](https://github.com/ggonnella/textformats/blob/main/manuals/howto_install_nim.md)\nand the textformats Nim package installed (``nimble install textformats``).\nThe tools are thereby installed and compiled. They are ``tf_spec`` (work with TFSL specifications),\n ``tf_decode`` (convert a format to JSON), ``tf_encode`` (convert JSON to a format)\n  and ``tf_validate`` (validate data or its text representations). \nExamples of use of the CLI tools are given in the git repository\n[here](https://github.com/ggonnella/textformats/tree/main/cli/examples)\n[here](https://github.com/ggonnella/textformats/tree/main/cli/tests).\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9145333338002573,
      "result": {
        "original_header": "Format specifications",
        "type": "Text_excerpt",
        "value": "The TFSL (TextFormats Specification Language) is usually input by the user\nas a YAML file. In alternative, the interactive Python script `tf_genspec.py`\ncan be used, which allows the generation of a specification from scratch. \nSeveral specifications are made available with the package and are contained\nin the git repository in the\n[spec directory](https://github.com/ggonnella/textformats/tree/main/spec) \nThe specification language is documented in a\n[manual](https://github.com/ggonnella/textformats/blob/main/manuals/TFSL_syntax.md),\nand a\n[cheatsheet](https://github.com/ggonnella/textformats/blob/main/cheatsheet/TFSL.md),\ndescribing the syntax,\na [howto](https://github.com/ggonnella/textformats/blob/main/manuals/TFSL_howto.md)\nexplaining how to define text representations\nfor different kind of values: strings, numeric, boolean, list, dictionaries, etc.\nand a\n[tests manual](https://github.com/ggonnella/textformats/blob/main/manuals/TFSL_tests.md),\ndescribing how to implement specification tests.\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9354372319578786,
      "result": {
        "original_header": "Interactive generation",
        "type": "Text_excerpt",
        "value": "An interactive script `tf_genspec.py` is provided under `scripts` in the\nsource code git repository.  It can be\nused to generate a TextFormats specification in YAML file.\nThe script has some limitations: it is not always guaranteed that the generated\nspecification is correct (e.g. the user can create circular or invalid\nreferences). \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9757106409099796,
      "result": {
        "original_header": "Developer notes",
        "type": "Text_excerpt",
        "value": "The library is implemented using the programming language Nim.\nThis language was used, since it combines some of the advantages of Python\nwith those of compiled languages. \nDuring compilation, C code is created and then compiled to binary.\nBesides in Nim code itself, the resulting library can be easily employed\nin C/C++ and in Python. \nCode organization and conventions, used in the implementation of the\nTextFormats library, addressed to the library software developer,\nare documented in the\n[developer manual](https://github.com/ggonnella/textformats/blob/main/manuals/developer_manual.md) \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9465225566811699,
      "result": {
        "original_header": "Known limitations",
        "type": "Text_excerpt",
        "value": "[^2]: reason: JsonNode objects from the json nim standard library are\nused to represent decoded values both for Nim code and for passing the values\nthrough the API to functions written in other languages; however, JsonNode does\nnot have a representation for unsigned integers)\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/ggonnella/textformats/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "faq": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Understanding specification errors",
        "parent_header": [
          "TextFormats",
          "Format specifications"
        ],
        "type": "Text_excerpt",
        "value": "The tool ``tf_spec`` (see above Command line tools) can be used as\n`tf_spec info -s <SPECFILE>` to list of datatypes of a (valid)\nspecification are output. An error will be output if the specification\nis invalid.\n\nA further tool to validate the syntax of a YAML or JSON specification, which can\nbe sometimes useful to better understand specification errors, is `tf_cerberus.py`,\nprovided under `scripts` in the\nsource code git repository.\nIt is based on the Python library `cerberus` (which is required in order to use this\ntool). The script has some limitations: it is not always guaranteed that a\nvalidated specification is indeed valid (e.g. circular or invalid references\nare not found).\n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "header_analysis"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 0
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/ggonnella/textformats/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "ggonnella/textformats"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "TextFormats"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "regular_expression"
    }
  ],
  "has_script_file": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/benchmarks/spec_compilation.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/benchmarks/regex_libraries/compile_all.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/benchmarks/regex_libraries/run_all.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/python/examples/egc/run_example.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/python/examples/gfa2_info/run_example.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/python/examples/gfa2_info/download_large_example.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/python/examples/ftab_to_gff3/run_example.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/C/scripts/find_nimbase.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/cli/examples/large_example.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/cli/examples/small_example.sh"
      },
      "technique": "file_exploration"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "\nThe Nim compiler (>= 1.6.0) must be installed to work with Nim, C or to install\nthe Python source distribution package.\n\nFor installing the Nim compiler there are several options (any will do, but some will only be available on some\nsystems, thus they are all listed here):\n\n# Option 1: Choosenim current version (requires a recent GLIB_C)\n```\ncurl https://nim-lang.org/choosenim/init.sh -sSf | sh\n# if necessary, add NIM to the path, e.g.:\necho 'export PATH=\"$HOME/.nimble/bin:$PATH\"' >> ~/.bashrc\n```\n\n# Option 2: Choosenim older version (any GLIB_C)\n\n```\n# for Linux\nexport URL=https://github.com/dom96/choosenim/releases/download/v0.7.2/choosenim-0.7.2_linux_amd64\n# for MacOS\nexport URL=https://github.com/dom96/choosenim/releases/download/v0.7.2/choosenim-0.7.2_macosx_amd64\n\nwget -O choosenim $URL && chmod +x choosenim && ./choosenim 1.6.4\n# add NIM to the path, e.g.:\necho 'export PATH=\"$HOME/.nimble/bin:$PATH\"' >> ~/.bashrc\n```\n\n# Option 3: Nim homepage \n\nInstall the Nim compiler pre-compiled binaries (or even the source code and compile it according to the instructions there)\nfrom the [Nim homepage](https://nim-lang.org/install_unix.html)\n\nIf necessary, add NIM to the path, where you install the software:\n```\necho 'export PATH=\"/path/to/nim/bin:$PATH\"' >> ~/.bashrc\n```\n\n# Option 4: package managers\n\nIf you install nim with a package manager (e.g. brew, conda, apt-get, ...)\nmake sure that the version installed is >= 1.6.0.\n\nCurrently e.g. conda currently installs version 1.4.8, incompatible with TextFormts.\n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/manuals/howto_install_nim.md",
      "technique": "file_exploration"
    },
    {
      "confidence": 0.9736587190544415,
      "result": {
        "original_header": "Python",
        "type": "Text_excerpt",
        "value": "The Python API of TextFormats is documented in the\n[Python API manual](https://github.com/ggonnella/textformats/blob/main/manuals/Python_API.md)\nand [cheatsheet](https://github.com/ggonnella/textformats/blob/main/cheatsheets/Python_API.md)\nand can be installed using:\n```\npip install textformats\n```\n \nIf a binary package compatible with the system is available, it will\nbe downloaded and installed. Nim installation is not required. \nIf no binary package is available, the source distribution is downloaded.\nIn this case, the [Nim compiler version >= 1.6.0 must be installed](https://github.com/ggonnella/textformats/blob/main/manuals/howto_install_nim.md)\nand the ``nim`` binary must be in PATH.  Then,\nthe ``pip install textformats`` command will automatically compile and install\nthe package. \nExample applications based on the Python API are available in the git repository\n[here](https://github.com/ggonnella/textformats/tree/main/python/examples)\nand [here](https://github.com/ggonnella/textformats/tree/main/python/benchmarks).\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9251058186894473,
      "result": {
        "original_header": "Nim",
        "type": "Text_excerpt",
        "value": "The Nim API of TextFormats is documented in the\n[Nim API manual](https://github.com/ggonnella/textformats/blob/main/manuals/Nim_API.md)\nand [cheatsheet](https://github.com/ggonnella/textformats/blob/main/cheatsheets/Nim_API.md).\nand is installed using:\n```\nnimble install textformats\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9412808163963969,
      "result": {
        "original_header": "C/C++",
        "type": "Text_excerpt",
        "value": "The C API are in the in the ``C`` directory of the git repository.\nExample applications based on the C API are available in the git repository\n[here](https://github.com/ggonnella/textformats/tree/main/C/examples)\nand [here](https://github.com/ggonnella/textformats/tree/main/C/benchmarks).\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.988589283705693,
      "result": {
        "original_header": "Command line tools",
        "type": "Text_excerpt",
        "value": "The CLI tools developed with TextFormats allows the use of the library\nfrom the command line (e.g. in Bash scripts). For using it, the\n[Nim compiler version >= 1.6.0 must be installed](https://github.com/ggonnella/textformats/blob/main/manuals/howto_install_nim.md)\nand the textformats Nim package installed (``nimble install textformats``).\nThe tools are thereby installed and compiled. They are ``tf_spec`` (work with TFSL specifications),\n ``tf_decode`` (convert a format to JSON), ``tf_encode`` (convert JSON to a format)\n  and ``tf_validate`` (validate data or its text representations). \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9421808275396658,
      "result": {
        "original_header": "Format specifications",
        "type": "Text_excerpt",
        "value": "Several specifications are made available with the package and are contained\nin the git repository in the\n[spec directory](https://github.com/ggonnella/textformats/tree/main/spec) \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9999999966506152,
      "result": {
        "original_header": "Developer notes",
        "type": "Text_excerpt",
        "value": "To run the unit test suite of the library, use the\n``nimble test`` command from the main project source code directory.\nTo run the CLI tools tests, first build it using ``nimble build`` or\n``nimble install``, then use the ``nimble clitest`` command.\nTo run the C API tests, use ``nimble ctest``.\nTo run the Python API tests, first build the package using\n``nimble pymake``, then use ``nimble pytest``.\n \n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/ggonnella/textformats/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "textformats"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "User",
        "value": "ggonnella"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "Nim",
        "size": 519022,
        "type": "Programming_language",
        "value": "Nim"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Python",
        "size": 174573,
        "type": "Programming_language",
        "value": "Python"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "C",
        "size": 46452,
        "type": "Programming_language",
        "value": "C"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Makefile",
        "size": 23298,
        "type": "Programming_language",
        "value": "Makefile"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Shell",
        "size": 15033,
        "type": "Programming_language",
        "value": "Shell"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "somef_missing_categories": [
    "run",
    "download",
    "requirements",
    "contact",
    "contributors",
    "documentation",
    "license",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-10-05 23:37:37",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 11
      },
      "technique": "GitHub_API"
    }
  ],
  "type": [
    {
      "confidence": 0.82,
      "result": {
        "type": "String",
        "value": "commandline-application"
      },
      "technique": "software_type_heuristics"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Format specifications: an example",
        "parent_header": [
          "TextFormats",
          "Format specifications"
        ],
        "type": "Text_excerpt",
        "value": "In multiple biological sequence analysis formats (e.g. SAM, GFA),\na CIGAR string represents a list of multi-edit operations, each consisting\nof a length (positive integer value) and an operation code (one among a short\nlist of possible codes).\n\nA string representation of a CIGAR is for example\n\"10M1D20M1I40M\". The string compactly represents a list of mappings,\neach with two members \"length\" and \"code\". In JSON its representation would\nbe: [{length: 10, code: \"M\"}, {length: 1, code: \"D\"}, {length: 20, code: \"M\"},\n{length: 1, code: \"I\"}, {length: 40, code: \"M\"}].\n\nThe definition of a CIGAR in TextFormats would be:\n```\ncigar:\n  list_of:\n    composed_of:\n    - length: {unsigned_integer: {min: 1}}\n    - code: {values: [M, D, I, P] }\n```\n\nOnce the definition is provided, the library provides the following functions:\n```\n# decoding: string representation => data\n\"10M1D\".decode(cigar)\n# => [{length: 10, code: \"M\"}, {length: 1, code: \"D\"}]\n\n# encoding: data => string representation\n[{length: 10, code: \"M\"}, {length: 1, code: \"D\"}].encode(cigar)\n# => \"10M1D\"\n\n# validation of string representation\n\"10M1D\".is_valid(cigar)\n# => true\n\n# validation of data\n[{length: 10, code: \"M\"}, {length: 1, code: \"D\"}].is_valid(cigar)\n# => true\n```\n\nFurthermore, definitions can refer to each other, which allows splitting\na complex definition into smaller parts, and reuse them in different contexts.\nFor example, the previous definition could have been written as:\n```\ncigar_code: {values: [M, D, I, P]}\npos_integer: {unsigned_integer: {min: 1}}\ncigar_op: {composed_of: [length: pos_integer, code: cigar_code]}\ncigar: {list_of: cigar_op}\n```\n\nSince definitions can be re-used in different contexts and formats, they\ncan be stored in modules, which can be imported from other specification files.\nThe import mechanism is flexible, featuring namespaces, partial imports and\nredefinitions of parts of an imported module.\n\nFinally, sometimes fine tuning of the conversion between encoded and\ndecoded data is necessary. Thus, the following operations can be included\nin the definitions:\n- providing more meaningful strings:\ne.g. in the example above of cigar operation code, one can\ndecode the \"M\" to the string \"replacement\" and the \"D\" to \"deletion\"\n- converting to different types:\ne.g. in some formats the symbols \"+\" and \"-\" represent\nthe boolean values true and false, and should be converted accordingly\n- add implicit values:\ne.g. in many formats, in a particular context\nof the file, multiple kind of information can be stored, and can be recognized\nfrom their different formatting; in this case, one\ncan add a label to the decoded data, describing the type of information\n- remove formatting symbols:\noften structured elements contain formatting constant strings such\nas separators, prefixes and suffixes, which must not be included in the\nresulting decoded data\n- define default values:\nsometimes a given symbol or part of a string representation is missing\nwhen representing a default value.\n"
      },
      "source": "https://raw.githubusercontent.com/ggonnella/textformats/main/README.md",
      "technique": "header_analysis"
    }
  ]
}
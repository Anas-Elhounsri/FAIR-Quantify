{
  "citation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Citing",
        "type": "Text_excerpt",
        "value": "If you use `bioptim`, we would be grateful if you could cite it as follows:\n@article{michaud2022bioptim,\n  title={Bioptim, a python framework for musculoskeletal optimal control in biomechanics},\n  author={Michaud, Benjamin and Bailly, Fran{\\c{c}}ois and Charbonneau, Eve and Ceglia, Amedeo and Sanchez, L{\\'e}a and Begon, Mickael},\n  journal={IEEE Transactions on Systems, Man, and Cybernetics: Systems},\n  year={2022},\n  publisher={IEEE}\n}\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "author": "Michaud, Benjamin and Bailly, Fran{\\c{c}}ois and Charbonneau, Eve and Ceglia, Amedeo and Sanchez, L{\\'e}a and Begon, Mickael",
        "format": "bibtex",
        "title": "Bioptim, a python framework for musculoskeletal optimal control in biomechanics",
        "type": "Text_excerpt",
        "value": "@article{michaud2022bioptim,\n    publisher = {IEEE},\n    year = {2022},\n    journal = {IEEE Transactions on Systems, Man, and Cybernetics: Systems},\n    author = {Michaud, Benjamin and Bailly, Fran{\\c{c}}ois and Charbonneau, Eve and Ceglia, Amedeo and Sanchez, L{\\'e}a and Begon, Mickael},\n    title = {Bioptim, a python framework for musculoskeletal optimal control in biomechanics},\n}"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/pyomeca/bioptim"
      },
      "technique": "GitHub_API"
    }
  ],
  "contact": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Muscle driven with contact",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "All the examples in the folder muscle_driven_with_contact show some dynamics and prepare some OCP for the tests.\nThey are not relevant and will be removed when unitary tests for the dynamics will be implemented.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/muscle_driven_with_contact/contact_forces_inequality_constraint_muscle.py\">contact_forces_inequality_constraint_muscle.py</a> file",
        "parent_header": [
          "Examples",
          "Muscle driven with contact"
        ],
        "type": "Text_excerpt",
        "value": "In this example, we implement inequality constraints on two contact forces. It is designed to show how to use min_bound \nand max_bound values for the definition of inequality constraints instead of equality constraints, which can be used with \nany ConstraintFcn.\n\nIn this case, the dynamics function used is `DynamicsFcn.MUSCLE_ACTIVATIONS_AND_TORQUE_DRIVEN_WITH_CONTACT`.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/muscle_driven_with_contact/contact_forces_inequality_constraint_muscle_excitations.py\">contact_forces_inequality_constraint_muscle_excitations.py</a> file",
        "parent_header": [
          "Examples",
          "Muscle driven with contact"
        ],
        "type": "Text_excerpt",
        "value": "In this example, we implement inequality constraints on two contact forces. It is designed to show how to use `min_bound` \nand `max_bound` values so they define inequality constraints instead of equality constraints, which can be used with any \n`ConstraintFcn`.\n\nIn this case, the dynamics function used is `DynamicsFcn.MUSCLE_EXCITATIONS_AND_TORQUE_DRIVEN_WITH_CONTACT` instead of \n`DynamicsFcn.MUSCLE_ACTIVATIONS_AND_TORQUE_DRIVEN_WITH_CONTACT` used in the previous example. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/muscle_driven_with_contact/muscle_activations_contacts_tracker.py\">muscle_activations_contacts_tracker.py</a> file",
        "parent_header": [
          "Examples",
          "Muscle driven with contact"
        ],
        "type": "Text_excerpt",
        "value": "In this example, we track both muscle controls and contact forces, as it is defined when adding the two objective \nfunctions below, using both `ObjectiveFcn.Lagrange.TRACK_MUSCLES_CONTROL` and \n`ObjectiveFcn.Lagrange.TRACK_CONTACT_FORCES` objective functions. \n\n```python\nobjective_functions = ObjectiveList()\nobjective_functions.add(ObjectiveFcn.Lagrange.TRACK_MUSCLES_CONTROL, target=muscle_activations_ref)\nobjective_functions.add(ObjectiveFcn.Lagrange.TRACK_CONTACT_FORCES, target=contact_forces_ref)\n```\n\nLet us take a look at the structure of this example. First, we load data to track and generate data using the \n`data_to_track.prepare_ocp` optimization control program. Then, we track these data using `muscle_activation_ref` and \n`contact_forces_ref` as shown below:\n\n```python\nocp = prepare_ocp(\n    biorbd_model_path=model_path,\n    phase_time=final_time,\n    n_shooting=ns,\n    muscle_activations_ref=muscle_activations_ref[:, :-1],\n    contact_forces_ref=contact_forces_ref,\n)\n```\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "contributing_guidelines": [
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "# Contributing to `bioptim`\nAll contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome.\nWe recommend going through the list of [`issues`](https://github.com/pyomeca/bioptim/issues) to find issues that interest you, preferable those tagged with `good first issue`.\nYou can then get your development environment setup with the following instructions.\n\n## Forking `bioptim`\n\nYou will need your own fork to work on the code.\nGo to the [bioptim project page](https://github.com/pyomeca/bioptim/) and hit the `Fork` button.\nYou will want to clone your fork to your machine:\n\n```bash\ngit clone https://github.com/your-user-name/bioptim.git\n```\n\n## Creating and activating conda environment\n\nBefore starting any development, we recommend that you create an isolated development environment. \nThe easiest and most efficient way (due to the numerous dependencies of `bioptim`) is to use an anaconda virtual environment and to create it based on the `environment.yml` file. \n\n- Install [miniconda](https://conda.io/miniconda.html)\n- `cd` to the `bioptim` source directory\n- Install `bioptim` dependencies with:\n\n```bash\nconda env create -f environment.yml\nconda activate biorbd_optim\n```\n\n## Implementing new features\n\nBefore implementing your awesome new feature, please discuss with the code owner to prevent any clashing with some other competing developments. \nIt is also a good idea to check the current opened pull-request not to redo something currently being developed. \nIf your feature is mentioned in the issue section of GitHub, please assign it to yourself.\nOtherwise, please open a new issue explaining what you are currently working on (and assign it to yourself!).\n\nAs soon as possible, you are asked to open a pull-request (see below) with a short but descriptive name. \nUnless that pull-request is ready to be merged, please tag it as `work in progress` by adding `[WIP]` at the beginning of the pull-request name.\nIf you are ready to get your PR reviewed, you can add the tag `ready to review` by adding `[RTR]`.\nIf you think your PR is ready for the last review, please use the tag `ready to merge` by adding `[RTM]`.\nSend commits that are as small as possible; 1 to 10 lines is probably a good guess, with again short but descriptive commit names. \nBe aware of the review done by the maintainers, they will contain useful tips and advice that should be integrated ASAP. \nOnce you have responded to a specific comment, please respond `Done!` and tag it as resolved.\n\nMake sure you add a minimal but meaningful example of your new feature in the `examples` folder and that you create a test with numerical values for comparison.\nIf this feature changes the API, this should also be reflected in the ReadMe.\nDuring your development, you can create a `sandbox` folder in the examples folder. \nEverything in this folder will automatically be ignored by Git. \nIf by accident you add a binary file in the history file (by not using a sandbox), your pull-request will be rejected and you will have to produce a new pull-request free from the binary file. \n\nWhen you have completed the implementation of your new feature, navigate to your pull-request in GitHub and select `Pariterre` in the `Reviewers` drop menu. \nAt the same time, if you think your review is ready to be merged, remove the `[WIP]` tag in the name (otherwise, your pull-request won't be merged). \nIf your pull-request is accepted, there is nothing more to do, Congrats! \nIf changes are required, reply to all the comments and, as stated previously, respond `Done!` and tag them as resolved. \nBe aware that sometimes the maintainer can push modifications directly to your branch, so make sure to pull before continuing your work on that branch.\n\n## Testing your code\n\nAdding tests are required to get your development merged to the master branch. \nTherefore, it is very good practice to get the habit of writing tests ahead of time so this is never an issue.\nThe `bioptim` test suite runs automatically on GitHub every time a commit is submitted.\nHowever, we strongly encourage running tests locally prior to submitting the pull-request.\nTo do so, simply run the tests folder in pytest (`pytest tests`).\n\n## Commenting\n\nEvery function, class and module should have their respective proper docstrings completed.\nThe docstring convention used is NumPy. \nMoreover, if your new features is available to the lay user (i.e., it changes the API), the `ReadMe.md` should be modified accordingly.\n\n## Convention of coding\n\n`Bioptim` tries to follow as much as possible the PEP recommendations (https://www.python.org/dev/peps/). \nUnless you have good reasons to disregard them, your pull-request is required to follow these recommendations. \nI won't get into details here, if you haven't yet, you should read them :) \n\nAll variable names that could be plural should be written as such.\n\nBlack is used to enforce the code spacing. \n`Bioptim` is linted with the 120-character max per line's option. \nThis means that your pull-request tests on GitHub will appear to fail if black fails. \nThe easiest way to make sure black is happy is to locally run this command:\n```bash\nblack . -l120 --exclude \"external/*\"\n```\nIf you need to install black, you can do it via conda using the conda-forge channel.\n\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/docs/contributing.md",
      "technique": "file_exploration"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2020-03-31T13:46:21Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-09-27T09:01:34Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "An optimization framework that links CasADi, Ipopt, ACADOS and biorbd for Optimal Control Problem "
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 0.904806115974468,
      "result": {
        "original_header": "Status",
        "type": "Text_excerpt",
        "value": "The current status of `bioptim` on conda-forge is \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8141935974226084,
      "result": {
        "original_header": "Try bioptim",
        "type": "Text_excerpt",
        "value": "Anyone can play with bioptim with a working (but slightly limited in terms of graphics) MyBinder by clicking the following badge \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.975067665871616,
      "result": {
        "original_header": "The OCP",
        "type": "Text_excerpt",
        "value": "An optimal control program is an optimization that uses control variables to drive some state variables.\n`Bioptim` includes two types of transcription methods: the `direct collocation` and the `direct multiple shooting`.\nTo summarize, it defines a large optimization problem by discretizing the control and the state variables into a predetermined number of intervals, the beginning of the interval being the shooting points.\nBy defining strict continuity/collocation constraints, it can ensure proper dynamics of the system (i.e. state continuity).\nThe OCP are the solved using gradient descending algorithms until a local minimum is found.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8939586116274385,
      "result": {
        "original_header": "Class: OptimalControlProgram",
        "type": "Text_excerpt",
        "value": "This is the main class that holds an ocp. \nMost of the attributes and methods are for internal use; therefore the API user should not care much about them.\nOnce an OptimalControlProgram is constructed, it is usually ready to be solved. \nThe full signature of the `OptimalControlProgram` can be scary at first, but should become clear soon.\nHere it is:\n```python\nOptimalControlProgram(\n    bio_model: [list, BioModel],\n    dynamics: [Dynamics, DynamicsList],\n    n_shooting: [int, list],\n    phase_time: [float, list], \n    x_bounds: BoundsList,\n    u_bounds: BoundsList,\n    x_init: InitialGuessList\n    u_init: InitialGuessList,\n    objective_functions: [Objective, ObjectiveList],\n    constraints: [Constraint, ConstraintList],\n    parameters: ParameterList,\n    ode_solver: OdeSolver,\n    control_type: [ControlType, list],\n    all_generalized_mapping: BiMapping,\n    q_mapping: BiMapping,\n    qdot_mapping: BiMapping,\n    tau_mapping: BiMapping,\n    plot_mappings: Mapping,\n    phase_transitions: PhaseTransitionList,\n    n_threads: int,\n    use_sx: bool,\n)\n```\nOf these, only the first four are mandatory.  \n`bio_model` is the model loaded with classes such as BiorbdModel, MultiBiorbdModel, or a custom class. \nIn the case of a multiphase optimization, one model per phase should be passed in a list.  \n`dynamics` is the system's dynamics during each phase (see The dynamics section).  \n`n_shooting` is the number of shooting points of the direct multiple shooting (method) for each phase.  \n`phase_time` is the final time of each phase. If the time is free, this is the initial guess.  \n`x_bounds` is the minimal and maximal value the states can have (see The bounds section)  .  \n`u_bounds` is the minimal and maximal value the controls can have (see The bounds section).  \n`x_init` is the initial guess for the states variables (see The initial conditions section).  \n`u_init` is the initial guess for the controls variables (see The initial conditions section).  \n`x_scaling` is the scaling applied to the states variables (see The variable scaling section).  \n`xdot_scaling` is the scaling applied to the state derivative variables (see The variable scaling section).  \n`u_scaling` is the scaling applied to the controls variables (see The variable scaling section).  \n`objective_functions` is the objective function set of the ocp (see The objective functions section).  \n`constraints` is the constraint set of the ocp (see The constraints section).  \n`parameters` is the parameter set of the ocp (see The parameters section).\nIt is a list (one element for each phase) of np.ndarray of shape (6, i, n), where the 6 components are [Mx, My, Mz, Fx, Fy, Fz], for the ith force platform (defined by the externalforceindex) for each node n.  \n`ode_solver` is the ode solver used to solve the dynamic equations.  \n`control_type` is the type of discretization of the controls (usually CONSTANT) (see ControlType section).  \n`all_generalized_mapping` is used to reduce the number of degrees of freedom by linking them (see The mappings section).\nThis one applies the same mapping to the generalized coordinates (*q*), velocities (*qdot*), and forces (*tau*).\n`q_mapping` the mapping applied to *q*.  \n`qdot_mapping` the mapping applied to *q_dot*.  \n`tau_mapping` the mapping applied to *tau*.  \n`plot_mappings` is to force some plots to be linked together.  \n`n_threads` is to solve the optimization using multiple threads. \nThis number is the number of threads to use.  \n`use_sx` is if the CasADi graph should be constructed in SX. \nSX will tend to solve much faster than MX graphs, however they necessitate a huge amount of RAM.\nPlease note that a common ocp will usually define only these parameters:\n```python\nocp = OptimalControlProgram(\n    bio_model: [list, BioModel],\n    dynamics: [Dynamics, DynamicsList],\n    n_shooting: [int, list],\n    phase_time: [float, list],\n    x_init: InitialGuessList\n    u_init: InitialGuessList, \n    x_bounds: BoundsList,\n    u_bounds: BoundsList,\n    objective_functions: [Objective, ObjectiveList],\n    constraints: [Constraint, ConstraintList],\n    n_threads: int,\n)\n```\n \nThe main methods one will be interested in are:\n```python\nocp.update_objectives()\nocp.update_constraints()\nocp.update_parameters()\nocp.update_bounds()\nocp.update_initial_guess()\n```\nThese allow to modify the ocp after being defined. \nIt is advantageous when solving the ocp for the first time, then adjusting some parameters and reoptimizing afterward. \nMoreover, the method \n```python\nsolution = ocp.solve(Solver)\n```\nis called to solve the ocp (the solution structure is discussed later). \nThe `Solver` class can be used to select the nonlinear solver to solve the ocp: \n- IPOPT\n- ACADOS\n- SQP method \nNote that options can be passed to the solver parameter.\nOne can refer to their respective solver's documentation to know which options exist.\nThe `show_online_optim` parameter can be set to `True` so the graphs nicely update during the optimization with the default values.\nOne can also directly declare `online_optim` as an `OnlineOptim` parameter to customize the behavior of the plotter. \nNote that `show_online_optim` and `online_optim` are mutually exclusive.\nPlease also note that `OnlineOptim.MULTIPROCESS` is not available on Windows and only none of them are available on Macos. \nTo see how to run the server on Windows, please refer to the `getting_started/pendulum.py` example.\nIt is expected to slow down the optimization a bit. \n`show_options` can be also passed as a dict to the plotter to customize the plotter's behavior.\nIf `online_optim` is set to `SERVER`, then a server must be started manually by instantiating an `PlottingServer` class (see `ressources/plotting_server.py`).\nThe following keys are additional options when using `OnlineOptim.SERVER` and `OnlineOptim.MULTIPROCESS_SERVER`:\n  - `host`: the host to use (default is `localhost`)\n  - `port`: the port to use (default is `5030`) \nFinally, one can save and load previously optimized values by using\n```python\nocp.save(solution, file_path)\nocp, solution = OptimalControlProgram.load(file_path)\n```\nIMPORTANT NOTICE: Please note that saved solution depends on the `bioptim` version used to create the .bo file, and retro-compatibility is NOT enforced.\nIn other words, an optimized solution from a previous version will probably NOT load on a newer `bioptim` version.\nTo save the solution in a way independent of the version of `bioptim`, one may use the `stand_alone` flag to `True`. \nFinally, the `add_plot(name, update_function)` method can create new dynamics plots.\nThe name is simply the name of the figure.\nIf one with the same name already exists, the axes are merged.\nThe update_function is a function handler with signature: `update_function(states: np.ndarray, constrols: np.ndarray: parameters: np.ndarray) -> np.ndarray`.\nIt is expected to return a np.ndarray((n, 1)), where `n` is the number of elements to plot. \nThe `axes_idx` parameter can be added to parse the data in a more exotic manner.\nFor instance, on a three-axes figure, if one wanted to plot the first value on the third axes and the second value on the first axes and nothing on the second, the `axes_idx=[2, 0]` would do the trick.\nThe interested user can have a look at the `examples/getting_started/custom_plotting.py` example.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.981489776563003,
      "result": {
        "original_header": "Class: NonLinearProgram",
        "type": "Text_excerpt",
        "value": "The NonLinearProgram is, by essence, the phase of an ocp. \nThe user is expected not to change anything from this class but can retrieve valuable information from it. \nOne main use of nlp is to get a reference to the bio_model for the current phase: `nlp.model`.\nAnother essential value stored in nlp is the shape of the states and controls: `nlp.shape`, which is a dictionary where the keys are the names of the elements (for instance, *q* for the generalized coordinates) \nIt would be tedious, and probably not much useful, to list all the elements of nlp here.   \nThe interested user is invited to look at the docstrings for this class to get a detailed overview of it.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9498879013950826,
      "result": {
        "original_header": "Class: VariationalOptimalControlProgram",
        "type": "Text_excerpt",
        "value": "The `VariationalOptimalControlProgram` class inherits from `OptimalControlProgram` and is used to solve optimal control\nproblems using the variational approach. A variational integrator does the integration. The formulation being completely different from the other approaches, it needed its own class. The parameters are the same as in\n`OptimalControlProgram` apart from the following changes:\n- `bio_model` must be a `VariationalBiorbdModel`\n- The phases have not been implemented yet; hence, only `final_time` must be specified, and it must be a float.\n- There are no velocities in the variational approach, so you must only specify the `q_init` and not the `q_bounds`\ninstead of `x_init` and `x_bounds`.\n- You can specify an initial guess for the velocities at the first node and the last node using `qdot_init` and\n`qdot_bounds` and the keys must be `\"qdot_start\"` and `\"qdot_end\"`. These velocities are implemented as parameters of\nthe OCP, you can access them with `sol.parameters[\"qdot_start\"]` and `sol.parameters[\"qdot_end\"]` at the end of the\noptimization.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9875342957697214,
      "result": {
        "original_header": "Class: PlottingServer",
        "type": "Text_excerpt",
        "value": "If one wants to use the `OnlineOptim.SERVER` plotter, one can instantiate this class to start a server.\nThis is not mandatory as if `as_multiprocess` is set to `True` in the `show_options` dict [default behavior], this server is started automatically.\nThe advantage of starting the server manually is that one can plot online graphs on a remote machine.\nAn example of such a server is provided in `resources/plotting_server.py`.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9908392364406541,
      "result": {
        "original_header": "The model",
        "type": "Text_excerpt",
        "value": "Bioptim is designed to work with any model, as long as it inherits from the class `bioptim.Model`. Models built with `biorbd` are already compatible with `bioptim`.\nThey can be used as is or modified to add new features.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.892718178514717,
      "result": {
        "original_header": "Class: BiorbdModel",
        "type": "Text_excerpt",
        "value": "The `BiorbdModel` class implements a BioModel of the biorbd dynamics library. Some methods may not be interfaced yet; it is accessible through:\n```python\nbio_model = BiorbdModel(\"path/to/model.bioMod\")\nbio_model.marker_names  # for example returns the marker names\n# if the methods is not interfaced, it can be accessed through\nbio_model.model.markerNames()\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9334711081987677,
      "result": {
        "original_header": "Class: MultiBiorbdModel",
        "type": "Text_excerpt",
        "value": "The `MultiBiorbdModel` class implements BioModel of multiple models of biorbd dynamics library. Some methods may not be interfaced yet; it is accessible through:\n```python\nbio_model = MultiBiorbdModel((\"path/to/model.bioMod\", \"path/to/other/model.bioMod\"))\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9583737062812391,
      "result": {
        "original_header": "Class: HolonomicBiorbdModel",
        "type": "Text_excerpt",
        "value": "The `HolonomicBiorbdModel` class implements a BioModel of the biorbd dynamics library. Since the class inherits\nfrom `BiorbdModel`, all the methods of `BiorbdModel` are available. You can define the\ndegrees of freedom (DoF) that are independent (that define the movement) and the ones that are dependent (that are\ndefined by the independent DoF and the holonomic constraint(s)). You can add some holonomic constraints to the model.\nFor this, you can use one of the functions of `HolonomicConstraintFcn` or add a custom one. You can refer to the\nexamples in `bioptim/examples/holonomic_constraints` to see how to use it.\nSome methods may not be interfaced yet; it is accessible through: \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9922078331781551,
      "result": {
        "original_header": "Class VariationalBiorbdModel",
        "type": "Text_excerpt",
        "value": "The `VariationalBiorbdModel` class implements a BioModel of the biorbd dynamics library. It is used in Discrete\nMechanic and Optimal Control (DMOC) and Discrete Mechanics and Optimal Control in Constrained Systems (DMOCC).\nSince the class inherits from `HolonomicBiorbdModel`, all the `HolonomicBiorbdModel` and `BiorbdModel` methods are\navailable. This class is used in `VariationalOptimalControlProgram`. You can refer to the examples in\n`bioptim/examples/discrete_mechanics_and_optimal_control` to see how to use it.\nSome methods may not be interfaced yet; it is accessible through:\n```python\nbio_model = VariationalBiorbdModel(\"path/to/model.bioMod\")\nholonomic_constraints = HolonomicConstraintsList()\nholonomic_constraints.add(\"holonomic_constraints\", HolonomicConstraintsFcn.function, **kwargs)\nbio_model.set_holonomic_configuration(holonomic_constraints)\nVariationalOptimalControlProgram(bio_model, ...)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8266256361525905,
      "result": {
        "original_header": "Class: CustomModel",
        "type": "Text_excerpt",
        "value": "The `BioModel` class is the base class for BiorbdModel and any custom models.\nThe methods are abstracted and must be implemented in the child class,\nor at least raise a `NotImplementedError` if they are not implemented. For example:\n```python\nfrom bioptim import Model\n\nclass MyModel(CustomModel, metaclass=ABCMeta):\n    def __init__(self, *args, **kwargs):\n        ...\n\n    def name_dof(self):\n        return [\"dof1\", \"dof2\", \"dof3\"]\n\n    def marker_names(self):\n        raise NotImplementedError\n``` \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8716813566860316,
      "result": {
        "original_header": "The dynamics",
        "type": "Text_excerpt",
        "value": "By essence, an optimal control program (ocp) links two types of variables: the states (x) and the controls (u). \nConceptually, the controls are the driving inputs of the system, which participate in changing the system states. \nIn the case of biomechanics, the states (*x*) are usually the generalized coordinates (*q*) and velocities (*qdot*), i.e., the pose of the musculoskeletal model and the joint velocities. \nOn the other hand, the controls (*u*) can be the generalized forces, i.e., the joint torques, but can also be the muscle excitations, for instance.\nStates and controls are linked through Ordinary differential equations: dx/dt = f(x, u, p), where p can be additional parameters that act on the system but are not time-dependent. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.936731333674359,
      "result": {
        "original_header": "Class: Dynamics",
        "type": "Text_excerpt",
        "value": "This class is the main class to define a dynamics. \nIt, therefore, contains all the information necessary to configure (i.e., determining which variables are states or controls) and perform the dynamics. \nWhen constructing an `OptimalControlProgram()`, Dynamics is the expected class for the `dynamics` parameter.  \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9761967559264837,
      "result": {
        "original_header": "The options",
        "type": "Text_excerpt",
        "value": "The full signature of Dynamics is as follows:\n```python\nDynamics(dynamics_type, configure: Callable, dynamic_function: Callable, phase: int)\n```\nThe `dynamics_type` is the selected `DynamicsFcn`. \nIt automatically defines both `configure` and `dynamic_function`. \nIf a function is sent instead, this function is interpreted as `configure` and the DynamicsFcn is assumed to be `DynamicsFcn.CUSTOM`\nIf one is interested in changing the behavior of a particular `DynamicsFcn`, they can refer to the Custom dynamics functions right below.  \nThe `phase` is the index of the phase the dynamics applies to. \nThe `add()` method of `DynamicsList` usually takes care of this, but it can be useful when declaring the dynamics out of order.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9871925864905284,
      "result": {
        "original_header": "Custom dynamic functions",
        "type": "Text_excerpt",
        "value": "The configuration is what tells `bioptim` which variables are states and which are control.\nThe user is expected to provide a function handler with the following signature: `custom_configure(ocp: OptimalControlProgram, nlp: NonLinearProgram)`.\nIn this function, the user is expected to call the relevant `ConfigureProblem` class methods: \n- `configure_q(nlp, as_states: bool, as_controls: bool)`\n- `configure_qdot(nlp, as_states: bool, as_controls: bool)`\n- `configure_q_qdot(nlp, as_states: bool, as_controls: bool)`\n- `configure_tau(nlp, as_states: bool, as_controls: bool)`\n- `configure_residual_tau(nlp, as_states: bool, as_controls: bool)`\n- `configure_muscles(nlp, as_states: bool, as_controls: bool)`\nwhere `as_states` add the variable to the states vector and `as_controls` to the controls vector.\nPlease note that this is not necessarily mutually exclusive.\nFinally, the user is expected to configure the dynamic by calling `ConfigureProblem.configure_dynamics_function(ocp, nlp, custom_dynamics)` \nDefining the dynamic function must be done when one provides a custom configuration, but it can also be defined by providing a function handler to the `dynamic_function` parameter for `Dynamics`. \nThe signature of this custom dynamic function is as follows: `custom_dynamic(states: MX, controls: MX, parameters: MX, nlp: NonLinearProgram`.\nThis function is expected to return a tuple[MX] of the derivative of the states. \nSome methods defined in the class `DynamicsFunctions` can be useful, but will not be covered here since it is initially designed for internal use.\nPlease note that MX type is a CasADi type.\nAnyone who wants to define custom dynamics should be at least familiar with this type beforehand.  \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9033841732210167,
      "result": {
        "original_header": "Class: DynamicsList",
        "type": "Text_excerpt",
        "value": "A DynamicsList is simply a list of Dynamics. \nThe `add()` method can be called exactly as if one was calling the `Dynamics` constructor. \nIf the `add()` method is used more than one, the `phase` parameter is automatically incremented.  \nSo a minimal use is as follows:\n```python\ndyn_list = DynamicsList()\ndyn_list.add(DynamicsFcn)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9354678884922492,
      "result": {
        "original_header": "Class: DynamicsFcn",
        "type": "Text_excerpt",
        "value": "The `DynamicsFcn` class is the configuration and declaration of all the already available dynamics in `bioptim`. \nSince this is an Enum, it is possible to use tab key on the keyboard to dynamically list them all, depending on the capabilities of your IDE.  \nPlease note that one can change the dynamic function associated to any of the configuration by providing a custom dynamics_function. \nFor more information on this, please refer to the Dynamics and DynamicsList section right before. \n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9460358083318188,
      "result": {
        "original_header": "TORQUE_DRIVEN",
        "type": "Text_excerpt",
        "value": "The torque driven defines the states (x) as *q* and *qdot* and the controls (u) as *tau*. \nThe derivative of *q* is trivially *qdot*.\nThe derivative of *qdot* is given by the biorbd function: `qddot = bio_model.ForwardDynamics(q, qdot, tau)`.\nIf external forces are provided, they are added to the ForwardDynamics function. Possible options:\n- **with_contact = True:** The derivative of *qdot* is given by the `biorbd` function that includes non-acceleration contact point defined in the bioMod: `qddot = bio_model.ForwardDynamicsConstraintsDirect(q, qdot, tau)`.\n- **with_passive_torque = True:** The passive torque is taken into account in the *tau*.\n- **with_ligament = True:** The tau generated by the ligament is taken into account in the *tau*.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9496082937820916,
      "result": {
        "original_header": "TORQUE_DERIVATIVE_DRIVEN",
        "type": "Text_excerpt",
        "value": "The torque derivative driven defines the states (x) as *q*, *qdot*, *tau* and the controls (u) as *taudot*. \nThe derivative of *q* is trivially *qdot*.\nThe derivative of *qdot* is given by the biorbd function: `qddot = bio_model.ForwardDynamics(q, qdot, tau)`.\nThe derivative of *tau* is trivially *taudot*. \nIf external forces are provided, they are added to the ForwardDynamics function. Possible options:\n- **with_contact = True:** The derivative of *qdot* is given by the `biorbd` function that includes non-acceleration contact point defined in the bioMod: `qddot = bio_model.ForwardDynamicsConstraintsDirect(q, qdot, tau)`.\n- **with_passive_torque = True:** The passive torque is taken into account in the *tau*.\n- **with_ligament = True:** The tau generated by the ligament is taken into account in the *tau*.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9735342928935657,
      "result": {
        "original_header": "TORQUE_ACTIVATIONS_DRIVEN",
        "type": "Text_excerpt",
        "value": "The torque driven defines the states (x) as *q* and *qdot* and the controls (u) as the level of activation of *tau*. \nThe derivative of *q* is trivially *qdot*.\nThe actual *tau* is computed from the activation by the `biorbd` function: `tau = bio_model.torque(torque_act, q, qdot)`.\nThen, the derivative of *qdot* is given by the `biorbd` function: `qddot = bio_model.ForwardDynamics(q, qdot, tau)`. \nPlease note, this dynamics is expected to be very slow to converge, if it ever does. \nOne is therefore encourage using TORQUE_DRIVEN instead, and to add the TORQUE_MAX_FROM_ACTUATORS constraint.\nThis has been shown to be more efficient and allows defining minimum torque. Possible options:\n- **with_contact = True:** The derivative of *qdot* is given by the `biorbd` function that includes non-acceleration contact point defined in the bioMod: `qddot = bio_model.ForwardDynamicsConstraintsDirect(q, qdot, tau)`.\n- **with_passive_torque = True:** The passive torque is taken into account in the *tau*.\n- **with_ligament = True:** The tau generated by the ligament is taken into account in the *tau*.\n- **with_residual_torque = True:** The residual torque is taken into account in the *tau*.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9797298040920828,
      "result": {
        "original_header": "JOINTS_ACCELERATION_DRIVEN",
        "type": "Text_excerpt",
        "value": "The joints acceleration driven defines the states (x) as *q* and *qdot* and the controls (u) as *qddot_joints*. The derivative of *q* is trivially *qdot*.\nThe joints' acceleration *qddot_joints* is the acceleration of the actual joints of the `biorb_model` without its root's joints.\nThe model's root's joints acceleration *qddot_root* are computed by the `biorbd` function: `qddot_root = boirbd_model.ForwardDynamicsFreeFloatingBase(q, qdot, qddot_joints)`.\nThe derivative of *qdot* is the vertical stack of *qddot_root* and *qddot_joints*. \nThis dynamic is suitable for bodies in free fall.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9525305950769566,
      "result": {
        "original_header": "MUSCLE_DRIVEN",
        "type": "Text_excerpt",
        "value": "The torque driven defines the states (x) as *q* and *qdot* and the controls (u) as the muscle activations. \nThe derivative of *q* is trivially *qdot*. Possible options:\nThe actual *tau* is computed from the muscle activation converted in muscle forces and thereafter converted to *tau* by the `biorbd` function: `bio_model.muscularJointTorque(muscles_states, q, qdot)`.\nThe derivative of *qdot* is given by the `biorbd` function: `qddot = bio_model.ForwardDynamics(q, qdot, tau)`.\n- **with_contact = True:** The actual *tau* is computed from the sum of *tau* to the *a* converted in muscle forces and thereafter converted to *tau* by the `biorbd` function: `bio_model.muscularJointTorque(a, q, qdot)`.\nThe derivative of *qdot* is given by the `biorbd` function that includes non-acceleration contact point defined in the bioMod: `qddot = bio_model.ForwardDynamics(q, qdot, tau)`.\n- **with_passive_torque = True:** The passive torque is taken into account in the *tau*.\n- **with_ligament = True:** The tau generated by the ligament is taken into account in the *tau*.\n- **with_residual_torque = True:** The torque driven defines the states (x) as *q* and *qdot* and the controls (u) as the *tau* and the muscle activations (*a*). \nThe actual *tau* is computed from the sum of *tau* to the muscle activation converted in muscle forces and thereafter converted to *tau* by the `biorbd` function: `bio_model.muscularJointTorque(a, q, qdot)`.\n- **with_excitations = True:** The torque driven defines the states (x) as *q*, *qdot* and muscle activations (*a*) and the controls (u) as the *tau* and the *EMG*.\nThe derivative of *a* is computed by the `biorbd` function: `adot = model.activationDot(emg, a)` \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9765080211177996,
      "result": {
        "original_header": "HOLOMOMIC_TORQUE_DRIVEN",
        "type": "Text_excerpt",
        "value": "This dynamics have been implemented to be used with `HolonomicBiorbdModel`. It is a torque driven only applied on the independent\ndegrees of freedom. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8878527904015409,
      "result": {
        "original_header": "CUSTOM",
        "type": "Text_excerpt",
        "value": "This leaves the user to define both the configuration (what are the states and controls) and to define the dynamic function. \nCUSTOM should not be called by the user, but the user should pass the configure_function directly. \nYou can have a look at Dynamics and DynamicsList sections for more information about how to configure and define custom dynamics. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9878826444448598,
      "result": {
        "original_header": "The bounds",
        "type": "Text_excerpt",
        "value": "The bounds provide a class that has minimal and maximal values for a variable.\nIt is, for instance, useful for the inequality constraints that limit the maximal and minimal values of the states (x) and the controls (u) .\nIn that sense, it is what is expected by the `OptimalControlProgram` for its `u_bounds` and `x_bounds` parameters. \nIt can however be used for much more.\nIf not provided for one variable, then it is -infinity to +infinity for that particular variable.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8990949129886402,
      "result": {
        "original_header": "Class: BoundsList",
        "type": "Text_excerpt",
        "value": "The BoundsList class is the main class to define bounds.\nThe constructor can be called by sending two boundary matrices (min, max) as such: `bounds[\"name\"] = min_bounds, max_bounds`. \nOr by providing a previously declared bounds: `bounds.add(\"name\", another_bounds)`.\nThe add nomenclature can also be used with the min and max, but must be specified as such: `bounds.add(\"name\", min_bound=min_bounds, max_bound=max_bounds)`.\nThe `min_bounds` and `max_bounds` matrices must have dimensions that fit the chosen `InterpolationType`, the default type being `InterpolationType.CONSTANT_WITH_FIRST_AND_LAST_DIFFERENT`, which is 3 columns. \nPlease note that to change any option, you must use the `.add` nomenclature \nIf the interpolation type is CUSTOM, then the bounds are function handlers of signature: \n```python\ncustom_bound(current_shooting_point: int, n_elements: int, n_shooting: int)\n```\nwhere current_shooting_point is the current point to return, n_elements is the number of expected lines and n_shooting is the number of total shooting point (that is if current_shooting_point == n_shooting, this is the end of the phase) \nThe main methods the user will be interested in is the `min` property that returns the minimal bounds and the `max` property that returns the maximal bounds. \nUnless it is a custom function, `min` and `max` are numpy.ndarray and can be directly modified to change the boundaries. \nIt is also possible to change `min` and `max` simultaneously by directly slicing the bounds as if it was a numpy.array, effectively defining an equality constraint: for instance `bounds[\"name\"][:, 0] = 0`.\nPlease note that if more than one phase is present in the bounds, then you must specify on which phase it should apply like so: `bounds[phase_index][\"name\"]...`\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9840254210528709,
      "result": {
        "original_header": "The initial conditions",
        "type": "Text_excerpt",
        "value": "The initial conditions the solver should start from, i.e., initial values of the states (x) and the controls (u).\nIn that sense, it is what is expected by the `OptimalControlProgram` for its `u_init` and `x_init` parameters. \nIf not specified for one variable, then it is set to zero for that particular variable. \n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9108529849587073,
      "result": {
        "original_header": "Class InitialGuessList",
        "type": "Text_excerpt",
        "value": "The full signature of `InitialGuessList.add` is as follows:\n```python\nInitialGuessList.add(\"name\", initial_guess, interpolation_type, phase)\n```\nThe first parameters are presented before.\nThe `phase` is the index of the phase the initial guess applies to. \nIf the interpolation type is CUSTOM, then the InitialGuess is a function handler of signature: \n```python\ncustom_init(current_shooting_point: int, n_elements: int, n_shooting: int)\n```\nwhere current_shooting_point is the current point to return, n_elements is the number of expected lines and n_shooting is the number of total shooting point (that is if current_shooting_point == n_shooting, this is the end of the phase) \nThe main methods the user will be interested in is the `init` property that returns the initial guess. \nUnless it is a custom function, `init` is a numpy.ndarray and can be directly modified to change the initial guess.  \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.980931890249473,
      "result": {
        "original_header": "The variable scaling",
        "type": "Text_excerpt",
        "value": "The scaling applied to the optimization variables, it is what is expected by the `OptimalControlProgram` for its `x_scaling`, `xdot_scaling` and `u_init` parameters. \n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9007977203968727,
      "result": {
        "original_header": "Class VariableScalingList",
        "type": "Text_excerpt",
        "value": "A VariableScalingList is a list of VariableScaling. \nThe `add()` method can be called exactly as if one was calling the `VariableScaling` constructor.   \nSo a minimal use is as follows:\n```python\nscaling = VariableScalingList()\nscaling.add(\"q\", scaling=[1, 1])\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9170352163637316,
      "result": {
        "original_header": "The constraints",
        "type": "Text_excerpt",
        "value": "The constraints are hard penalties of the optimization program.\nThat means the solution won't be considered optimal unless all the constraint set is fully respected.\nThe constraints come in two format: equality and inequality. \n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9408056645225333,
      "result": {
        "original_header": "Class: Constraint",
        "type": "Text_excerpt",
        "value": "The Constraint provides a class that prepares a constraint, so it can be added to the constraint set by `bioptim`.\nWhen constructing an `OptimalControlProgram()`, Constraint is the expected class for the `constraint` parameter. \nIt is also possible to later change the constraint by calling the method `update_constraints(the_constraint)` of the `OptimalControlProgram` \nThe Constraint class is the main class to define constraints.\nThe constructor can be called with the type of the constraint and the node to apply it to, as such: `constraint = Constraint(ConstraintFcn, node=Node.END)`. \nBy default, the constraint will be an equality constraint equals to 0. \nTo change this behaviour, one can add the parameters `min_bound` and `max_bound` to change the bounds to their desired values.  \nThe full signature of Constraint is as follows:\n```python\nConstraint(ConstraintFcn, node: node, index: list, phase: int, list_index: int, target: np.ndarray **extra_param)\n```\nThe first parameters are presented before.\nThe `list` is the list of elements to keep. \nFor instance, if one defines a TRACK_STATE constraint with `index=0`, then only the first state is tracked.\nThe default value is all the elements.\nThe `phase` is the index of the phase the constraint should apply to.\nIf it is not sent, phase=0 is assumed.\nThe `list_index` is the ith element of a list for a particular phase\nThis is usually taken care by the `add()` method of `ConstraintList`, but it can be useful when declaring the constraints out of order, or when overriding previously declared constraints using `update_constraints`.\nThe `target` is a value subtracted to the constraint value. \nIt is useful to define tracking problems.\nThe dimensions of the target must be of [index, node] \nThe `ConstraintFcn` class provides a list of some predefined constraint functions. \nSince this is an Enum, it is possible to use tab key on the keyboard to dynamically list them all, assuming you IDE allows for it. \nIt is possible however to define a custom constraint by sending a function handler in place of the `ConstraintFcn`.\nThe signature of this custom function is: `custom_function(pn: PenaltyController, **extra_params)`\nThe PenaltyController contains all the required information to act on the states and controls at all the nodes defined by `node`, while `**extra_params` are all the extra parameters sent to the `Constraint` constructor. \nThe function is expected to return an MX vector of the constraint to be inside `min_bound` and `max_bound`. \nPlease note that MX type is a CasADi type.\nAnyone who wants to define custom constraint should be at least familiar with this type beforehand. \n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9198355480367909,
      "result": {
        "original_header": "Class: ConstraintList",
        "type": "Text_excerpt",
        "value": "A ConstraintList is simply a list of Constraints. \nThe `add()` method can be called exactly as calling the `Constraint` constructor. \nIf the `add()` method is used more than once, the `list_index` parameter is automatically incremented for the prescribed `phase`.\nIf no `phase` is prescribed by the user, the first phase is assumed.  \nSo a minimal use is as follows:\n```python\nconstraint_list = ConstraintList()\nconstraint_list.add(constraint)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.945312735912057,
      "result": {
        "original_header": "Class: ConstraintFcn",
        "type": "Text_excerpt",
        "value": "The `ConstraintFcn` class is the declaration of all the already available constraints in `bioptim`. \nSince this is an Enum, it is possible to use the tab key on the keyboard to dynamically list them all, depending on the capabilities of your IDE. The existing contraint functions in alphabetical order:\n- **BOUND_STATE**  &mdash; Adds bounds on states. Same aim as `bounds[\"state_name\"] = min_bounds, max_bounds` but with a different numerical behaviour.\n- **BOUND_CONTROL**  &mdash; Adds bounds on controls. Same aim as `bounds[\"control_name\"] = min_bounds, max_bounds` but with a different numerical behaviour.\n- **NON_SLIPPING**  &mdash; Adds a constraint of static friction at contact points constraining for small tangential forces.  \nThis constraint assumes that the normal forces is positive (that is having an additional TRACK_CONTACT_FORCES with `max_bound=np.inf`). The extra parameters `tangential_component_idx: int`, `normal_component_idx: int`, and `static_friction_coefficient: float` must be passed to the `Constraint` constructor.\n- **PROPORTIONAL_CONTROL** &mdash; Links one control to another, such that `u[first_dof] - first_dof_intercept = coef * (u[second_dof] - second_dof_intercept)`. The extra parameters `first_dof: int` and `second_dof: int` must be passed to the `Constraint` constructor.\n- **PROPORTIONAL_STATE** &mdash; Links one state to another, such that `x[first_dof] - first_dof_intercept = coef * (x[second_dof] - second_dof_intercept)`. The extra parameters `first_dof: int` and `second_dof: int` must be passed to the `Constraint` constructor.\n- **SUPERIMPOSE_MARKERS** &mdash; Matches one marker with another one. The extra parameters `first_marker_idx: int` and `second_marker_idx: int` informs which markers are to be superimposed.\n- **TIME_CONSTRAINT**  &mdash; Adds the time to the optimization variable set. It will leave the time free within the given boundaries.\n- **TORQUE_MAX_FROM_ACTUATORS**  &mdash; Adds a constraint of maximal torque to the generalized forces controls such that the maximal *tau* are computed from the `biorbd` method `bio_model.torque_max(q, qdot)`. This is an efficient alternative to torque activation dynamics.  The extra parameter `min_torque` can be passed to ensure that the model is never too weak.\n- **TRACK_ALL_CONTROLS**  &mdash; Tracks all the control variables toward a target.\n- **TRACK_ANGULAR_MOMENTUM**  &mdash; Constraints the angular momentum in the global reference frame toward a target. The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be sent to specify the axes along which the momentum should be tracked.\n- **TRACK_COM_POSITION**  &mdash; Constraints the center of mass toward a target. The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be sent to specify the axes along which the center of mass should be tracked.\n- **TRACK_COM_VELOCITY**  &mdash; Constraints the center of mass velocity toward a target. The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be provided to specify the axes along which the velocity should be tracked.\n- **TRACK_CONTACT_FORCES**  &mdash; Tracks the non-acceleration point reaction forces toward a target.\n- **TRACK_LINEAR_MOMENTUM**  &mdash; Constraints the linear momentum toward a target. The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be sent to specify the axes along which the momentum should be tracked.\n- **TRACK_MARKER_WITH_SEGMENT_AXIS**  &mdash; Tracks a marker using a segment, that is aligning an axis toward the marker. The extra parameters `marker_idx: int`, `segment_idx: int`, and `axis: Axis` must be passed to the `Constraint` constructor\n- **TRACK_MARKERS_VELOCITY** &mdash; Tracks the skin marker velocities toward a target.\n- **TRACK_MARKERS** &mdash; Tracks the skin markers toward a target. The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be provided to specify the axes along which the markers should be tracked.\n- **TRACK_MUSCLES_CONTROL**  &mdash; Tracks the muscles (part of the control variables) toward a target.\n- **TRACK_SEGMENT_WITH_CUSTOM_RT**  &mdash;Links a segment with an RT (for instance, an Inertial Measurement Unit). It does so by computing the homogenous transformation between the segment and the RT and then converting this to Euler angles. The extra parameters `segment_idx: int` and `rt_idx: int` must be passed to the `Constraint` constructor.\n- **TRACK_STATE** &mdash; Tracks the state's variable toward a target.\n- **TRACK_TORQUE**  &mdash; Tracks the generalized forces (part of the control variables) toward a target.\n- **CUSTOM**  &mdash; The user should not directly send CUSTOM, but the user should pass the custom_constraint function directly. You can look at Constraint and ConstraintList sections for more information about how to define custom constraints. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8753402826359349,
      "result": {
        "original_header": "The objective functions",
        "type": "Text_excerpt",
        "value": "The objective functions are soft penalties of the optimization program.\nIn other words, the solution tries to minimize the value as much as possible but will not complain if the objective remains high.\nThe objective functions come in two formats: Lagrange and Mayer.  \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9521963621162022,
      "result": {
        "original_header": "Class: Objective",
        "type": "Text_excerpt",
        "value": "The Objective provides a class that prepares an objective function so that it can be added to the objective set by `bioptim`.\nWhen constructing an `OptimalControlProgram()`, Objective is the expected class for the `objective_functions` parameter. \nIt is also possible to later change the objective functions by calling the method `update_objectives(the_objective_function)` of the `OptimalControlProgram` \nThe Objective class is the main class to define objectives.\nThe constructor can be called with the type of the objective and the node to apply it to, as such: `objective = Objective(ObjectiveFcn, node=Node.END)`. \nPlease note that `ObjectiveFcn` should either be a `ObjectiveFcn.Lagrange` or `ObjectiveFcn.Mayer`. \nThe full signature of Objective is as follows:\n```python\nObjective(ObjectiveFcn, node: Node, index: list, phase: int, list_index: int, quadratic: bool, target: np.ndarray, weight: float, **extra_param)\n```\nThe first parameters are presented before.\nThe `list` is the list of elements to keep. \nWhen defining a MINIMIZE_STATE objective_function with `index=0`,  only the first state is minimized.\nThe default value is all the elements.\nThe `phase` is the index of the phase the objective function should apply to.\nIf it is not sent, phase=0 is assumed.\nThe `list_index` is the ith element of a list for a particular phase\nThis is usually taken care by the `add()` method of `ObjectiveList`, but it can be useful when declaring the objectives out of order or when overriding previously declared objectives using `update_objectives`.\n`quadratic` defines if the objective function should be squared. \nThis is particularly useful when minimizing toward 0 instead of minus infinity.\nThe `target` is a value subtracted from the objective value. \nIt is relevant to define tracking problems.\nThe dimensions of the target must be of [index, node].\nFinally, `weight` is the weighting that should be applied to the objective. \nThe higher the weight is, the more important the objective is compared to the other objective functions. \nThe `ObjectiveFcn` class provides a list of some predefined objective functions. \nSince `ObjectiveFcn.Lagrange` and `ObjectiveFcn.Mayer` are Enum, it is possible to use tab key on the keyboard to dynamically list them all, assuming you IDE allows for it. \nIt is possible, however, to define a custom objective function by sending a function handler in place of the `ObjectiveFcn`.\nIn this case, an additional parameter must be sent to the `Objective` constructor:  the `custom_type` with either `ObjectiveFcn.Lagrange` or `ObjectiveFcn.Mayer`.\nThe signature of the custom function is: `custom_function(pn: PenaltyController, **extra_params)`\nThe PenaltyController contains all the required information to act on the states and controls at all the nodes defined by `node`, while `**extra_params` are all the extra parameters sent to the `Objective` constructor. \nThe function is expected to return an MX vector of the objective function. \nPlease note that MX type is a CasADi type.\nAnyone who wants to define custom objective functions should be at least familiar with this type beforehand. \n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9223112748809899,
      "result": {
        "original_header": "Class: ObjectiveList",
        "type": "Text_excerpt",
        "value": "An ObjectiveList is a list of Objective. \nThe `add()` method can be called exactly as calling the `Objective` constructor. \nIf the `add()` method is used more than once, the `list_index` parameter is automatically incremented for the prescribed `phase`.\nIf no `phase` is prescribed by the user, the first phase is assumed.  \nSo a minimal use is as follows:\n```python\nobjective_list = ObjectiveList()\nobjective_list.add(objective)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9306366423462318,
      "result": {
        "original_header": "Class: ObjectiveFcn",
        "type": "Text_excerpt",
        "value": "Here a list of objective function with its type (Lagrange and/or Mayer) in alphabetical order: \n- **MINIMIZE_ALL_CONTROLS** (Lagrange) &mdash; Minimizes all the control variables toward zero (or a target).\n- **MINIMIZE_ANGULAR_MOMENTUM** (Lagrange and Mayer)  &mdash; Minimizes the angular momentum in the global reference frame toward zero (or a target). The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be provided to specify the axes along which the momentum should be minimized.\n- **MINIMIZE_COM_ACCELERATION** (Lagrange and Mayer)  &mdash; Minimizes the center of mass acceleration towards zero (or a target). The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be provided to specify the axes along which the acceleration should be minimized.\n- **MINIMIZE_COM_POSITION** (Lagrange and Mayer)  &mdash; Minimizes the center of mass position toward zero (or a target). The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be sent to specify the axes along which the center of mass should be minimized.\n- **MINIMIZE_COM_VELOCITY**  (Lagrange and Mayer)  &mdash; Minimizes the center of mass velocity towards zero (or a target). The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be provided to specify the axes along which the velocity should be minimized.\n- **MINIMIZE_CONTACT_FORCES** (Lagrange) &mdash; Minimizes the non-acceleration points of the reaction forces toward zero (or a target).\n- **MINIMIZE_LINEAR_MOMENTUM** (Lagrange and Mayer)  &mdash; Minimizes the linear momentum towards zero (or a target). The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be provided to specify the axes along which the momentum should be minimized.\n- **MINIMIZE_MARKERS_DISPLACEMENT** (Lagrange) &mdash; Minimizes the difference between a state at a node and the same state at the next node, effectively minimizing the velocity. The extra parameter `coordinates_system_idx` can be specified to compute the marker position in that coordinate system. Otherwise, it is computed in the global reference frame. \n- **MINIMIZE_MARKERS_VELOCITY or MINIMIZE_MARKERS_ACCELERATION** (Lagrange and Mayer) &mdash; Minimizes the marker velocities or accelerations toward zero (or a target).\n- **MINIMIZE_MARKERS** (Lagrange and Mayer) &mdash; Minimizes the position of the markers toward zero (or a target). The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be sent to specify the axes along which the markers should be minimized.\n- **MINIMIZE_MUSCLES_CONTROL** (Lagrange) &mdash;  Minimizes the muscles' controls (part of the control variables) toward zero (or a target).\n- **MINIMIZE_PREDICTED_COM_HEIGHT** (Mayer)  &mdash; Minimizes the maximal height of the center of mass, predicted from the parabolic equation, assuming vertical axis is Z (2): CoM_dot[2]**2 / (2 * -g) + CoM[2]. To maximize a jump, one can use this function at the end of the push-off phase and declare a weight of -1.\n- **MINIMIZE_SOFT_CONTACT_FORCES** (Lagrange) &mdash; Minimizes the external forces induced by soft contacts (or a target).\n- **MINIMIZE_STATE_DERIVATIVE** (Lagrange) &mdash; Minimizes the difference between a state at a node and the same state at the next node, i.e., minimizes the generalized state derivative.\n- **MINIMIZE_STATE** (Lagrange and Mayer) &mdash; Minimizes the state variable towards zero (or a target).\n- **MINIMIZE_TIME** (Lagrange and Mayer) &mdash; Adds the time to the optimization variable set. It will minimize the time toward minus infinity or a target. If the Mayer term is used, `min_bound` and `max_bound` can also be defined.\n- **MINIMIZE_TORQUE_DERIVATIVE** (Lagrange) &mdash; Minimizes the difference between a *tau* at a node and the same *tau* at the next node, i.e., minimizes the generalized forces derivative.\n- **MINIMIZE_TORQUE** (Lagrange) &mdash; Minimizes the generalized forces (part of the control variables) toward zero (or a target).\n- **PROPORTIONAL_CONTROL** (Lagrange) &mdash; Minimizes the difference between one control and another, such that `u[first_dof] - first_dof_intercept = coef * (u[second_dof] - second_dof_intercept)`. The extra parameters `first_dof: int` and `second_dof: int` must be passed to the `Objective` constructor.\n- **PROPORTIONAL_STATE** (Lagrange and Mayer) &mdash; Minimizes the difference between one state and another, such that `x[first_dof] - first_dof_intercept = coef * (x[second_dof] - second_dof_intercept)`. The extra parameters `first_dof: int` and `second_dof: int` must be passed to the `Objective` constructor.\n- **SUPERIMPOSE_MARKERS** (Lagrange and Mayer) &mdash; Tracks one marker with another one. The extra parameters `first_marker_idx: int` and `second_marker_idx: int` informs which markers are to be superimposed\n- **TRACK_ALL_CONTROLS (Lagrange)** &mdash; Tracks all the control variables toward a target.\n- **TRACK_CONTACT_FORCES** (Lagrange) &mdash; Tracks the non-acceleration points of the reaction forces toward a target.\n- **TRACK_MARKER_WITH_SEGMENT_AXIS** (Lagrange and Mayer) &mdash; Minimizes the distance between a marker and an axis of a segment, that is aligning an axis toward the marker. The extra parameters `marker_idx: int`, `segment_idx: int` and `axis: Axis` must be passed to the `Objective` constructor\n- **TRACK_MARKERS_VELOCITY or TRACK_MARKERS_ACCELERATION** (Lagrange and Mayer) &mdash;  Tracks the marker velocities or accelerations toward a target.\n- **TRACK_MARKERS** (Lagrange and Mayer) &mdash; Tracks the skin markers towards a target. The extra parameter `axis_to_track: Axis = (Axis.X, Axis.Y, Axis.Z)` can be sent to specify the axes along which the markers should be tracked.\n- **TRACK_MUSCLES_CONTROL** (Lagrange) &mdash; Tracks the muscles' controls (part of the control variables) toward a target.\n- **TRACK_SEGMENT_WITH_CUSTOM_RT** (Lagrange and Mayer)  &mdash; Minimizes the distance between a segment and an RT (for instance, an Inertial Measurement Unit). It does so by computing the homogenous transformation between the segment and the RT and then converting this to Euler angles. The extra parameters `segment_idx: int` and `rt_idx: int` must be passed to the `Objective` constructor.\n- **TRACK_SOFT_CONTACT_FORCES**  (Lagrange)  &mdash; Tracks the external forces induced by soft contacts toward a target.\n- **TRACK_STATE**  (Lagrange and Mayer) &mdash; Tracks the state variable toward a target.\n- **TRACK_TORQUE** (Lagrange &mdash; Tracks the generalized forces (part of the control variables) toward a target.\n- **CUSTOM** (Lagrange and Mayer)  &mdash; The user should not directly send CUSTOM, but pass the custom_objective function directly. \nYou can look at Objective and ObjectiveList sections for more information about defining custom objective function. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8902002205739096,
      "result": {
        "original_header": "The parameters",
        "type": "Text_excerpt",
        "value": "Parameters are time-independent variables (e.g., a muscle maximal isometric force, the value of gravity ). that affect the dynamics of the whole system. \nDue to the variety of parameters, it was impossible to provide predefined parameters but the time. \nTherefore, all the parameters are custom-made.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9610041749469346,
      "result": {
        "original_header": "Class: ParameterList",
        "type": "Text_excerpt",
        "value": "The ParameterList provides a class that prepares the parameters, so it can be added to the parameter set to optimize by `bioptim`.\nWhen constructing an `OptimalControlProgram()`, ParameterList is the expected class for the `parameters` parameter. \nIt is also possible to later change the parameters by calling the method `update_parameters(the_parameter_list)` of the `OptimalControlProgram` \nThe ParameterList class is the main class to define parameters.\nPlease note that, unlike other lists, `Parameter` is not accessible. This is for simplicity reasons, as it would complicate the API quite a bit to permit it.\nTherefore, one should not call the Parameter constructor directly.  \nHere is the full signature of the `add()` method of the `ParameterList`:\n```python\nParameterList.add(parameter_name: str, function: Callable, initial_guess: InitialGuess, bounds: Bounds, size: int, phase: int, **extra_parameters)\n```\nThe `parameter_name` is the parameter's name (reference for the output data as well).\nThe `function` is the function that modifies the biorbd model, it will be called just prior to applying the dynamics. \nThe signature of the custom function is: `custom_function(BioModel, MX, **extra_parameters)`, where BiorbdModel is the model to apply the parameter to, the MX is the value the parameter will take, and the `**extra_parameters` are those sent to the add() method.\nThis function is expected to modify the bio_model, and not return anything.\nPlease note that MX type is a CasADi type.\nAnyone who wants to define custom parameters should be at least familiar with this type beforehand.\nThe `initial_guess` is the initial value of the parameter.\nThe `bounds` are the maximal and minimal values of the parameter.\nThe `size` is the number of elements of this parameter.\nIf an objective function is provided, the return of the objective function should match the size.\nThe `phase` that the parameter applies to.\nEven though a parameter is time-independent, one biorbd_model is loaded per phase. \nSince parameters are associated to a specific bio_model, one must define a parameter per phase.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9762841879479414,
      "result": {
        "original_header": "The multinode constraints",
        "type": "Text_excerpt",
        "value": "`Bioptim` can declare multiphase optimisation programs. The goal of a multiphase ocp is usually to handle changing dynamics. \nThe user must understand that each phase is, therefore, a full ocp by itself, with constraints that links the end of which with the beginning of the following.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9021135092362398,
      "result": {
        "original_header": "Class: BinodeConstraintList",
        "type": "Text_excerpt",
        "value": "The BinodeConstraintList provides a class that prepares the binode constraints.\nWhen constructing an `OptimalControlProgram()`, BinodeConstraintList is the expected class for the `binode_constraints` parameter.  \nThe BinodeConstraintList class is the main class to define parameters.\nPlease note that, unlike other lists, `BinodeConstraint` is not accessible since binode constraints do not make sense for single-phase ocp.\nTherefore, one should not call the PhaseTransition constructor directly.  \nHere is the full signature of the `add()` method of the `BinodeConstraintList`:\n```python\nBinodeConstraintList.add(BinodeConstraintFcn, phase_first_idx, phase_second_idx, first_node, second_node, **extra_parameters)\n```\nThe `BinodeConstraintFcn` is binode constraints function to use.\nThe default is EQUALITY.\nWhen declaring a custom transition phase, BinodeConstraintFcn is the function handler to the custom function.\nThe signature of the custom function is: `custom_function(binode_constraint:BinodeConstraint, nlp_pre: NonLinearProgram, nlp_post: NonLinearProgram, **extra_parameters)`,\nwhere `nlp_pre` is the non linear program of the considered phase, `nlp_post` is the non linear program of the second considered phase, and the `**extra_parameters` are those sent to the add() method.\nThis function is expected to return the cost of the binode constraint computed in the form of an MX. Please note that MX type is a CasADi type.\nAnyone who wants to define binode constraints should be at least familiar with this type beforehand.\nThe `phase_first_idx` is the index of the first phase. \nThe `phase_second_idx` is the index of the second phase. \nThe `first_node` is the first node considered. \nThe `second_node` is the second node considered. \n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8987815892091773,
      "result": {
        "original_header": "Class: BinodeConstraintFcn",
        "type": "Text_excerpt",
        "value": "The `BinodeConstraintFcn` class is the already available binode constraint in `bioptim`. \nSince this is an Enum, it is possible to use the tab key on the keyboard to dynamically list them all, depending on the capabilities of your IDE.  \n- **EQUALITY**   &mdash; The states are equals.\n- **COM_EQUALITY**   &mdash; The positions of centers of mass are equals.\n- **COM_VELOCITY_EQUALITY**   &mdash; The velocities of centers of mass are equals.\n- **CUSTOM**   &mdash; CUSTOM should not be directly sent by the user, but the user should pass the custom_transition function directly. \nYou can look at the BinodeConstraintList section for more information about defining a custom transition function.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.970602439339119,
      "result": {
        "original_header": "The phase transitions",
        "type": "Text_excerpt",
        "value": "`Bioptim` can declare multiphase optimisation programs. \nThe goal of a multiphase ocp is usually to handle changing dynamics. \nThe user must understand that each phase is, therefore, a full ocp by itself, with constraints that links the end of which with the beginning of the following.\nDue to some limitations created by using MX variables, some things can be done, and some cannot during a phase transition. \n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8965230238579452,
      "result": {
        "original_header": "Class: PhaseTransitionList",
        "type": "Text_excerpt",
        "value": "The PhaseTransitionList provides a class that prepares the phase transitions.\nWhen constructing an `OptimalControlProgram()`, PhaseTransitionList is the expected class for the `phase_transitions` parameter.  \nThe PhaseTransitionList class is the main class to define parameters.\nPlease note that, unlike other lists, `PhaseTransition` is not accessible since phase transition does not make sense for single-phase ocp.\nTherefore, one should not call the PhaseTransition constructor directly.  \nHere is the full signature of the `add()` method of the `PhaseTransitionList`:\n```python\nPhaseTransitionList.add(PhaseTransitionFcn, phase_pre_idx, **extra_parameters)\n```\nThe `PhaseTransitionFcn` is the transition phase function to use.\nThe default is CONTINUOUS.\nWhen declaring a custom transition phase,  PhaseTransitionFcn is the function handler to the custom function.\nThe signature of the custom function is: `custom_function(transition: PhaseTransition nlp_pre: NonLinearProgram, nlp_post: NonLinearProgram, **extra_parameters)`,\nwhere `nlp_pre` is the nonlinear program at the end of the phase before the transition, `nlp_post` is the nonlinear program at the beginning of the phase after the transition, and the `**extra_parameters` are those sent to the add() method.\nThis function is expected to return the cost of the phase transition computed from the states pre- and post-transition in the form of an MX.\nPlease note that MX type is a CasADi type.\nAnyone who wants to define phase transitions should be at least familiar with this type beforehand.\nThe `phase_pre_idx` is the index of the phase before the transition.\nIf the `phase_pre_idx` is set to the index of the last phase, then this is equivalent to set `PhaseTransitionFcn.CYCLIC`.  \n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9812843108907726,
      "result": {
        "original_header": "Class: PhaseTransitionFcn",
        "type": "Text_excerpt",
        "value": "The `PhaseTransitionFcn` class is the already available phase transitions in `bioptim`. \nSince this is an Enum, it is possible to use the tab key on the keyboard to dynamically list them all, depending on the capabilities of your IDE.  \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.945522719835085,
      "result": {
        "original_header": "The results",
        "type": "Text_excerpt",
        "value": "`Bioptim` offers different ways to manage and visualize the results from an optimization. \nThis section explores the different methods that can be called to have a look at your data. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.91780471593308,
      "result": {
        "original_header": "Data manipulation",
        "type": "Text_excerpt",
        "value": "The Solution structure holds all the optimized values. \nTo get the states variable, control variables, and time, one can invoke each property.\n```python\nstates = sol.states\ncontrols = sol.controls\ntime = sol.time\n```\nIf the program was a single-phase problem, then the returned values are dictionaries, otherwise, it is a list of dictionaries of size equal to the number of phases.\nThe keys of the returned dictionaries correspond to the name of the variables. \nFor instance, if generalized coordinates (*q*) are states, the state dictionary has *q* as key.\nIn any case, the key `all` is always there.\n```python\n# single-phase case\nq = sol.states[\"q\"]  # generalized coordinates\nq = sol.states[\"all\"]  # all states\n# multiple-phase case - states of the first phase\nq = sol.states[0][\"q\"]\nq = sol.states[0][\"all\"]\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8951943031018601,
      "result": {
        "original_header": "Integrate",
        "type": "Text_excerpt",
        "value": "It is possible to integrate (also called simulate) the states at will by calling the `sol.integrate()` method.\nThe `shooting_type: Shooting` parameter allows you to select the type of integration to perform (see the enum Shooting for more detail).\nThe `keep_intermediate_points` parameter allows us to keep the intermediate shooting points (usually a multiple of n_steps of the Runge-Kutta) or collocation points.\nIf set to false, these points are not stored in the output structure.\nBy definition, setting `keep_intermediate_points` to True while asking for `Shooting.MULTIPLE` would return the same structure.\nThis will therefore raise an error if set to False with `Shooting.MULTIPLE`.\nThe `merge_phase: bool` parameter requests to merge all the phases into one [True] or not [False].\nThe `continuous: bool` parameter can be deceiving. It is mostly for internal purposes. \nHere are the tables of the combinations for `sol.integrate` and shooting_types.\nAs the argument `keep_intermediates_points` does not significantly affect the implementations, it has been withdrawn from the tables.\nIf implemented, it will be done with `keep_intermediates_points=True or False`. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9748458580524544,
      "result": {
        "original_header": "Shooting.SINGLE_DISCONTINUOUS_PHASES",
        "type": "Text_excerpt",
        "value": "Let's pursue with `shooting_type = Shooting.SINGLE_DISCONTINUOUS_PHASES`, it re-integrates each phase of the ocp as a single phase ocp.\nThus, SINGLE and SINGLE_DISCONTINUOUS_PHASES are equivalent if there is only one phase. Here is the table: \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9206126744294975,
      "result": {
        "original_header": "Shooting.MULTIPLE",
        "type": "Text_excerpt",
        "value": "Let us finish with `shooting_type = Shooting.MULTIPLE`,\nplease note that this cannot be used with `keep_intermediates_points=False`.\nAlso, the word `MULTIPLE` refers to direct multiple shooting. \nOdeSolver | <div style=\"width:110px\">merge_phase</div>  | <div style=\"width:80px\">Solution<br>Integrator</div> | Implemented | Comment|\n----|-------------|-----------|:----:|:-----------:|\nDMS | True | OCP | :white_check_mark: | |\nDMS | False | OCP | :white_check_mark: | |\nDMS | True | SCIPY | :white_check_mark: | |\nDMS | False | SCIPY | :white_check_mark: | |\nCOLLOCATION | True | OCP | :x: | The solution cannot be re-integrated with the ocp solver|\nCOLLOCATION | False | OCP | :x: | The solution cannot be re-integrated with the ocp solver|\nCOLLOCATION | True | SCIPY  | :white_check_mark: | This is re-integrated with solve_ivp, as direct multiple shooting problem |\nCOLLOCATION | False | SCIPY | :white_check_mark: | This is re-integrated with solve_ivp, as direct multiple shooting problem |\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9782097986626779,
      "result": {
        "original_header": "Merge phases",
        "type": "Text_excerpt",
        "value": "Please note that, apart from `sol.merge_phases()`, these data manipulation methods return an incomplete Solution structure.\nThis structure can be used for further analyses but cannot be used for visualization. \nIf one wants to visualize integrated or interpolated data, they must use the corresponding parameters or the visualization method they use.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.971662396434472,
      "result": {
        "original_header": "Data visualization",
        "type": "Text_excerpt",
        "value": "The first data visualizing method is `sol.graphs()`. \nThis method will spawn all the graphs associated with the ocp. \nThis is the same method that is called by the online plotter. \nTo add and modify plots, one should use the `ocp.add_plot()` method.\nBy default, this graphs the states as multiple shootings.\nIf one wants to simulate in single shooting, the option `shooting_type=Shooting.SINGLE` will do the trick. \nA second one is `sol.animate()`.\nThis method summons one or more `bioviz` figures (depending on whether phases were merged) and animates the model.\nPlease note that despite `bioviz` best efforts, plotting a lot of meshing vertices in MX format is slow.\nSo even though it is possible, it is suggested to animate without the bone meshing (by passing the parameter `show_meshes=False`)\nTo do so, we strongly suggest saving the data and loading them in an environment where `bioptim` is compiled with the Eigen backend, which will be much more efficient.\nIf `n_frames` is set, an interpolation is performed. Otherwise, the phases are merged if possible, so a single animation is shown. \nTo prevent phase merging, one can set `n_frames=-1`. \nIn order to print the values of the objective functions and constraints, one can use the `sol.print_cost()` method.\nIf the parameter `cost_type=CostType.OBJECTIVE` is passed, only the values of each objective functions are printed.\nThe same is true for the constraints with `CostType.CONSTRAINTS`.\nPlease note that for readability purposes, this method prints the sum by phases for the constraints. \n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9314483578707868,
      "result": {
        "original_header": "The extra stuff and the Enum",
        "type": "Text_excerpt",
        "value": "It was hard to categorize the remaining classes and enum. \nSo I present them in bulk in this extra stuff section.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8659886433953232,
      "result": {
        "original_header": "The mappings",
        "type": "Text_excerpt",
        "value": "The mapping is a way to link things stored in a list.\nFor instance, consider these vectors: a = [0, 0, 0, 10, -9] and b = [10, 9]. \nEven though they are quite different, they share some common values. \nIt is, therefore, possible to retrieve a from b, and conversely. \nThis is what the Mapping class does for the rows of numpy arrays.\nSo if one was to declare the following Mapping: `b_from_a = Mapping([3, -4])`.\nThen, assuming a is a numpy.ndarray column vector (`a = np.array([a]).T`), it would be possible to summon b from a like so: \n```python\nb = b_from_a.map(a)\n```\nNote that the `-4` opposed the fourth value.\nConversely, using the `a_from_b = Mapping([None, None, None, 0, -1])` mapping, and assuming b is a numpy.ndarray column vector (`b = np.array([b]).T`), it would be possible to summon b from a like so:\nBASH2*\nNote that the `None` are replaced by zeros. \nThe BiMapping is no more no less than a list of two mappings that link two matrices both ways: `BiMapping(a_to_b, b_to_a)` \nThe SelectionMapping is a subclass of BiMapping where you only have to precise the size of the first matrix, \nand the mapping b_to_a to get the second matrix from the first. If some elements depend on others, \nyou can add an argument dependency:`SelectionMapping(size(int), b_to_a; tuple[int, int, ...], dependencies :tuple([int, int, bool]))`\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9405628156958539,
      "result": {
        "original_header": "Class: OdeSolver",
        "type": "Text_excerpt",
        "value": "The ordinary differential equation (ode) solver to solve the dynamics of the system. \nThe RK4 and RK8 are the ones with the most options available.\nIRK may be more robust but slower. \nCVODES is the one with the least options since it is not in-house implemented. \nThe accepted values are:\n- For Direct multiple shooting:\n   - RK1: Runge-Kutta of the 1st order also known as Forward Euler\n   - RK2: Runge-Kutta of the 2nd order also known as Midpoint Euler\n   - RK4: Runge-Kutta of the 4th order\n   - RK8: Runge-Kutta of the 8th order\n   - IRK: Implicit Runge-Kutta (Legendre and Radau, from 0th to 9th order)\n   - CVODES: cvodes solver\n- For Direct collocation:\n   - COLLOCATION: Legendre and Radau, from 0th to 9th order\n   - TRAPEZOIDAL: Trapezoidal rule\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9938429559523936,
      "result": {
        "original_header": "Enum: Solver",
        "type": "Text_excerpt",
        "value": "The nonlinear solver to solve the whole ocp. \nEach solver has some requirements (for instance, \u0300`Acados` necessitates that the graph is SX). \nFeel free to test each of them to see which fits your needs best.\n\u0300`Ipopt` is a robust solver, that may be slow.\n\u0300`Acados`, on the other hand, is a very fast solver, but is much more sensitive to the relative weightings of the objective functions and the initial guess.\nIt is perfectly designed for MHE and NMPC problems. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9295474846807905,
      "result": {
        "original_header": "Enum: PhaseDynamics",
        "type": "Text_excerpt",
        "value": "The argument should be set to SHARED_DURING_THE_PHASE if we assume the dynamics are the same within each phase of the ocp problem. \nThis argument increases the speed to mount the problem; it should be considered each time you build an Optimal Control Program.\nThe default value is ONE_PER_NODE, meaning we consider the dynamic equations to be different for each shooting node (e.g., when applying a different external force at each shooting node). \nIn the case, you want to use this feature you have to specify it when adding the dynamics of each phase.\n```python3\ndynamics = Dynamics(DynamicsFcn.TORQUE_DRIVEN, phase_dynamics=PhaseDynamics.SHARED_DURING_THE_PHASE)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9216754224276452,
      "result": {
        "original_header": "Enum: ControlType",
        "type": "Text_excerpt",
        "value": "The accepted values are:\n- CONSTANT: The controls remain constant over the interval. The number of control is therefore equals to the number of shooting points.\n- LINEAR_CONTINUOUS: The controls are linearly interpolated over the interval. Since they are continuous, the end of an interval corresponds to the beginning of the next. The number of controls equals to the number of shooting point + 1 control.\n- CONSTANT_WITH_LAST_NODE: The controls remain constant over the interval. The number of control is therefore equals to the number of shooting point + 1 controls. (Note that the last control has no effect on the states so it should be constrained. This type of control is useful when you want the instantaneous slope of the states at the last node)\n- NONE: The problem has no controls. (It is useful if the system is driven by parameters)\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8786859044914737,
      "result": {
        "original_header": "Enum: PlotType",
        "type": "Text_excerpt",
        "value": "When adding a plot, it is possible to change the aspect of it. \nThe accepted values are:\nPLOT: Normal plot that links the points.\nINTEGRATED: Plot that links the points within an interval but is discrete between its end and the beginning of the next interval.\nSTEP: Step plot, constant over an interval.\nPOINT: Point plot.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9166811779851919,
      "result": {
        "original_header": "Enum: OnlineOptim",
        "type": "Text_excerpt",
        "value": "The type of online plotter to use. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9090283151863173,
      "result": {
        "original_header": "Enum: InterpolationType",
        "type": "Text_excerpt",
        "value": "Defines wow a time-dependent variable is interpolated.\nIt is mainly used for phases time span.\nTherefore, first and last nodes refer to the first and last nodes of a phase. \nThe accepted values are:\n- CONSTANT: Requires only one column; all the values are equal during the whole period of time.\n- CONSTANT_WITH_FIRST_AND_LAST_DIFFERENT: Requires three columns. The first and last columns correspond to the first and last nodes, while the middle corresponds to all the other nodes.\n- LINEAR: Requires two columns. It corresponds to the first and last nodes. The middle nodes are linearly interpolated to get their values.\n- EACH_FRAME: Requires as many columns as there are nodes. It is not an interpolation per se, but it allows the user to specify all the nodes individually.\n- ALL_POINTS: Requires as many columns as there are collocation points. It is not an interpolation per se, but it allows the user to specify all the collocation points individually.\n- SPLINE: Requires five columns. It performs a cubic spline to interpolate between the nodes.\n- CUSTOM: User-defined interpolation function.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9616994230167342,
      "result": {
        "original_header": "Enum: MagnitudeType",
        "type": "Text_excerpt",
        "value": "The type of magnitude you want for the added noise. Either relative to the bounds (0 is no noise, 1 is the value of your bounds), or absolute \nThe accepted values are:\n- ABSOLUTE: Absolute noise of a chosen magnitude.\n- RELATIVE: Relative noise to the bounds (0 is no noise, 1 is the value of your bounds).\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9842772969928446,
      "result": {
        "original_header": "Enum: Shooting",
        "type": "Text_excerpt",
        "value": "The type of integration to perform\n- SINGLE: It re-integrates the solution as a single-phase optimal control problem\n- SINGLE_DISCONTINUOUS_PHASE: It re-integrates each phase of the solution as a single-phase optimal control problem. The phases are, therefore, not continuous.\n- MULTIPLE: The word `MULTIPLE` is used as a common terminology to be able to execute DMS and COLLOCATION. It refers to the fact that there are several points per interval, shooting points in DMS and collocation points in COLLOCATION.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.924588480887013,
      "result": {
        "original_header": "Enum: QuadratureRule",
        "type": "Text_excerpt",
        "value": "The type of integration used to integrate the cost function terms of Lagrange:\n- RECTANGLE_LEFT: The integral is approximated by a left rectangle rule (Left Riemann sum).\n- RECTANGLE_RIGHT: The integral is approximated by a right rectangle rule (Right Riemann sum).\n- MIDPOINT: The integral is approximated by a midpoint rectangle rule (Midpoint Riemann sum).\n- APPROXIMATE_TRAPEZOIDAL: The integral is approximated by a trapezoidal rule using the state at the beginning of the next interval.\n- TRAPEZOIDAL: The integral is approximated by a trapezoidal rule using the state at the end of the current interval.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9950396109048649,
      "result": {
        "original_header": "Enum: RigidBodyDynamics",
        "type": "Text_excerpt",
        "value": "The type of transcription of any dynamics (e.g., rigidbody_dynamics or soft_contact_dynamics):\n- ODE: the dynamics is handled explicitly in the continuity constraint of the ordinary differential equation of the Direct Multiple Shooting approach.\n- DAE_INVERSE_DYNAMICS: it adds an extra control *qddot* to respect inverse dynamics on nodes; this is a DAE-constrained OCP.\n- DAE_FORWARD_DYNAMICS: it adds an extra control *qddot* to respect forward dynamics on nodes; this is a DAE-constrained OCP.\n- DAE_INVERSE_DYNAMICS_JERK: it adds an extra control *qdddot* and an extra state *qddot* to respect inverse dynamics on nodes; this is a DAE-constrained OCP.\n- DAE_FORWARD_DYNAMICS_JERK: it adds an extra control *qdddot* and an extra state *qddot* to respect forward dynamics on nodes; this is a DAE-constrained OCP.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9941684953818305,
      "result": {
        "original_header": "Enum: SoftContactDynamics",
        "type": "Text_excerpt",
        "value": "The type of transcription of any dynamics (e.g., rigidbody_dynamics or soft_contact_dynamics):\n- ODE: soft contact dynamics is handled explicitly.\n- CONSTRAINT: an extra control *fext* is added, and it ensures respecting soft contact_dynamics on nodes through a constraint.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8533364560536986,
      "result": {
        "original_header": "Performance",
        "type": "Text_excerpt",
        "value": "If you find yourself asking, \"Why is bioptim so slow? I thought it was lightning fast!\"\nThen this section may help you improve your code to get better performance.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8499088933462471,
      "result": {
        "original_header": "use_sx",
        "type": "Text_excerpt",
        "value": "Set use_sx to True in the OptimalControlProgram class to use the SX symbolic variables.\nThese are faster but require more RAM, so ensure you have enough RAM to use this option.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9400061931222988,
      "result": {
        "original_header": "n_threads",
        "type": "Text_excerpt",
        "value": "Set n_threads to the number of threads you want to use in the OptimalControlProgram class.\nBy default, it is set to 1. It will split the computation of the continuity constraints between threads and speed up the computation. If applicable to your problem, use the next option too.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9801839568245265,
      "result": {
        "original_header": "expand",
        "type": "Text_excerpt",
        "value": "(For objective and constraint functions)\nSet the expand argument to True for objective and constraint functions to speed up the computation.\nIt will turn MX symbolic variables into SX symbolic variables, which is faster but requires more RAM.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9564463262508233,
      "result": {
        "original_header": "Troubleshooting",
        "type": "Text_excerpt",
        "value": "Despite our best efforts to assist you with this long Readme and several examples, you may experience some problems with bioptim.\nFortunately, this troubleshooting section will guide you through solving some known issues.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9299909926055553,
      "result": {
        "original_header": "Freezing compute",
        "type": "Text_excerpt",
        "value": "If your computer freezes before any optimization is performed, it is probably because your problem requires too much RAM.\nIf you are using use_sx and/or expand options, try turning them off. If it does not work, try reducing the number of nodes.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9599300296950559,
      "result": {
        "original_header": "Free variables",
        "type": "Text_excerpt",
        "value": "Sometimes when working on advanced custom problems, you may have *free variables* that prevent the solver from being launched.\nIf this occurs, try reloading your model inside of the custom function. We have found this solution to be effective when working with biorbd models.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9934738335086015,
      "result": {
        "type": "Text_excerpt",
        "value": "\n`Bioptim` is an optimal control program (OCP) framework for biomechanics. \nIt is based on the efficient  biomechanics library and benefits from the powerful algorithmic diff provided by .\nIt interfaces the robust  and the fast  solvers to suit all your needs for solving OCP in biomechanics. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "documentation": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/pyomeca/bioptim/tree/master/docs"
      },
      "technique": "file_exploration"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/pyomeca/bioptim/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "executable_example": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://mybinder.org/v2/gh/pyomeca/bioptim-tutorial/HEAD?urlpath=lab"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "faq": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Defining our optimal control problems",
        "type": "Text_excerpt",
        "value": "Here we will detail our implementation of optimal control problems and some definitions.\nThe mathematical transcription of the OCP is as follows:\n![](docs/OCP_equation.jpg)\nThe optimization variables are the states (x = variables that represent the state of the system at each node and that \nare subject to continuity constraints), controls (u = decision variables defined at each node that drive the system),\nalgebraic states (s = optimization variables that are defined at each node but that are not subject to the \nbuilt-in continuity constraints), and parameters (p = optimization variables defined once per phase).\nThe state continuity constraints implementation may vary depending on the transcription of the problem (implicit vs explicit, direct multiple shooting vs direct collocations).\n\nThe cost function can include Mayer terms (function evaluated at one node, the default is the last node) and Lagrange terms (functions integrated over the duration of the phase).\nThe Lagrange terms are computed by default as EulerForward Integrals:\n```python\nL = 0\nfor i in range(n_shooting):\n  L += weight * sum((evaluated_cost[:, i] - target_cost[:, i])**2 * dt)\n```\nWhere `weight` is by default 1 and `target_cost` is by default 0. For more advanced approximations, see QuadratureRule section. They can be used to evaluate more accurately the Lagrange terms of the cost function.\nThe optimization variables can be subject to equality and/or inequality constraints.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Solving stochastic optimal control problems (SOCP)",
        "parent_header": [
          "A first practical example"
        ],
        "type": "Text_excerpt",
        "value": "It is possible to solve SOCP (also called optimal feedback control problem) using the class \n`StochasticOptimalControlProgram`. You just have to add the type of SOCP that you want to solve using \n`SocpType.TRAPEZOIDAL_EXPLICIT(motor_noise_magnitude, sensory_noise_magnitude)`,\n`SocpType.TRAPEZOIDAL_IMPLICIT(motor_noise_magnitude, sensory_noise_magnitude)`, or\n`SocpType.COLLOCATION(motor_noise_magnitude, sensory_noise_magnitude)`. \nOur implementation of SOCP is based on Van Wouwe 2022 (https://doi.org/10.1371/journal.pcbi.1009338). \nIn the examples folder examples/stochastic_optimal_control, you will find arm_reaching_muscle_driven.py which is our \nimplementation of the arm reaching task (6 muscles) described in the above-mentioned article.\nOur implementation of the integration of the covariance matrix with a collocation scheme is based on Gillis 2013 \n(https://ieeexplore.ieee.org/abstract/document/6761121).\nYou will also find our implementation of the example of Gillis 2013 in the same folder \n(obstacle_avoidance_collocations.py).\n\nWe recommend the user to use the SocpType.COLLOCATION implementation if a great level of dynamics consistency is \nneeded, or SocpType.TRAPEZOIDAL_IMPLICIT with a Cholesky decomposition of the covariance matrix for a faster \nresolution.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Non-converging problems",
        "parent_header": [
          "Troubleshooting"
        ],
        "type": "Text_excerpt",
        "value": "If Ipopt converges to an infeasible solution, ensure the boundaries are sound for the problem's constraints.\nIf the problem still does not converge, try changing the initial guess of the problem.\n\nIf the problem takes numerous iterations to solve (much more than expected), check the weights on objective functions and the weight of the actual variables.\n\nIf the problem still does not converge, try observing the evolution of the objective function and the constraints through a live plot.\nIt is always good to see how they evolve through the iterations.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 46
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/pyomeca/bioptim/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "pyomeca/bioptim"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "has_script_file": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/pyomeca/bioptim/master/external/acados_install_mac.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/pyomeca/bioptim/master/external/acados_install_linux.sh"
      },
      "technique": "file_exploration"
    }
  ],
  "identifier": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://zenodo.org/badge/latestdoi/251615517"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "images": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/pyomeca/bioptim/master/docs/OCP_equation.jpg"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "How to install",
        "type": "Text_excerpt",
        "value": "The preferred way to install for the lay user is using anaconda. \nAnother way, more designed for the core programmers, is from the sources. \nWhile it is theoretically possible to use `bioptim` from Windows, it is highly discouraged since it will require manually compiling all the dependencies. \nA great alternative for Windows users is *Ubuntu* on *Windows supporting Linux*.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Installing from Anaconda (For Windows, Linux, and Mac)",
        "parent_header": [
          "How to install"
        ],
        "type": "Text_excerpt",
        "value": "The easiest way to install `bioptim` is to download the binaries from [Anaconda](https://anaconda.org/) repositories. \nThe project is hosted on the conda-forge channel (https://anaconda.org/conda-forge/bioptim).\n\nAfter having appropriately installed an anaconda client [my suggestion would be Miniconda (https://conda.io/miniconda.html)] and loaded the desired environment to install `bioptim` in, just type the following command:\n```bash\nconda install -c conda-forge bioptim\n```\nThis will download and install all the dependencies and install `bioptim`. \nAnd that is it! \nYou can already enjoy bioptiming!\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Installing from the sources (For Linux, Mac, and Windows)",
        "parent_header": [
          "How to install"
        ],
        "type": "Text_excerpt",
        "value": "Installing from the sources is as easy as installing from Anaconda, with the difference that you will be required to download and install the dependencies by hand (see the section below). \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Linux - Installing dependencies with conda",
        "parent_header": [
          "How to install",
          "Installing from the sources (For Linux, Mac, and Windows)",
          "Dependencies"
        ],
        "type": "Text_excerpt",
        "value": "All these (except for \u0300`Acados` and the HSL lib) can easily be installed using (assuming the anaconda3 environment is loaded if needed) the `pip3` command or the Anaconda's following command:\n```bash\nconda install biorbd bioviz python-graphviz -cconda-forge\n```\nSince there is no `Anaconda` nor `pip3` package of `Acados`, a convenient installer is provided with `bioptim`. \nThe installer can be found and run at `[ROOT_BIOPTIM]/external/acados_install_linux.sh`.\nHowever, the installer requires an `Anaconda3` environment.\nIf you have an `Anaconda3` environment loaded, the installer should find itself where to install it. \nIf you want to install it elsewhere, you can provide the script with a first argument which is the `$CONDA_PREFIX`. \nThe second argument that can be passed to the script is the `$BLASFEO_TARGET`. \nIf you don't know what it is, it is probably better to keep the default. \nPlease note that depending on your computer architecture, `Acados` may or may not work correctly.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Mac - Installing dependencies with conda",
        "parent_header": [
          "How to install",
          "Installing from the sources (For Linux, Mac, and Windows)",
          "Dependencies"
        ],
        "type": "Text_excerpt",
        "value": "Equivalently for MacOSX:\n```bash\nconda install casadi 'rbdl' 'biorbd' 'bioviz' python-graphviz -cconda-forge\n```\nSince there is no `Anaconda` nor `pip3` package of `Acados`, a convenient installer is provided with `bioptim`.\nThe `Acados` installation script is `[ROOT_BIOPTIM]/external/acados_install_mac.sh`.\nHowever, the installer requires an `Anaconda3` environment.\nIf you have an `Anaconda3` environment loaded, the installer should find itself where to install it. \nIf you want to install it elsewhere, you can provide the script with a first argument, the `$CONDA_PREFIX`. \nThe second argument that can be passed to the script is the `$BLASFEO_TARGET`. \nIf you don't know what it is, it is probably better to keep the default. \nPlease note that depending on your computer architecture, `Acados` may or may not work correctly.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Windows - Installing dependencies with conda",
        "parent_header": [
          "How to install",
          "Installing from the sources (For Linux, Mac, and Windows)",
          "Dependencies"
        ],
        "type": "Text_excerpt",
        "value": "Equivalently for Windows:\n```bash\nconda install casadi 'rbdl' 'biorbd' 'bioviz' python-graphviz -cconda-forge\n```\nThere is no `Anaconda` nor `pip3` package of `Acados`.\nTo use the `Acados` solver on Windows, one must compile it themselves.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The case of HSL solvers",
        "parent_header": [
          "How to install",
          "Installing from the sources (For Linux, Mac, and Windows)",
          "Dependencies"
        ],
        "type": "Text_excerpt",
        "value": "HSL is a collection of state-of-the-art packages for large-scale scientific computation. \nAmong its best-known packages are those for the solution of sparse linear systems (`ma27`, `ma57`, etc.), compatible with \u0300`Ipopt`.\nHSL packages are [available](http://www.hsl.rl.ac.uk/download/coinhsl-archive-linux-x86_64/2014.01.17/) at no cost for academic research and teaching. \nOnce you obtain the HSL dynamic library (precompiled `libhsl.so` for Linux, to be compiled `libhsl.dylib` for MacOSX, `libhsl.dll` for Windows), you just have to place it in your `Anaconda3` environment into the `lib/` folder.\nYou can now use all the options of `bioptim`, including the HSL linear solvers with `Ipopt`.\nWe recommend using `ma57` as a default linear solver by calling as such:\n```python\nsolver = Solver.IPOPT()\nsolver.set_linear_solver(\"ma57\")\nocp.solve(solver)\n```"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Installation complete",
        "parent_header": [
          "How to install"
        ],
        "type": "Text_excerpt",
        "value": "Once `bioptim` is downloaded, navigate to the root folder and (assuming your conda environment is loaded if needed), you can type the following command:\n```bash \npython setup.py install\n```\nAssuming everything went well, that is it! \nYou can already enjoy bioptimizing!\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.9877925101203914,
      "result": {
        "original_header": "Status",
        "type": "Text_excerpt",
        "value": "| Type | Status |\n|---|---|\n| License | <a href=\"https://opensource.org/licenses/MIT\"><img src=\"https://img.shields.io/badge/license-MIT-success\" alt=\"License\"/></a> |\n| Continuous integration | [![Build status](https://github.com/pyomeca/bioptim/actions/workflows/run_tests.yml/badge.svg)](https://github.com/pyomeca/bioptim/actions) |\n| Code coverage | [![codecov](https://codecov.io/gh/pyomeca/bioptim/branch/master/graph/badge.svg?token=NK1V6QE2CK)](https://codecov.io/gh/pyomeca/bioptim) |\n| DOI | [![DOI](https://zenodo.org/badge/251615517.svg)](https://zenodo.org/badge/latestdoi/251615517) | \nThe current status of `bioptim` on conda-forge is \n| Name | Downloads | Version | Platforms | MyBinder |\n| --- | --- | --- | --- | --- |\n| [![Conda Recipe](https://img.shields.io/badge/recipe-bioptim-green.svg)](https://anaconda.org/conda-forge/bioptim) | [![Conda Downloads](https://img.shields.io/conda/dn/conda-forge/bioptim.svg)](https://anaconda.org/conda-forge/bioptim) | [![Conda Version](https://img.shields.io/conda/vn/conda-forge/bioptim.svg)](https://anaconda.org/conda-forge/bioptim) | [![Conda Platforms](https://img.shields.io/conda/pn/conda-forge/bioptim.svg)](https://anaconda.org/conda-forge/bioptim) | [![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/pyomeca/bioptim-tutorial/HEAD?urlpath=lab) |\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9877352560497643,
      "result": {
        "original_header": "Table of Contents",
        "type": "Text_excerpt",
        "value": "[Testing bioptim](#try-bioptim)\n<details>\n<summary><a href=\"#how-to-install\">How to install</a></summary> \n  - <details>\n    <summary><a href=\"#the-variable-scaling\">The variable scaling</a></summary> \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9871571768990355,
      "result": {
        "original_header": "Class: OptimalControlProgram",
        "type": "Text_excerpt",
        "value": "Note that options can be passed to the solver parameter.\nOne can refer to their respective solver's documentation to know which options exist.\nThe `show_online_optim` parameter can be set to `True` so the graphs nicely update during the optimization with the default values.\nOne can also directly declare `online_optim` as an `OnlineOptim` parameter to customize the behavior of the plotter. \nNote that `show_online_optim` and `online_optim` are mutually exclusive.\nPlease also note that `OnlineOptim.MULTIPROCESS` is not available on Windows and only none of them are available on Macos. \nTo see how to run the server on Windows, please refer to the `getting_started/pendulum.py` example.\nIt is expected to slow down the optimization a bit. \n`show_options` can be also passed as a dict to the plotter to customize the plotter's behavior.\nIf `online_optim` is set to `SERVER`, then a server must be started manually by instantiating an `PlottingServer` class (see `ressources/plotting_server.py`).\nThe following keys are additional options when using `OnlineOptim.SERVER` and `OnlineOptim.MULTIPROCESS_SERVER`:\n  - `host`: the host to use (default is `localhost`)\n  - `port`: the port to use (default is `5030`) \nFinally, one can save and load previously optimized values by using\n```python\nocp.save(solution, file_path)\nocp, solution = OptimalControlProgram.load(file_path)\n```\nIMPORTANT NOTICE: Please note that saved solution depends on the `bioptim` version used to create the .bo file, and retro-compatibility is NOT enforced.\nIn other words, an optimized solution from a previous version will probably NOT load on a newer `bioptim` version.\nTo save the solution in a way independent of the version of `bioptim`, one may use the `stand_alone` flag to `True`. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9523332731388767,
      "result": {
        "original_header": "The dynamics",
        "type": "Text_excerpt",
        "value": "The following section investigates how to instruct `bioptim` of the dynamic equations the system should follow. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8906290550326833,
      "result": {
        "original_header": "Class: DynamicsList",
        "type": "Text_excerpt",
        "value": "So a minimal use is as follows:\n```python\ndyn_list = DynamicsList()\ndyn_list.add(DynamicsFcn)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9943890140940816,
      "result": {
        "original_header": "Class: BoundsList",
        "type": "Text_excerpt",
        "value": "Please note that to change any option, you must use the `.add` nomenclature \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9873893482072648,
      "result": {
        "original_header": "Class InitialGuessList",
        "type": "Text_excerpt",
        "value": "If someone wants to add noise to the initial guess, you can provide the following:\n```python\ninit = init.add_noise(\n    bounds: BoundsList, \n    magnitude: list | int | float | np.ndarray,\n    magnitude_type: MagnitudeType, n_shooting: int, \n    bound_push: list | int | float, \n    seed: int\n    )\n```\nThe bounds must contain all the keys defined in the init list.\nThe parameters, except `MagnitudeType` must be specified for each phase unless you want the same value for every phases. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8906290550326833,
      "result": {
        "original_header": "Class VariableScalingList",
        "type": "Text_excerpt",
        "value": "So a minimal use is as follows:\n```python\nscaling = VariableScalingList()\nscaling.add(\"q\", scaling=[1, 1])\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8906290550326833,
      "result": {
        "original_header": "Class: ConstraintList",
        "type": "Text_excerpt",
        "value": "So a minimal use is as follows:\n```python\nconstraint_list = ConstraintList()\nconstraint_list.add(constraint)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8906290550326833,
      "result": {
        "original_header": "Class: ObjectiveList",
        "type": "Text_excerpt",
        "value": "So a minimal use is as follows:\n```python\nobjective_list = ObjectiveList()\nobjective_list.add(objective)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9862056164767005,
      "result": {
        "original_header": "Enum: PhaseDynamics",
        "type": "Text_excerpt",
        "value": "In the case, you want to use this feature you have to specify it when adding the dynamics of each phase.\n```python3\ndynamics = Dynamics(DynamicsFcn.TORQUE_DRIVEN, phase_dynamics=PhaseDynamics.SHARED_DURING_THE_PHASE)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9999999740097113,
      "result": {
        "original_header": "Enum: OnlineOptim",
        "type": "Text_excerpt",
        "value": "The accepted values are:\nNONE: No online plotter.\nDEFAULT: Use the default online plotter depending on the OS (MULTIPROCESS on Linux, MULTIPROCESS_SERVER on Windows and NONE on MacOS).\nMULTIPROCESS: The online plotter is in a separate process.\nSERVER: The online plotter is in a separate server.\nMULTIPROCESS_SERVER: The online plotter using the server automatically setup on a separate process.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9983022792625189,
      "result": {
        "original_header": "Troubleshooting",
        "type": "Text_excerpt",
        "value": "Despite our best efforts to assist you with this long Readme and several examples, you may experience some problems with bioptim.\nFortunately, this troubleshooting section will guide you through solving some known issues.\n \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9963801006259346,
      "result": {
        "type": "Text_excerpt",
        "value": "<img\n      src=\"https://github.com/pyomeca/biorbd_design/blob/main/logo_png/bioptim_full.png\"\n      alt=\"logo\"\n    /> \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "invocation": [
    {
      "confidence": 0.8473652459188526,
      "result": {
        "original_header": "Table of Contents",
        "type": "Text_excerpt",
        "value": "<details>\n<summary><a href=\"#a-first-practical-example\">A first practical example</a></summary> \n\n        \n<details>\n<summary><a href=\"#examples\">Examples</a></summary> \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/pyomeca/bioptim/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "biomechanics, casadi, control, direct-collocation, direct-multiple-shooting, discrete-mechanics, dmoc, dmocc, fatigue-dynamics, forward-simulation, moving-horizon-estimation, musculoskeletal-model, musculoskeletal-simulations, optimal-control, robotics, stochastic-optimal-control"
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "MIT License",
        "spdx_id": "MIT",
        "type": "License",
        "url": "https://api.github.com/licenses/mit",
        "value": "https://api.github.com/licenses/mit"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "MIT License\n\nCopyright (c) 2020 Pariterre\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/LICENSE",
      "technique": "file_exploration"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "bioptim"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "Organization",
        "value": "pyomeca"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "Python",
        "size": 2882679,
        "type": "Programming_language",
        "value": "Python"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "releases": [
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2024-08-15T15:11:58Z",
        "date_published": "2024-08-15T15:14:22Z",
        "description": "What's maintainers? Have you forgotten me? I need to get free! I need releases! \r\nNow there are too much changes to tell the most important one... You made this to yourself! So people, enjoy the new me!\r\n\r\n## What's Changed\r\n* [RTR] Add state and control bounds using constraints by @mickaelbegon in https://github.com/pyomeca/bioptim/pull/817\r\n* Fixed parameters optimization for multiple phases by @pariterre in https://github.com/pyomeca/bioptim/pull/819\r\n* Fix on custom_model.py + test by @Ipuch in https://github.com/pyomeca/bioptim/pull/822\r\n* fix: restore example simulation in getting started by @Ipuch in https://github.com/pyomeca/bioptim/pull/823\r\n* [RTR] fix key in minimize parameters -tests/examples will be created afterwards by @mickaelbegon in https://github.com/pyomeca/bioptim/pull/834\r\n* [RTM when modify] spring load - explore more objective function - tests will come later by @mickaelbegon in https://github.com/pyomeca/bioptim/pull/840\r\n* [RTM after next push] SOCP: Making the noise dependant on the states + controls by @EveCharbie in https://github.com/pyomeca/bioptim/pull/809\r\n* [RTM after push] Provide two examples of minmax OCP with extra parameters  by @mickaelbegon in https://github.com/pyomeca/bioptim/pull/835\r\n* feat: test_entry_size; bound_checking biorbd_model by @Infa60 in https://github.com/pyomeca/bioptim/pull/832\r\n* [RTM?] SOCP collocation scaling by @EveCharbie in https://github.com/pyomeca/bioptim/pull/842\r\n* Implemented time in dynamic by @pariterre in https://github.com/pyomeca/bioptim/pull/843\r\n* scouting by @pariterre in https://github.com/pyomeca/bioptim/pull/845\r\n* Fixing Lagrange multipliers plotting by @SamHybz in https://github.com/pyomeca/bioptim/pull/849\r\n* doc(biorbd_holonomic_model) by @Ipuch in https://github.com/pyomeca/bioptim/pull/847\r\n* [RTR] Parameters uniformisation by @EveCharbie in https://github.com/pyomeca/bioptim/pull/846\r\n* Correcting RK4 and RK8 time integration calculation by @Kev1CO in https://github.com/pyomeca/bioptim/pull/850\r\n* [RTR] Fixing target plots by @EveCharbie in https://github.com/pyomeca/bioptim/pull/851\r\n* [RTR] refactor(maintaining plots) by @Ipuch in https://github.com/pyomeca/bioptim/pull/855\r\n* [RTM when tests pass] Extra checks in holonomic model by @Ipuch in https://github.com/pyomeca/bioptim/pull/854\r\n* [RTR] Implement manual graph display for pendulum test by @EveCharbie in https://github.com/pyomeca/bioptim/pull/856\r\n* [RTR] FIX: example which had an unexpected behavior, and a new that new implementation should pass by @Mart1t1 in https://github.com/pyomeca/bioptim/pull/826\r\n* [RTM when test passes] Fix self[phase] in path condition by @Kev1CO in https://github.com/pyomeca/bioptim/pull/860\r\n* [RTM after next push] fix: linear continuous multiphase continuity by @Ipuch in https://github.com/pyomeca/bioptim/pull/857\r\n* [RTR] catching when reading by @Ipuch in https://github.com/pyomeca/bioptim/pull/861\r\n* [RTR] Fix sol.integrate shooting.single continuity by @Kev1CO in https://github.com/pyomeca/bioptim/pull/859\r\n* mamba by @EveCharbie in https://github.com/pyomeca/bioptim/pull/864\r\n* [RTM] external forces as symbolic variables to allow multi-threading by @EveCharbie in https://github.com/pyomeca/bioptim/pull/865\r\n* [RTR] bounds in model clarified by @Ipuch in https://github.com/pyomeca/bioptim/pull/862\r\n* Delete Notes by @Ipuch in https://github.com/pyomeca/bioptim/pull/870\r\n* Needed to merge the two PRs here  by @EveCharbie in https://github.com/pyomeca/bioptim/pull/867\r\n* [RTR] Save IPOPT output by @EveCharbie in https://github.com/pyomeca/bioptim/pull/871\r\n* [RTR] very small doc addition by @EveCharbie in https://github.com/pyomeca/bioptim/pull/873\r\n* doc: image equation in doc by @Ipuch in https://github.com/pyomeca/bioptim/pull/875\r\n* [RTR] Fixed friction by @Ipuch in https://github.com/pyomeca/bioptim/pull/876\r\n* Fixing multi_biorbd_model by @pariterre in https://github.com/pyomeca/bioptim/pull/879\r\n* docs: scoot numerical_time_series by @Ipuch in https://github.com/pyomeca/bioptim/pull/878\r\n* Fixed ACADOS for Macos by @pariterre in https://github.com/pyomeca/bioptim/pull/880\r\n* [RTR] graphs: fix the holonomic case by @Ipuch in https://github.com/pyomeca/bioptim/pull/884\r\n* holonomic graph multiphase multi all combinations by @Ipuch in https://github.com/pyomeca/bioptim/pull/885\r\n* feat: pyorerun interfaced by @Ipuch in https://github.com/pyomeca/bioptim/pull/882\r\n* Time dependent tests by @Kev1CO in https://github.com/pyomeca/bioptim/pull/886\r\n* [RTM] New plotting! by @pariterre in https://github.com/pyomeca/bioptim/pull/887\r\n* Removed useless recomputing of yticks by @pariterre in https://github.com/pyomeca/bioptim/pull/890\r\n* Fixing some problem MULTIPROCESS_SERVER by @pariterre in https://github.com/pyomeca/bioptim/pull/888\r\n\r\n## New Contributors\r\n* @Infa60 made their first contribution in https://github.com/pyomeca/bioptim/pull/832\r\n* @SamHybz made their first contribution in https://github.com/pyomeca/bioptim/pull/849\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_3.2.0...Release_3.2.1",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_3.2.1",
        "name": "TooMuchToTell",
        "release_id": 170383491,
        "tag": "Release_3.2.1",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_3.2.1",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/170383491",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/170383491",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_3.2.1"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2024-01-11T18:03:16Z",
        "date_published": "2024-01-11T18:08:24Z",
        "description": "Over the time, dust accumulate to the point you don't see the floor anymore... electronic code does not make exception! Therefore Bioptimn needed a huge dedusting from years of development\r\n\r\nSpringCleaning is a rewrite of the core dynamics of bioptim, not so much of the API except for few breaking changes. All in all, this is a very welcome breath of fresh air for Bioptim!\r\n\r\n## What's Changed\r\n* [RTR] fix on live optimization by @Ipuch in https://github.com/pyomeca/bioptim/pull/702\r\n* [RTM] Bug and BoundsList by @20chupin in https://github.com/pyomeca/bioptim/pull/703\r\n* [RTM] Ipopt options were problematic by @Ipuch in https://github.com/pyomeca/bioptim/pull/709\r\n* [RTM] IntegralApproximation -> QuadratureRule by @20chupin in https://github.com/pyomeca/bioptim/pull/704\r\n* [RTM] restoring the right types for protocols and markervelocities by @Ipuch in https://github.com/pyomeca/bioptim/pull/708\r\n* BiorrbdModelHolonomic and VariationalBiorbdModel in core by @20chupin in https://github.com/pyomeca/bioptim/pull/699\r\n* [RTR] some little test on preparing the data for animation of tracked markers. by @Ipuch in https://github.com/pyomeca/bioptim/pull/714\r\n* [RTR] StochastiOCP merge by @EveCharbie in https://github.com/pyomeca/bioptim/pull/715\r\n* [RTR] solver options ipopt test by @Ipuch in https://github.com/pyomeca/bioptim/pull/723\r\n* [RTM] Restoring bounds on graphs by @EveCharbie in https://github.com/pyomeca/bioptim/pull/724\r\n* [RTM] show bounds test in ocp by @Ipuch in https://github.com/pyomeca/bioptim/pull/728\r\n* [RTM if tests pass] implicit formulation of the SOCP by @EveCharbie in https://github.com/pyomeca/bioptim/pull/721\r\n* [RTM] added multi-node penalties to objective plots by @EveCharbie in https://github.com/pyomeca/bioptim/pull/726\r\n* Made expand modifiable from API by @pariterre in https://github.com/pyomeca/bioptim/pull/727\r\n* [RTM when answered] Add min power (joint and muscle) - typo in Readme - new strategy of CI by @mickaelbegon in https://github.com/pyomeca/bioptim/pull/733\r\n* [RTM if tests pass] Cholesky decomposition of the covariance matrix by @EveCharbie in https://github.com/pyomeca/bioptim/pull/731\r\n* [RTM when #733 is merged] controls piecewise constant with last node by @EveCharbie in https://github.com/pyomeca/bioptim/pull/737\r\n* change way to report coverage by @mickaelbegon in https://github.com/pyomeca/bioptim/pull/740\r\n* [RTR] s_scaling good version by @EveCharbie in https://github.com/pyomeca/bioptim/pull/734\r\n* [RTM] add trapezoidal integrator by @EveCharbie in https://github.com/pyomeca/bioptim/pull/738\r\n* [RTM] Not compute the defects if not in implicit by @EveCharbie in https://github.com/pyomeca/bioptim/pull/742\r\n* DMOCC now working entirely with honomic constraints. by @Ipuch in https://github.com/pyomeca/bioptim/pull/736\r\n* [RTR] Refactor new_variable by @Ipuch in https://github.com/pyomeca/bioptim/pull/730\r\n* [RTM] collocations for SOCP by @EveCharbie in https://github.com/pyomeca/bioptim/pull/744\r\n* [RTM when tests pass] changed reshape_to_vector/matrix for good (test breaking) by @EveCharbie in https://github.com/pyomeca/bioptim/pull/750\r\n* [RTM when tests pass] Including custom functions as built-ins for stochastic problems by @EveCharbie in https://github.com/pyomeca/bioptim/pull/743\r\n* [RTR] Multi-threading in SOCP_COLLOCATION by @EveCharbie in https://github.com/pyomeca/bioptim/pull/753\r\n* [RTR] extra models for futher computations by @Ipuch in https://github.com/pyomeca/bioptim/pull/757\r\n* [To be deleted] Running tests on all platforms by @pariterre in https://github.com/pyomeca/bioptim/pull/758\r\n* [WIP] Unique dynamic function for time dependent problem by @Kev1CO in https://github.com/pyomeca/bioptim/pull/718\r\n* [RTR] tiny commit to help everyone debugging by @Ipuch in https://github.com/pyomeca/bioptim/pull/760\r\n* [RTR] Multimodel, I need animation and displaced the file for more convinience by @Ipuch in https://github.com/pyomeca/bioptim/pull/761\r\n* [RTM] Wild refactor trying to understand what's going on in compute_values for graphics by @Ipuch in https://github.com/pyomeca/bioptim/pull/762\r\n* Fixed custom_plot by @pariterre in https://github.com/pyomeca/bioptim/pull/767\r\n* [RTR] Unit test on helper function. by @Ipuch in https://github.com/pyomeca/bioptim/pull/764\r\n* Migrating to biorbd 1.10.0 by @pariterre in https://github.com/pyomeca/bioptim/pull/768\r\n* [RTM when tests pass] Time dependent test correction by @Kev1CO in https://github.com/pyomeca/bioptim/pull/759\r\n* FIxed a bug of time in plot for multiphase programs by @pariterre in https://github.com/pyomeca/bioptim/pull/769\r\n* Update README.md with PhaseDynamics instead of assume_phase_dynamics by @Ipuch in https://github.com/pyomeca/bioptim/pull/774\r\n* get_u isolated as a helper+ unit test by @Ipuch in https://github.com/pyomeca/bioptim/pull/775\r\n* [RTM when ping] SOCP_COLLOCATION corrections to make it right :) by @EveCharbie in https://github.com/pyomeca/bioptim/pull/771\r\n* [RTR] removing assume_phase from readme by @Kev1CO in https://github.com/pyomeca/bioptim/pull/777\r\n* [RTM when tests pass] external forces moved out of ocp too by @Ipuch in https://github.com/pyomeca/bioptim/pull/779\r\n* [RTM when tests pass] Using integrate_extra_dynamics instead of duplicating code by @EveCharbie in https://github.com/pyomeca/bioptim/pull/780\r\n* [RTR] Stochastic variables should not be inputs of OCP by @Ipuch in https://github.com/pyomeca/bioptim/pull/765\r\n* [RTM when tested] Added a multi-node constraint for the total duration of the movement by @EveCharbie in https://github.com/pyomeca/bioptim/pull/782\r\n* [RTM] Added more complex example of optimal estimation  by @EveCharbie in https://github.com/pyomeca/bioptim/pull/784\r\n* Minibug patch by @Ipuch in https://github.com/pyomeca/bioptim/pull/786\r\n* some unit test in integration for stability purpose. by @Ipuch in https://github.com/pyomeca/bioptim/pull/785\r\n* [RTR] Solving a critical issue of codeclimate by @Ipuch in https://github.com/pyomeca/bioptim/pull/788\r\n* [RTR] Try to refactor a bit the initialisation of Solution by @Ipuch in https://github.com/pyomeca/bioptim/pull/787\r\n* [RTM when tests pass] Refactor solution with classmethods by @Ipuch in https://github.com/pyomeca/bioptim/pull/789\r\n* [RTM when tests pass] Breaking up solution in multiple scripts by @Ipuch in https://github.com/pyomeca/bioptim/pull/790\r\n* [RTR] Udpate min max + test by @Ipuch in https://github.com/pyomeca/bioptim/pull/798\r\n* [RTR] duplicate_collocation_starting_point by @Ipuch in https://github.com/pyomeca/bioptim/pull/796\r\n* [RTR] Refactoring solver interface utils for the better by @Ipuch in https://github.com/pyomeca/bioptim/pull/793\r\n* [RTR] Mayer_TRACK_CONTACT_FORCES by @Alpha2Shahiri in https://github.com/pyomeca/bioptim/pull/797\r\n* [RTM when tests pass] Reorganize files by @Ipuch in https://github.com/pyomeca/bioptim/pull/792\r\n* [RTM] Added the commit ID + version to sol by @EveCharbie in https://github.com/pyomeca/bioptim/pull/806\r\n* Major refactor towards 3.2.0 by @pariterre in https://github.com/pyomeca/bioptim/pull/814\r\n* [RTM] Commit for mickael by @Ipuch in https://github.com/pyomeca/bioptim/pull/811\r\n* [RTM] yml code climate by @Ipuch in https://github.com/pyomeca/bioptim/pull/800\r\n* Final stretch of the reformating! by @pariterre in https://github.com/pyomeca/bioptim/pull/816\r\n\r\n## New Contributors\r\n* @Alpha2Shahiri made their first contribution in https://github.com/pyomeca/bioptim/pull/797\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_3.1.0...Release_3.2.0",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_3.2.0",
        "name": "SpringCleaning",
        "release_id": 136710980,
        "tag": "Release_3.2.0",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_3.2.0",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/136710980",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/136710980",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_3.2.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2023-06-23T16:24:49Z",
        "date_published": "2023-06-23T16:28:31Z",
        "description": "The new order is a deep state conspiracy... Here at pyomeca, we believe in shallow state, still we need to be ordered anyway. So thanks to the new way of declaring initial guesses and bounds, no one can be mistaken anymore on the order of the variables!\r\n\r\n## What's Changed\r\n* [RTR] Multi Biorbd Model  by @EveCharbie in https://github.com/pyomeca/bioptim/pull/625\r\n* Selection Mapping (to simplify BiMapping of variables call) by @lsechoir in https://github.com/pyomeca/bioptim/pull/619\r\n* extract final cycles of Cyclic NMPC and evaluate the cost of sub cycles by @Ipuch in https://github.com/pyomeca/bioptim/pull/633\r\n* [RTM if tests pass] inverse OCP by @EveCharbie in https://github.com/pyomeca/bioptim/pull/635\r\n* [RTR] Fixing a bug on BiMapping by @20chupin in https://github.com/pyomeca/bioptim/pull/636\r\n* [RTM] Sample data control by @Kev1CO in https://github.com/pyomeca/bioptim/pull/628\r\n* [RTR] Reverted the default behavior of copying the mappings by @EveCharbie in https://github.com/pyomeca/bioptim/pull/639\r\n* [RTM] moving test to make windows test pass by @Ipuch in https://github.com/pyomeca/bioptim/pull/640\r\n* [RTM] Work around for the memory leak in the meantime by @EveCharbie in https://github.com/pyomeca/bioptim/pull/645\r\n* [RTM] New multi-start debug options by @lsechoir in https://github.com/pyomeca/bioptim/pull/634\r\n* [RTR] added an objective function to minimize the angle between two vectors by @EveCharbie in https://github.com/pyomeca/bioptim/pull/649\r\n* [RTM] added an objective to minimize JCS orientation by @EveCharbie in https://github.com/pyomeca/bioptim/pull/648\r\n* [RTM] Added intercept for proportional states/controls by @EveCharbie in https://github.com/pyomeca/bioptim/pull/646\r\n* [RTM] sol.graphs crashes if Meyer term in objective  by @lsechoir in https://github.com/pyomeca/bioptim/pull/644\r\n* [RTR] Quickly restoring same dynamics in phases and multithreading efficiency. by @Ipuch in https://github.com/pyomeca/bioptim/pull/652\r\n* Correction to TRACK_VECTOR_ORIENTAION_FROM_MARKERS by @EveCharbie in https://github.com/pyomeca/bioptim/pull/651\r\n* troubleshoot DOCUMENTATION by @Ipuch in https://github.com/pyomeca/bioptim/pull/656\r\n* [RTR] CX for each node by @AnaisFarr in https://github.com/pyomeca/bioptim/pull/630\r\n* Fix for Casadi 3.6.2 on Mac by @pariterre in https://github.com/pyomeca/bioptim/pull/660\r\n* [RTR] Enable cost fun evaluation with control type none by @Kev1CO in https://github.com/pyomeca/bioptim/pull/658\r\n* Changed default value for show_online by @pariterre in https://github.com/pyomeca/bioptim/pull/661\r\n* [RTR] Maintain biorbdModel and MultiBiorbdModel health by @Ipuch in https://github.com/pyomeca/bioptim/pull/662\r\n* [RTM] bug with states mapping  while using multimodel by @lsechoir in https://github.com/pyomeca/bioptim/pull/647\r\n* Replaced state[\"scaled\"] by state.scaled by @pariterre in https://github.com/pyomeca/bioptim/pull/663\r\n* Started to change [0] for node_index by @pariterre in https://github.com/pyomeca/bioptim/pull/668\r\n* [RTR] Test for map_states and map_controls by @EveCharbie in https://github.com/pyomeca/bioptim/pull/671\r\n* [RTR] bug with derivative=True and node=Node.ALL by @EveCharbie in https://github.com/pyomeca/bioptim/pull/670\r\n* [RTR] Enable nlp.time(node_index) and ocp.time(phase_index, node_index) by @Kev1CO in https://github.com/pyomeca/bioptim/pull/659\r\n* Continuing integrating proper assume_phase_dynamics by @pariterre in https://github.com/pyomeca/bioptim/pull/673\r\n* [RTR] empty initial guess / scaling problem  by @EveCharbie in https://github.com/pyomeca/bioptim/pull/666\r\n* Fixed parameters when assume_phase_dynamics is False by @pariterre in https://github.com/pyomeca/bioptim/pull/674\r\n* Finalizing tests for assume_phase_dynamics=False by @pariterre in https://github.com/pyomeca/bioptim/pull/675\r\n* Validated more global tests for assume_phase_dynamics True and False by @pariterre in https://github.com/pyomeca/bioptim/pull/676\r\n* Made the BioModel protocol working with @properties  by @pariterre in https://github.com/pyomeca/bioptim/pull/678\r\n* [RTR] Enables the plotting of time bimapped problems by @Kev1CO in https://github.com/pyomeca/bioptim/pull/669\r\n* Converted Binode into multinode by @pariterre in https://github.com/pyomeca/bioptim/pull/679\r\n* Updated ACADOS by @Ipuch in https://github.com/pyomeca/bioptim/pull/682\r\n* [RTR] Fixed add_penalty_plot index by @EveCharbie in https://github.com/pyomeca/bioptim/pull/665\r\n* [RTR] same_marker_velocity and docstrings scooted by @Ipuch in https://github.com/pyomeca/bioptim/pull/687\r\n* [RTM] Variational integrator by @20chupin in https://github.com/pyomeca/bioptim/pull/696\r\n* Fix scaling by @pariterre in https://github.com/pyomeca/bioptim/pull/684\r\n* [WIP] Bis Min_max_torque (Pariterre to fix) by @EveCharbie in https://github.com/pyomeca/bioptim/pull/683\r\n\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_3.0.1...Release_3.1.0",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_3.1.0",
        "name": "TheNewOrder",
        "release_id": 109717786,
        "tag": "Release_3.1.0",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_3.1.0",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/109717786",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/109717786",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_3.1.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2023-03-06T15:36:09Z",
        "date_published": "2023-03-06T15:53:50Z",
        "description": "Twins are special, unique, they are inseparable. But at some point in their live, they must get their own live. It is the same for dynamic constraints in an optimal control program. Even though, they seem identical, they have their own personality that must be acknowledged. \r\n\r\nConstraints between shooting node are now independent, assuring that they work properly. Bioptim is better, stronger and happier!\r\n\r\n## What's Changed\r\n* Correct bug with bioviz version by @20chupin in https://github.com/pyomeca/bioptim/pull/611\r\n* [RTR] \"Union\" to \"|\" by @20chupin in https://github.com/pyomeca/bioptim/pull/613\r\n* [RTR] QandQdotBounds Issues by @Kev1CO in https://github.com/pyomeca/bioptim/pull/604\r\n* [RTM] Removed an occurrence of nb_q by @pariterre in https://github.com/pyomeca/bioptim/pull/612\r\n* [RTR] prevents further errors in inital guess size by @AntoineLeroy in https://github.com/pyomeca/bioptim/pull/617\r\n* Add residual torque to TORQUE_ACTIVATIONS_DRIVEN function by @AnaisFarr in https://github.com/pyomeca/bioptim/pull/623\r\n* [RTRT] Addressing a small issue. by @Ipuch in https://github.com/pyomeca/bioptim/pull/629\r\n* [RTR] adressing node specific dynamics by @Ipuch in https://github.com/pyomeca/bioptim/pull/624\r\n* Fix passive torque example by @AntoineLeroy in https://github.com/pyomeca/bioptim/pull/626\r\n* [RTR]PR changes for ligaments by @AntoineLeroy in https://github.com/pyomeca/bioptim/pull/614\r\n\r\n## New Contributors\r\n* @20chupin made their first contribution in https://github.com/pyomeca/bioptim/pull/611\r\n* @Kev1CO made their first contribution in https://github.com/pyomeca/bioptim/pull/604\r\n* @AnaisFarr made their first contribution in https://github.com/pyomeca/bioptim/pull/623\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_3.0.0...Release_3.0.1",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_3.0.1",
        "name": "SeparatedTwins",
        "release_id": 94654427,
        "tag": "Release_3.0.1",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_3.0.1",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/94654427",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/94654427",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_3.0.1"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2023-01-26T21:15:37Z",
        "date_published": "2023-01-26T21:16:44Z",
        "description": "Dynamics is the core nature of most, if not all, things; at least for every instance of moving things. Bioptim was restrained to one type of dynamics and it made it sad. How can I describe the world if I cannot define my own dynamics, it was saying. Don't be sad no more, Bioptim, 'cause now, all dynamics are at your door! This new release disconnect biorbd from the core of bioptim allowing for arbitrary dynamics to be implemented. This is exciting! This opens bioptim to a lot of new usage! We are so optimist with what you can bring to the world that I'd say we are bioptimistic!\r\n\r\n## What's Changed\r\n* Added the capability to apply fatigue directly to joint torque by @pariterre in https://github.com/pyomeca/bioptim/pull/542\r\n* [RTR] Issue#550 correction by @rapidnico in https://github.com/pyomeca/bioptim/pull/552\r\n* [RTR] more detailed detailed costs by @Ipuch in https://github.com/pyomeca/bioptim/pull/545\r\n* [RTR] integration rule tested in collocation by @Ipuch in https://github.com/pyomeca/bioptim/pull/546\r\n* [RTR] noise magnitude controled for each decision variable by @Ipuch in https://github.com/pyomeca/bioptim/pull/553\r\n* [RTR] SQP method interface by @EveCharbie in https://github.com/pyomeca/bioptim/pull/556\r\n* Update README.md by @fbailly in https://github.com/pyomeca/bioptim/pull/558\r\n* Github actions pot and fixing all the PRs by @Ipuch in https://github.com/pyomeca/bioptim/pull/565\r\n* Multi-start module by @EveCharbie in https://github.com/pyomeca/bioptim/pull/555\r\n* [RTR] Implicit defect type for muscles by @Ipuch in https://github.com/pyomeca/bioptim/pull/561\r\n* Allowed for bioviz 2.2.0 as the changes don't impact bioptim by @pariterre in https://github.com/pyomeca/bioptim/pull/566\r\n* [RTR] Creation of to_noised_initial_guess function by @rapidnico in https://github.com/pyomeca/bioptim/pull/560\r\n* [RTR] Fix target size with multi threads by @AntoineLeroy in https://github.com/pyomeca/bioptim/pull/574\r\n* [RTM] SQP test by @EveCharbie in https://github.com/pyomeca/bioptim/pull/569\r\n* [RTM] multi-start values testing by @EveCharbie in https://github.com/pyomeca/bioptim/pull/570\r\n* [RTM] Multi-model (phase mapping) by @EveCharbie in https://github.com/pyomeca/bioptim/pull/548\r\n* [RTR] Check Conditioning by @Julo0 in https://github.com/pyomeca/bioptim/pull/573\r\n* [RTR] correction of graphs for mapped tau by @lsechoir in https://github.com/pyomeca/bioptim/pull/582\r\n* [RTR] Model interface for a wider use of bioptim by @Ipuch in https://github.com/pyomeca/bioptim/pull/581\r\n* [WIP] Variable scaling by @EveCharbie in https://github.com/pyomeca/bioptim/pull/572\r\n* [RTR] inverse defects on joint acceleration driven by @Ipuch in https://github.com/pyomeca/bioptim/pull/577\r\n* [RTR] updating to numpy 1.24 by @Ipuch in https://github.com/pyomeca/bioptim/pull/590\r\n* Update README.md by @Ipuch in https://github.com/pyomeca/bioptim/pull/589\r\n* [RTR] split final MHE save by @Ipuch in https://github.com/pyomeca/bioptim/pull/592\r\n* Fix variable naming by @Ipuch in https://github.com/pyomeca/bioptim/pull/597\r\n* Partly addressing QandQdotBounds Issues by @Ipuch in https://github.com/pyomeca/bioptim/pull/599\r\n* Changed name of clear_penalty to ensure_penalty_sanity by @pariterre in https://github.com/pyomeca/bioptim/pull/600\r\n* [WIP] Passive Torque by @AntoineLeroy in https://github.com/pyomeca/bioptim/pull/584\r\n* setup install fix by @Ipuch in https://github.com/pyomeca/bioptim/pull/602\r\n* [RTM] add error for model path type by @AntoineLeroy in https://github.com/pyomeca/bioptim/pull/605\r\n* release checklist by @Ipuch in https://github.com/pyomeca/bioptim/pull/607\r\n* Fixed the versions by @pariterre in https://github.com/pyomeca/bioptim/pull/608\r\n\r\n## New Contributors\r\n* @AntoineLeroy made their first contribution in https://github.com/pyomeca/bioptim/pull/574\r\n* @Julo0 made their first contribution in https://github.com/pyomeca/bioptim/pull/573\r\n* @lsechoir made their first contribution in https://github.com/pyomeca/bioptim/pull/582\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_2.3.0...Release_3.0.0",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_3.0.0",
        "name": "Bioptimistic ",
        "release_id": 90353795,
        "tag": "Release_3.0.0",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_3.0.0",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/90353795",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/90353795",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_3.0.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2022-09-22T18:27:22Z",
        "date_published": "2022-09-22T18:38:05Z",
        "description": "\"Over the see, no one can see\" - No name (actually no one... but who cares!)\r\nWhen one looks at the horizon, they can't see past a certain point. Too far is the horizon, too much water separate them to the new world ahead. When they are sailing that see, the same can be said for the land behind. They must forgot where they are from, to focus on where they are going. \r\n\r\nBioptim is a sailor, no one can remember what happened between that release and the previous one. Bioptim has so evolved, it cannot see over its own see of changes\r\n\r\n## What's Changed\r\n* Readme update and trapezoidal integration of cost function by @Ipuch in https://github.com/pyomeca/bioptim/pull/458\r\n* Semi-explicit and rigid contacts by @Ipuch in https://github.com/pyomeca/bioptim/pull/426\r\n* Time vector returned by integrate by @EveCharbie in https://github.com/pyomeca/bioptim/pull/453\r\n* print bounds of controls and states  by @AurelienRenou in https://github.com/pyomeca/bioptim/pull/461\r\n* fixing an error because of merge by @Ipuch in https://github.com/pyomeca/bioptim/pull/463\r\n* Playing with qddot  by @Ipuch in https://github.com/pyomeca/bioptim/pull/466\r\n* small fix manage unit target by @Ipuch in https://github.com/pyomeca/bioptim/pull/467\r\n* merge master into crazydynamics by @Ipuch in https://github.com/pyomeca/bioptim/pull/464\r\n* minimize comddot without qddot as variable by @Ipuch in https://github.com/pyomeca/bioptim/pull/469\r\n* Multinode Constraint Plot by @Ipuch in https://github.com/pyomeca/bioptim/pull/470\r\n* COM AND COM VELOCITY multinode constraints by @Ipuch in https://github.com/pyomeca/bioptim/pull/472\r\n* changed len to shape by @EveCharbie in https://github.com/pyomeca/bioptim/pull/473\r\n* Terminology PR by @Ipuch in https://github.com/pyomeca/bioptim/pull/465\r\n* merge master into crazy dynamics by @Ipuch in https://github.com/pyomeca/bioptim/pull/474\r\n* if we have radau and inverse dynamics constraints in collocation by @Ipuch in https://github.com/pyomeca/bioptim/pull/448\r\n* tested examples by @Sciancisco in https://github.com/pyomeca/bioptim/pull/475\r\n* fixed examples by @thasaarah in https://github.com/pyomeca/bioptim/pull/476\r\n* Muscle implicit dynamics by @aceglia in https://github.com/pyomeca/bioptim/pull/459\r\n* more info in detailed_cost by @Ipuch in https://github.com/pyomeca/bioptim/pull/482\r\n* States without intermediate states in case of collocation by @Ipuch in https://github.com/pyomeca/bioptim/pull/484\r\n* [RTR] changed the example to match symmetry_by_mapping/constraint by @EveCharbie in https://github.com/pyomeca/bioptim/pull/481\r\n* [RTM] Free floating dynamics by @Sciancisco in https://github.com/pyomeca/bioptim/pull/488\r\n* [RTM] random_initial_condition_example by @EveCharbie in https://github.com/pyomeca/bioptim/pull/486\r\n* [RTM] graphs uneven number of variables by @EveCharbie in https://github.com/pyomeca/bioptim/pull/483\r\n* track qddot as constraint by @Ipuch in https://github.com/pyomeca/bioptim/pull/497\r\n* defecttype on other ode solvers by @Ipuch in https://github.com/pyomeca/bioptim/pull/498\r\n* [RTM?] Detailed cost dimension bug for markers target by @EveCharbie in https://github.com/pyomeca/bioptim/pull/495\r\n* [RTM] qddot as statedot by @Ipuch in https://github.com/pyomeca/bioptim/pull/505\r\n* [RTM] animated tracked markers by @thasaarah in https://github.com/pyomeca/bioptim/pull/500\r\n* [RTM] Pull master in crazydynamics by @Ipuch in https://github.com/pyomeca/bioptim/pull/490\r\n* [RTR] Change pendulum acados example for more realistic results by @aceglia in https://github.com/pyomeca/bioptim/pull/508\r\n* [RTM] NoisedInitialGuess properly scale within bounds by @Ipuch in https://github.com/pyomeca/bioptim/pull/506\r\n* [RTM] Mayer on first node with acados by @aceglia in https://github.com/pyomeca/bioptim/pull/501\r\n* [RTM] Change solver option set and turn back to the initial set convergence.  by @aceglia in https://github.com/pyomeca/bioptim/pull/502\r\n* [RTR] Shape bug when the index list contains only one index by @EveCharbie in https://github.com/pyomeca/bioptim/pull/511\r\n* Better fcn enum by @Sciancisco in https://github.com/pyomeca/bioptim/pull/512\r\n* [RTR] master merged into CrazyDynamics to mare sure everything fits by @Ipuch in https://github.com/pyomeca/bioptim/pull/514\r\n* [RTR] implicit defect works in torque driven. by @Ipuch in https://github.com/pyomeca/bioptim/pull/515\r\n* merging FcnEnum by @Ipuch in https://github.com/pyomeca/bioptim/pull/518\r\n* Crazy dynamics by @pariterre in https://github.com/pyomeca/bioptim/pull/519\r\n* scoot some documentation by @Ipuch in https://github.com/pyomeca/bioptim/pull/522\r\n* docstring by @Ipuch in https://github.com/pyomeca/bioptim/pull/525\r\n* [RTM] collocation initial guess by @thasaarah in https://github.com/pyomeca/bioptim/pull/504\r\n* [RTM] continuity constraints are well displayed by @Ipuch in https://github.com/pyomeca/bioptim/pull/513\r\n* [RTR] States_no_intermediate handles a merged solution. by @Ipuch in https://github.com/pyomeca/bioptim/pull/520\r\n* [RTR] Names of variables in figures handles variable mapping by @Ipuch in https://github.com/pyomeca/bioptim/pull/524\r\n* [RTM] Check black earlier in the build to save some time by @Sciancisco in https://github.com/pyomeca/bioptim/pull/526\r\n* [RTM] Continuity objective take2 by @Sciancisco in https://github.com/pyomeca/bioptim/pull/516\r\n* [RTR] scoot docstrings by @Ipuch in https://github.com/pyomeca/bioptim/pull/529\r\n* [RTR] initial guess with interpolationType.EACHFRAME by @Ipuch in https://github.com/pyomeca/bioptim/pull/531\r\n* scoot docstrings in optimization_variable.py by @rapidnico in https://github.com/pyomeca/bioptim/pull/532\r\n* [RTR] readme update (do not use .bo) by @EveCharbie in https://github.com/pyomeca/bioptim/pull/535\r\n* Made the error message even better! by @pariterre in https://github.com/pyomeca/bioptim/pull/539\r\n* [RTR] MinimizeQDDOT by @Ipuch in https://github.com/pyomeca/bioptim/pull/528\r\n* [RTR] Refactor Integration by @Ipuch in https://github.com/pyomeca/bioptim/pull/534\r\n* [RTR] check if code is blacked independantly in github actions by @Ipuch in https://github.com/pyomeca/bioptim/pull/530\r\n* [WIP] Update Acados to the last release (v0.1.8) by @aceglia in https://github.com/pyomeca/bioptim/pull/509\r\n\r\n## New Contributors\r\n* @AurelienRenou made their first contribution in https://github.com/pyomeca/bioptim/pull/461\r\n* @Sciancisco made their first contribution in https://github.com/pyomeca/bioptim/pull/475\r\n* @thasaarah made their first contribution in https://github.com/pyomeca/bioptim/pull/476\r\n* @rapidnico made their first contribution in https://github.com/pyomeca/bioptim/pull/532\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_2.2.2...Release_2.3.0",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_2.3.0",
        "name": "SeeOfChanges",
        "release_id": 77915057,
        "tag": "Release_2.3.0",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_2.3.0",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/77915057",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/77915057",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_2.3.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2022-04-29T19:40:28Z",
        "date_published": "2022-04-29T19:43:04Z",
        "description": "Sometime continuing what you started instead of rebuilding from ground is a good thing. Therefore, having LINEAR_CONTINUOUS plots which show the actual continuity of plotting was important. It is now fixed\r\n\r\n## What's Changed\r\n* Fix a Bug in LINEAR CONTINUOUS control when plotting objectives. by @Ipuch in https://github.com/pyomeca/bioptim/pull/457\r\n* checking version for article fix by @Ipuch in https://github.com/pyomeca/bioptim/pull/460\r\n\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_2.2.1...Release_2.2.2",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_2.2.2",
        "name": "Continuity",
        "release_id": 65710655,
        "tag": "Release_2.2.2",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_2.2.2",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/65710655",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/65710655",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_2.2.2"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2022-04-04T17:54:37Z",
        "date_published": "2022-04-04T18:08:35Z",
        "description": "Bioptim was recently used to spice up gymastic as it can now optimally control avatar in salto movements!\r\n\r\n## What's Changed\r\n* Removed unecessary import by @pariterre in https://github.com/pyomeca/bioptim/pull/434\r\n* Handling multiphase problems with implicit dynamics by @Ipuch in https://github.com/pyomeca/bioptim/pull/435\r\n* fix a Docstring by @pariterre in https://github.com/pyomeca/bioptim/pull/446\r\n* custom phase transition update by @Ipuch in https://github.com/pyomeca/bioptim/pull/439\r\n* Ignored plots for phase_transition by @EveCharbie in https://github.com/pyomeca/bioptim/pull/433\r\n* added angular momentum and linear momentum as built in functions by @EveCharbie in https://github.com/pyomeca/bioptim/pull/437\r\n* Handle equality constraints on specified nodes. by @Ipuch in https://github.com/pyomeca/bioptim/pull/444\r\n* Added cost details to sol by @EveCharbie in https://github.com/pyomeca/bioptim/pull/440\r\n* Allow the user to not expand the dynamics if wanted by @Ipuch in https://github.com/pyomeca/bioptim/pull/454\r\n\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_2.2.0...Release_2.2.1",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_2.2.1",
        "name": "SaltAndPepper",
        "release_id": 63550728,
        "tag": "Release_2.2.1",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_2.2.1",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/63550728",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/63550728",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_2.2.1"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2022-01-15T20:31:03Z",
        "date_published": "2022-01-15T20:33:16Z",
        "description": "The name pretty much sums it all.\r\nThis is the version used to generate the results for my PhD :) Hurray!\r\n\r\n## What's Changed\r\n* Fix issue for acados compilation by @aceglia in https://github.com/pyomeca/bioptim/pull/410\r\n* Fixed effort perception and RHO by @pariterre in https://github.com/pyomeca/bioptim/pull/419\r\n* full string as method for ode solvers by @Ipuch in https://github.com/pyomeca/bioptim/pull/415\r\n* Allow multiple phase transitions by @Ipuch in https://github.com/pyomeca/bioptim/pull/418\r\n* Fixed Fatigue Perception and Xia by @pariterre in https://github.com/pyomeca/bioptim/pull/422\r\n* Standardized the name of a file by @pariterre in https://github.com/pyomeca/bioptim/pull/423\r\n* Plot soft contact forces by @Ipuch in https://github.com/pyomeca/bioptim/pull/408\r\n* Changed default value of scaling in PerceptionEffort by @pariterre in https://github.com/pyomeca/bioptim/pull/425\r\n* update docstring of configure_problem.py by @Ipuch in https://github.com/pyomeca/bioptim/pull/427\r\n* Added the iterations and fixed timer in receding horizon by @pariterre in https://github.com/pyomeca/bioptim/pull/428\r\n* Added a tag to get all the outputs when MHE by @pariterre in https://github.com/pyomeca/bioptim/pull/431\r\n* now handling parameter optimisation with implicit dynamics such as time. by @Ipuch in https://github.com/pyomeca/bioptim/pull/430\r\n\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_2.1.1...Release_2.2.0",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_2.2.0",
        "name": "PhD",
        "release_id": 57203584,
        "tag": "Release_2.2.0",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_2.2.0",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/57203584",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/57203584",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_2.2.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2021-11-18T19:50:38Z",
        "date_published": "2021-11-18T19:52:21Z",
        "description": "To take some rest, you need to lie down. Bioptim does so, by lie on the sheet instead of under, that is getting onto a paper. \r\nThis is the official release for the paper (so far)!\r\n\r\n## What's Changed\r\n* ocp.print() now works with CVODES by @Ipuch in https://github.com/pyomeca/bioptim/pull/400\r\n* Pyqt application to run examples by @aceglia in https://github.com/pyomeca/bioptim/pull/402\r\n* bug fix when using show_options by @Ipuch in https://github.com/pyomeca/bioptim/pull/404\r\n* Add the choice for an integrator of the solution by @Ipuch in https://github.com/pyomeca/bioptim/pull/405\r\n\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_2.1.0...Release_2.1.1",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_2.1.1",
        "name": "LieDown",
        "release_id": 53670166,
        "tag": "Release_2.1.1",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_2.1.1",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/53670166",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/53670166",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_2.1.1"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2021-10-27T16:25:45Z",
        "date_published": "2021-10-27T19:46:11Z",
        "description": "Assessing your fatigue level is important in order to know when to slow down. Bioptim was not able to properly assess it effort level while optimizing. This is now fixed! Using FatiguePerception, bioptim now knows properly how to compute fatigue over time and optimize according to it.\r\n\r\nIn the mean time, I will focus on my thesis writing, so I also take some rest!\r\n\r\n## What's Changed\r\n* Multiple Collocation bug fix by @pariterre in https://github.com/pyomeca/bioptim/pull/390\r\n* Adding a new Class SolverOptions to manage IPOPT and ACADOS efficiently by @Ipuch in https://github.com/pyomeca/bioptim/pull/387\r\n* Symmetry by mapping by @AnaisBellia in https://github.com/pyomeca/bioptim/pull/391\r\n* Merged solver and solver options by @pariterre in https://github.com/pyomeca/bioptim/pull/395\r\n* Update Quat example + test by @EveCharbie in https://github.com/pyomeca/bioptim/pull/396\r\n* Added fatigue perception scaler by @pariterre in https://github.com/pyomeca/bioptim/pull/397\r\n* Made fatigue perception limited to 0/1 by @pariterre in https://github.com/pyomeca/bioptim/pull/398\r\n* Fixed cost function print when using multi_threads by @pariterre in https://github.com/pyomeca/bioptim/pull/399\r\n\r\n## New Contributors\r\n* @AnaisBellia made their first contribution in https://github.com/pyomeca/bioptim/pull/391\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_2.0.3...Release_2.1.0",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_2.1.0",
        "name": "TakeSomeRest",
        "release_id": 52174248,
        "tag": "Release_2.1.0",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_2.1.0",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/52174248",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/52174248",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_2.1.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2021-10-06T20:36:56Z",
        "date_published": "2021-10-06T20:42:21Z",
        "description": "Are you bored waiting after the optimization? Obviously everyone wants things to go faster! You can now c-compile the function optimized by Ipopt! Also, while you are being fatigued, why not optimizing it with the brand new fatigue model!\r\n\r\nEnjoy :D\r\n\r\n## What's Changed\r\n* phase transition with different nx and nu by @EveCharbie in https://github.com/pyomeca/bioptim/pull/372\r\n* Added a cyclic Receding Horizon by @pariterre in https://github.com/pyomeca/bioptim/pull/376\r\n* Add Acados real time to optimize and add options in MHE class  by @aceglia in https://github.com/pyomeca/bioptim/pull/371\r\n* Added a smooth if_else to replace casadi's one by @pariterre in https://github.com/pyomeca/bioptim/pull/378\r\n* Modified pendulum examples by @Ipuch in https://github.com/pyomeca/bioptim/pull/377\r\n* Added number of CPUs for Acados multiprocessing in installation file.  by @aceglia in https://github.com/pyomeca/bioptim/pull/386\r\n* CVODES update by @Ipuch in https://github.com/pyomeca/bioptim/pull/381\r\n* Implemented the Michaud fatigue by @pariterre in https://github.com/pyomeca/bioptim/pull/379\r\n\r\n\r\n**Full Changelog**: https://github.com/pyomeca/bioptim/compare/Release_2.0.2...Release_2.1.0",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_2.0.3",
        "name": "TiredOfWaiting",
        "release_id": 50920341,
        "tag": "Release_2.0.3",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_2.0.3",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/50920341",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/50920341",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_2.0.3"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2021-08-18T15:00:41Z",
        "date_published": "2021-08-18T15:07:01Z",
        "description": "The very nature of an optimization, is to be better at something. But bioptim was shy. It would not show you how good it was! \r\nThis is no longer the case! Now Bioptim can happily show you its performance on objective function WHILE optimizing!\r\n\r\nNow it is your turn to show us what you've got ;)",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_2.0.2",
        "name": "ShowMeWhatYouveGot",
        "release_id": 48052645,
        "tag": "Release_2.0.2",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_2.0.2",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/48052645",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/48052645",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_2.0.2"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2021-07-23T15:17:07Z",
        "date_published": "2021-07-23T15:18:08Z",
        "description": "Bioptim implemented the direct collocations for those who prefer them to direct multishooting!",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_2.0.1",
        "name": "MyColoc",
        "release_id": 46681227,
        "tag": "Release_2.0.1",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_2.0.1",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/46681227",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/46681227",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_2.0.1"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2021-07-20T01:41:22Z",
        "date_published": "2021-07-20T01:46:28Z",
        "description": "The rewriting of the core opens new doors that did not even exist before. Now, it is possible to plan for integrated objective!\r\nThe API was also improve to get a better user experience. \r\nBioptim gets mature and we hope you will like it",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_2.0.0",
        "name": "Symbols",
        "release_id": 46446564,
        "tag": "Release_2.0.0",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_2.0.0",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/46446564",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/46446564",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_2.0.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2021-05-18T12:41:06Z",
        "date_published": "2021-05-21T14:24:58Z",
        "description": "Installing acados into Mac was a mess, now it would be a mess not to! The reason? Installing acados on Mac is now easy as pie! Give it a try",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_1.2.1",
        "name": "MACADOS",
        "release_id": 43356599,
        "tag": "Release_1.2.1",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_1.2.1",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/43356599",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/43356599",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_1.2.1"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2021-05-07T19:56:03Z",
        "date_published": "2021-05-07T20:00:28Z",
        "description": "Moving horizon is an important part of optimal control programs. It allows, by marching over frame, to optimally predict very long trials. Bioptim now has a module for MovingHorizonEstimator and NonlinealModelPredictiveControl!",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_1.2.0",
        "name": "MarchingToVictory",
        "release_id": 42625584,
        "tag": "Release_1.2.0",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_1.2.0",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/42625584",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/42625584",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_1.2.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2021-02-24T15:23:01Z",
        "date_published": "2021-02-25T18:54:43Z",
        "description": "\"Get to the world and yell out loud your existence, praising the good, condemning the bad\"\r\n\r\nBioptim is ready for the world to be aware of it and it comes in the form of a paper! This version is the actual version used to produce the data from the paper.\r\n\r\nLong live to Bioptim!",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_1.1.0",
        "name": "PaperWork",
        "release_id": 38759763,
        "tag": "Release_1.1.0",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_1.1.0",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/38759763",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/38759763",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_1.1.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2021-01-28T16:57:22Z",
        "date_published": "2021-01-28T17:10:02Z",
        "description": "Slowly but surely maturing in its cocoon, bioptim was getting there. And there is it! The day has come when bioptim is ready to call itself the version 1.0.0! That is a big day for it and let all celebrate in a big Hurray!\r\n\r\nLong live to bioptim! Hurray!",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_1.0.0",
        "name": "TheRealDebut",
        "release_id": 37041646,
        "tag": "Release_1.0.0",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_1.0.0",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/37041646",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/37041646",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_1.0.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "pariterre",
          "type": "User"
        },
        "date_created": "2020-05-24T23:10:39Z",
        "date_published": "2020-05-24T23:14:17Z",
        "description": "Everything starts with an idea. A way to improve the world around you. An idea that you will observe and cherish for some time. And then, it became real. The world is a better place. But that just the first step, the baby step, the 001 step... The 0.0.1 step\r\n\r\nWelcome to the future of optimal control in biomechanics!",
        "html_url": "https://github.com/pyomeca/bioptim/releases/tag/Release_0.0.1",
        "name": "TheGrandDebut",
        "release_id": 26845564,
        "tag": "Release_0.0.1",
        "tarball_url": "https://api.github.com/repos/pyomeca/bioptim/tarball/Release_0.0.1",
        "type": "Release",
        "url": "https://api.github.com/repos/pyomeca/bioptim/releases/26845564",
        "value": "https://api.github.com/repos/pyomeca/bioptim/releases/26845564",
        "zipball_url": "https://api.github.com/repos/pyomeca/bioptim/zipball/Release_0.0.1"
      },
      "technique": "GitHub_API"
    }
  ],
  "requirements": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Dependencies",
        "parent_header": [
          "How to install",
          "Installing from the sources (For Linux, Mac, and Windows)"
        ],
        "type": "Text_excerpt",
        "value": "`bioptim` relies on several libraries. \nThe most obvious one is the `biorbd` suite (including indeed `biorbd` and `bioviz`), but extra libraries are required.\nDue to the different dependencies, it would be tedious to show how to install them all here. \nThe user is therefore invited to read the relevant documentation. \n\nHere is a list of all direct dependencies (meaning that some dependencies may require other libraries themselves):  \n[Python](https://www.python.org/) | [numpy](https://numpy.org/) | [scipy](https://scipy.org/) | [packaging](https://packaging.python.org/) | [setuptools](https://pypi.org/project/setuptools/)\n| [matplotlib](https://matplotlib.org/) | [pandas](https://pandas.pydata.org/) | [pyomeca](https://github.com/pyomeca/pyomeca) | [CasADi](https://web.casadi.org/) | [rbdl-casadi](https://github.com/pyomeca/rbdl-casadi) compiled with the CasADi backend | [tinyxml](http://www.grinninglizard.com/tinyxmldocs/index.html) | [biorbd](https://github.com/pyomeca/biorbd) | [vtk](https://vtk.org/) | [PyQt](https://www.riverbankcomputing.com/software/pyqt) | [bioviz](https://github.com/pyomeca/bioviz) | [graphviz](https://graphviz.org/) | [`Ipopt`](https://github.com/coin-or/Ipopt) | [`Acados`](https://github.com/acados/acados) | [pyqtgraph](https://www.pyqtgraph.org/) | [pygmo](https://esa.github.io/pygmo2/) (only for inverse optimal control)  \nand optionally: [The linear solvers from the HSL Mathematical Software Library](http://www.hsl.rl.ac.uk/index.html) with install instructions [here](https://github.com/casadi/casadi/wiki/Obtaining-HSL).\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Linux - Installing dependencies with conda",
        "parent_header": [
          "How to install",
          "Installing from the sources (For Linux, Mac, and Windows)",
          "Dependencies"
        ],
        "type": "Text_excerpt",
        "value": "All these (except for \u0300`Acados` and the HSL lib) can easily be installed using (assuming the anaconda3 environment is loaded if needed) the `pip3` command or the Anaconda's following command:\n```bash\nconda install biorbd bioviz python-graphviz -cconda-forge\n```\nSince there is no `Anaconda` nor `pip3` package of `Acados`, a convenient installer is provided with `bioptim`. \nThe installer can be found and run at `[ROOT_BIOPTIM]/external/acados_install_linux.sh`.\nHowever, the installer requires an `Anaconda3` environment.\nIf you have an `Anaconda3` environment loaded, the installer should find itself where to install it. \nIf you want to install it elsewhere, you can provide the script with a first argument which is the `$CONDA_PREFIX`. \nThe second argument that can be passed to the script is the `$BLASFEO_TARGET`. \nIf you don't know what it is, it is probably better to keep the default. \nPlease note that depending on your computer architecture, `Acados` may or may not work correctly.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Mac - Installing dependencies with conda",
        "parent_header": [
          "How to install",
          "Installing from the sources (For Linux, Mac, and Windows)",
          "Dependencies"
        ],
        "type": "Text_excerpt",
        "value": "Equivalently for MacOSX:\n```bash\nconda install casadi 'rbdl' 'biorbd' 'bioviz' python-graphviz -cconda-forge\n```\nSince there is no `Anaconda` nor `pip3` package of `Acados`, a convenient installer is provided with `bioptim`.\nThe `Acados` installation script is `[ROOT_BIOPTIM]/external/acados_install_mac.sh`.\nHowever, the installer requires an `Anaconda3` environment.\nIf you have an `Anaconda3` environment loaded, the installer should find itself where to install it. \nIf you want to install it elsewhere, you can provide the script with a first argument, the `$CONDA_PREFIX`. \nThe second argument that can be passed to the script is the `$BLASFEO_TARGET`. \nIf you don't know what it is, it is probably better to keep the default. \nPlease note that depending on your computer architecture, `Acados` may or may not work correctly.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Windows - Installing dependencies with conda",
        "parent_header": [
          "How to install",
          "Installing from the sources (For Linux, Mac, and Windows)",
          "Dependencies"
        ],
        "type": "Text_excerpt",
        "value": "Equivalently for Windows:\n```bash\nconda install casadi 'rbdl' 'biorbd' 'bioviz' python-graphviz -cconda-forge\n```\nThere is no `Anaconda` nor `pip3` package of `Acados`.\nTo use the `Acados` solver on Windows, one must compile it themselves.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The case of HSL solvers",
        "parent_header": [
          "How to install",
          "Installing from the sources (For Linux, Mac, and Windows)",
          "Dependencies"
        ],
        "type": "Text_excerpt",
        "value": "HSL is a collection of state-of-the-art packages for large-scale scientific computation. \nAmong its best-known packages are those for the solution of sparse linear systems (`ma27`, `ma57`, etc.), compatible with \u0300`Ipopt`.\nHSL packages are [available](http://www.hsl.rl.ac.uk/download/coinhsl-archive-linux-x86_64/2014.01.17/) at no cost for academic research and teaching. \nOnce you obtain the HSL dynamic library (precompiled `libhsl.so` for Linux, to be compiled `libhsl.dylib` for MacOSX, `libhsl.dll` for Windows), you just have to place it in your `Anaconda3` environment into the `lib/` folder.\nYou can now use all the options of `bioptim`, including the HSL linear solvers with `Ipopt`.\nWe recommend using `ma57` as a default linear solver by calling as such:\n```python\nsolver = Solver.IPOPT()\nsolver.set_linear_solver(\"ma57\")\nocp.solve(solver)\n```"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "run": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Run examples",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "A GUI to access the examples can be run to facilitate the testing of bioptim\nYou can run the file `__main__.py` in the `examples` folder or execute the following command.\n```bash\npython -m bioptim.examples\n```\nPlease note that `pyqtgraph` must be installed to run this GUI. \n\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "somef_missing_categories": [
    "acknowledgement",
    "download",
    "contributors",
    "support",
    "has_build_file"
  ],
  "somef_provenance": {
    "date": "2024-10-06 07:41:51",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 92
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "A first practical example",
        "type": "Text_excerpt",
        "value": "The easiest way to learn `bioptim` is to dive into it.\nSo let us do that and build our first optimal control program together.\nPlease note that this tutorial is designed to recreate the `examples/getting_started/pendulum.py` file where a pendulum is asked to start in a downward position and end, balanced, in an upward position while only being able to move sideways actively.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The import",
        "parent_header": [
          "A first practical example"
        ],
        "type": "Text_excerpt",
        "value": "We will not spend time explaining the import since every one of them will be explained in detail later, and it is pretty straightforward anyway.\n```python\nfrom bioptim import (\n  BiorbdModel,\n  OptimalControlProgram,\n  DynamicsFcn,\n  Dynamics,\n  BoundsList,\n  InitialGuessList,\n  ObjectiveFcn,\n  Objective,\n)\n```\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Building the ocp",
        "parent_header": [
          "A first practical example"
        ],
        "type": "Text_excerpt",
        "value": "First of all, let us load a bioMod file using `biorbd`:\n```python\nbio_model = BiorbdModel(\"pendulum.bioMod\")\n```\nIt is convenient since it will provide interesting functions such as the number of degrees of freedom (`bio_model.nb_q`).\nPlease note that a `pendulum.bioMod` copy is available at the end of the *Getting started* section.\nIn brief, the pendulum consists of two degrees of freedom (sideways movement and rotation), with the center of mass near the head.\n\nThe dynamics of the pendulum, as for many biomechanical dynamics, is driven by the generalized forces. \nGeneralized forces are forces or moments directly applied to the degrees of freedom as if virtual motors were driven them.\nIn `bioptim`, this dynamic is called torque driven. \nIn a torque driven dynamics, the states are the positions (also called generalized coordinates, *q*) and the velocities (also called the generalized velocities, *qdot*), whereas the controls are the joint torques (also called generalized forces, *tau*). \nLet us define such dynamics:\n```python\ndynamics = Dynamics(DynamicsFcn.TORQUE_DRIVEN)\n```\n\nThe pendulum is required to start in a downward position (0 rad) and to finish in an upward position (3.14 rad) with no velocity at the start and end nodes.\nTo define that, it would be nice first to define boundary constraints on the position (*q*) and velocities (*qdot*) that match those in the bioMod file and to apply them at the very beginning, the very end, and all the intermediate nodes as well.\nIn this case, the state with index 0 is translation y, and index 1 refers to rotation about x. \nFinally, the index 2 and 3 are  the velocity of translation y and rotation about x,respectively.\n\nbounds_from_ranges uses the ranges from a biorbd model and returns a structure with the minimal and maximal bounds for all the degrees of freedom and velocities on three columns corresponding to the starting, intermediate, and final nodes, respectively.\nHow convenient!\n```python\nx_bounds = BoundsList()\nx_bounds[\"q\"] = bio_model.bounds_from_ranges(\"q\")\nx_bounds[\"qdot\"] = bio_model.bounds_from_ranges(\"qdot\")\n```\nThe first dimension of x_bounds is the degrees of freedom (*q*) `and` their velocities (*qdot*) that match those `in` the bioMod `file`. The time `is` discretized `in` nodes which `is` the second dimension declared `in` x_bounds.\nIf you have more than one phase, we would have x_bound[*phase*][*q `and` qdot*, *nodes*]\nIn the first place, we want the first `and` last column (which `is` equivalent to nodes 0 `and` -1) to be 0, i.e., the translations `and` rotations to be null `for` both the position `and` so the velocities.\n```python\nx_bounds[\"q\"][:, [0, -1]] = 0\nx_bounds[\"qdot\"][:, [0, -1]] = 0\n```\nFinally, override once again the final node for the rotation so it is upside down.\n```python\nx_bounds[\"q\"][1, -1] = 3.14\n```\nAt that point, you may want to have a look at the `x_bounds[\"q\"].min` and `x_bounds[\"q\"].max` matrices to convince yourself that the initial and final positions are prescribed and that all the intermediate points are free up to certain minimal and maximal values. \n\nUp to that point, nothing prevents the solver from simply using the virtual motor of the rotation to rotate the pendulum upward (like clock hands) to get to the upside-down rotation. \nWhat makes this example interesting is that we can prevent this by defining minimal and maximal bounds on the control (the maximal forces that these motors have)\n```\nu_bounds = BoundsList()\nu_bounds[\"tau\"] = [-100, 0], [100, 0]\n```\nLike this, the sideways force ranges from -100 Newton to 100 Newton, but the rotation force ranges from 0 N/m to 0 N/m.\nAgain, `u_bounds` is defined for the first, the intermediate, and the final nodes, but this time, we do not want to specify anything particular for the first and final nodes, so we can leave them as is. \n\nIf you wondering where are defined *q*, *qdot* and *tau*, it is in the configuration of `DynamicsFcn.TORQUE_DRIVEN`. If you define a custom dynamics, then the variable's name should match those you define yourself.\n\nWho says optimization says cost function.\nEven though, it is possible to define an OCP without objective, it is not so much recommended, and let us face it... much less fun!\nSo the pendulum's goal (or the cost function) is to perform its task while using the minimum forces possible. \nTherefore, an objective function that minimizes the generalized forces is defined:\n```python\nobjective_functions = Objective(ObjectiveFcn.Lagrange.MINIMIZE_TORQUE)\n```\n\nAt that point, it is possible to solve the program.\nStill, helping the solver is usually a good idea, so let us give \u0300`Ipopt` a starting point to investigate.\nThe initial guess that we can provide is those for the states (`x_init`, here *q* and *qdot*) and for the controls (`u_init`, here *tau*). \nSo let us define both of them quickly\n```python\nx_init = InitialGuessList()\nx_init[\"q\"] = [0, 0]\nx_init[\"qdot\"] = [0, 0]\n\nu_init = InitialGuessList()\nu_init[\"tau\"] = [0, 0]\n```\nPlease note that initial guess is optional. The default value if a value is not provided is zero.\n\nOn the same train of thought, if we want to help the solver even more, we can also define a variable scaling for the states (`x_scaling`, here *q* and *qdot*) and for the controls (`u_scaling`, here *tau*). *Note that the scaling should be declared in the order in which the variables appear. \nWe encourage you to choose a variable scaling the same order of magnitude to the expected optimal values.\n```python\nx_scaling = VariableScalingList()\nx_scaling.add(\"q\", scaling=[1, 3])\nx_scaling.add(\"qdot\", scaling=[85, 85])\n   \nu_scaling = VariableScalingList()\nu_scaling.add(\"tau\", scaling=[900, 1])\n```\nWe now have everything to create the ocp!\nFor that, we have to decide how much time the pendulum has to get up there (`phase_time`) and how many shooting points are defined for the multishoot (`n_shooting`).\nThereafter, you have to send everything to the `OptimalControlProgram` class and let `bioptim` prepare everything for you.\nFor simplicity's sake, I copied all the pieces of code previously visited in the building of the ocp section here:\n```python\nocp = OptimalControlProgram(\n        bio_model,\n        dynamics,\n        n_shooting=25,\n        phase_time=3,\n        x_bounds=x_bounds,\n        u_bounds=u_bounds,\n        x_init=x_init,\n        u_init=u_init,\n        objective_functions=objective_functions,\n    )\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Checking the ocp",
        "parent_header": [
          "A first practical example"
        ],
        "type": "Text_excerpt",
        "value": "Now you can check if the ocp is well-defined for the initial values.\nThis checking will help see if your constraints and objectives are okay.\nTo visualize it, you can use\n```python\nocp.check_conditioning()\n```\nThis call will print two different plots!\n\nThe first shows the Jacobian matrix of constraints and the norm of each Hessian matrix of constraints.\nThere is one matrix for each phase.\nThe first half of the plot can be used to verify if some constraints are redundant. It simply compares the rank of the Jacobian with the number of constraints for each phase.\nThe second half of the plot can be used to verify if the equality constraints are linear.\n\nThe second plot window shows the hessian of the objective for each phase. It calculates if the problem can be convex by checking if the matrix is positive semi-definite.\nIt also calculates the condition number for each phase thanks to the eigenvalues.\n\nIf everything is okay, let us solve the ocp !\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Solving the ocp",
        "parent_header": [
          "A first practical example"
        ],
        "type": "Text_excerpt",
        "value": "It is now time to see `Ipopt` in action! \nTo solve the ocp, you simply have to call the `solve()` method of the `ocp` class\n```python\nsolver = Solver.IPOPT(show_online_optim=True)\nsol = ocp.solve(solver)\n```\nIf you feel fancy, you can even activate the online optimization graphs!\nHowever, for such an easy problem, `Ipopt` will not leave you the time to appreciate the real-time updates of the graph...\nFor a more complicated problem, you may also wish to visualize the objectives and constraints during the optimization \n(useful when debugging, because who codes the right thing the first time). You can do it by calling\n```python\nocp.add_plot_penalty(CostType.OBJECTIVES)\nocp.add_plot_penalty(CostType.CONSTRAINTS)\n```\nor alternatively asks for both at once using\n```python\nocp.add_plot_penalty(CostType.ALL)\n```\nThat's it!\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Show the results",
        "parent_header": [
          "A first practical example"
        ],
        "type": "Text_excerpt",
        "value": "If you want to look at the animated data, `bioptim` has an interface to `bioviz` designed to visualize bioMod files.\nFor that, simply call the `animate()` method of the solution:\n```python\nsol.animate()\n```\n\nIf you did not fancy the online graphs but would enjoy them anyway, you can call the method `graphs()`:\n```python\nsol.graphs()\n```\n\nIf you are interested in the results of individual objective functions and constraints, you can print them using the \n`print_cost()` or access them using the `detailed_cost_values()`:\n\n```python\n# sol.detailed_cost  # Invoke this for adding the details of the objectives to sol for later manipulations\nsol.print_cost()  # For printing their values in the console\n```\n\nAnd that is all! \nYou have completed your first optimal control program with `bioptim`! \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Solving using multi-start",
        "parent_header": [
          "A first practical example"
        ],
        "type": "Text_excerpt",
        "value": "Due to the gradient descent methods, we can affirm that the optimal solution is a local minimum. However, it is impossible to know if a global minimum was found. For highly non-linear problems, there might exist a wide range of local \noptima. Solving the same problem with different initial guesses can be helpful to find the best local minimum or to \ncompare the different optimal kinematics. It is possible to multi-start the problem by creating a multi-start object \nwith `MultiStart()` and running it with its method `run()`.\nAn example of how to use multi-start is given in examples/getting_started/multi-start.py.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The complete example files",
        "parent_header": [
          "A first practical example"
        ],
        "type": "Text_excerpt",
        "value": "If you did not completely follow (or were too lazy to!) you will find  the complete files described in the Getting started section here.\nYou will find that the file is a bit different from the `example/getting_started/pendulum.py`, but it is merely different on the surface.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The pendulum.py file",
        "parent_header": [
          "A first practical example",
          "The complete example files"
        ],
        "type": "Text_excerpt",
        "value": "```python\nimport biorbd_casadi as biorbd\nfrom bioptim import (\n    BiorbdModel,\n    OptimalControlProgram,\n    DynamicsFcn,\n    Dynamics,\n    BoundsList,    \n    InitialGuessList,\n    ObjectiveFcn,\n    Objective,\n)\n\nbio_model = BiorbdModel(\"pendulum.bioMod\")\ndynamics = Dynamics(DynamicsFcn.TORQUE_DRIVEN)\n\n# Bounds are optional (default -inf -> inf)\nx_bounds = BoundsList()\nx_bounds[\"q\"] = bio_model.bounds_from_ranges(\"q\")\nx_bounds[\"q\"][:, [0, -1]] = 0\nx_bounds[\"q\"][1, -1] = 3.14\nx_bounds[\"dot\"] = bio_model.bounds_from_ranges(\"qdot\")\nx_bounds[\"qdot\"][:, [0, -1]] = 0\n\nu_bounds = BoundsList()\nu_bounds[\"tau\"] = [-100, 0], [100, 0]\n\nobjective_functions = Objective(ObjectiveFcn.Lagrange.MINIMIZE_TORQUE)\n\n# Initial guess is optional (default = 0)\nx_init = InitialGuessList()\nx_init[\"q\"] = [0, 0]\nx_init[\"qdot\"] = [0, 0]\nu_init = InitialGuessList()\nu_init = [0, 0]\n\nocp = OptimalControlProgram(\n        bio_model,\n        dynamics,\n        n_shooting=25,\n        phase_time=3,\n        x_bounds=x_bounds,\n        u_bounds=u_bounds,\n        x_init=x_init,\n        u_init=u_init,\n        objective_functions=objective_functions,\n    )\n    \nsol = ocp.solve(show_online_optim=True)\nsol.print_cost()\nsol.animate()\n```"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The pendulum.bioMod file",
        "parent_header": [
          "A first practical example",
          "The complete example files"
        ],
        "type": "Text_excerpt",
        "value": "Here is a simple pendulum that can be interpreted by `biorbd`. \nFor more information on how to build a bioMod file, one can read the doc of [biorbd](https://github.com/pyomeca/biorbd).\n\n```c\nversion 4\n\n// Seg1\nsegment Seg1\n    translations\ty\n    rotations\tx\n    ranges  -1 5\n            -2*pi 2*pi\n    mass 1\n    inertia\n        1 0 0\n        0 1 0\n        0 0 0.1\n    com 0.1 0.1 -1\n    mesh 0.0   0.0   0.0\n    mesh 0.0  -0.0  -0.9\n    mesh 0.0   0.0   0.0\n    mesh 0.0   0.2  -0.9\n    mesh 0.0   0.0   0.0\n    mesh 0.2   0.2  -0.9\n    mesh 0.0   0.0   0.0\n    mesh 0.2   0.0  -0.9\n    mesh 0.0   0.0   0.0\n    mesh 0.0  -0.0  -1.1\n    mesh 0.0   0.2  -1.1\n    mesh 0.0   0.2  -0.9\n    mesh 0.0  -0.0  -0.9\n    mesh 0.0  -0.0  -1.1\n    mesh 0.2  -0.0  -1.1\n    mesh 0.2   0.2  -1.1\n    mesh 0.0   0.2  -1.1\n    mesh 0.2   0.2  -1.1\n    mesh 0.2   0.2  -0.9\n    mesh 0.0   0.2  -0.9\n    mesh 0.2   0.2  -0.9\n    mesh 0.2  -0.0  -0.9\n    mesh 0.0  -0.0  -0.9\n    mesh 0.2  -0.0  -0.9\n    mesh 0.2  -0.0  -1.1\nendsegment\n\n    // Marker 1\n    marker marker_1\n        parent Seg1\n        position 0 0 0\n    endmarker\n\n    // Marker 2\n    marker marker_2\n        parent Seg1\n        position 0.1 0.1 -1\n    endmarker\n```\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Examples",
        "type": "Text_excerpt",
        "value": "In this section, we describe all the examples implemented with bioptim. They are ordered in separate files. Each subsection corresponds to the different files, dealing with different examples and topics.\nPlease note that the examples from the paper (see [Citing](#citing)) can be found in this repo\n[https://github.com/s2mLab/BioptimPaperExamples](https://github.com/s2mLab/BioptimPaperExamples).\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Run examples",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "A GUI to access the examples can be run to facilitate the testing of bioptim\nYou can run the file `__main__.py` in the `examples` folder or execute the following command.\n```bash\npython -m bioptim.examples\n```\nPlease note that `pyqtgraph` must be installed to run this GUI. \n\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Getting started",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "In this subsection, all the examples of the getting_started file are described.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/custom_bounds.py\">custom_bounds.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial box sent upward. It is designed to investigate the different bounds defined in bioptim.\nTherefore, it shows how to define the bounds, i.e., the minimal and maximal values of the state and control variables.\n\nAll the types of interpolation are shown: `CONSTANT`, `CONSTANT_WITH_FIRST_AND_LAST_DIFFERENT`, `LINEAR`, `EACH_FRAME`,\n`SPLINE`, and `CUSTOM`. \n\nWhen the `CUSTOM` interpolation is chosen, the functions `custom_x_bounds_min` and `custom_x_bounds_max`  \nprovide custom x bounds. The functions `custom_u_bounds_min` and `custom_u_bounds_max` provide custom \nu bounds. \nIn this particular example,  linear interpolation is mimicked using these four functions.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/custom_constraint.py\">custom_constraint.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial box that must superimpose one of its corners on a marker at the beginning of the movement and superimpose the same corner on a different marker at the end.\nIt is designed to show how to define custom constraints function if the available constraints do not fulfill your need.\n\nThis example reproduces the behavior of the `SUPERIMPOSE_MARKERS` constraint.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/custom_dynamics.py\">custom_dynamics.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial box that must superimpose one of its corners on a marker at the beginning of the movement\nand superimpose the same corner on a different marker at the end.\nIt is designed to show how to define a custom dynamics function if the provided ones are not \nsufficient.\n\nThis example reproduces the behavior of the `DynamicsFcn.TORQUE_DRIVEN` using custom dynamics. \n\nThe custom_dynamic function is used to provide the derivative of the states. The custom_configure function is used \nto tell the program which variables are states and controls. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/custom_initial_guess.py\">custom_initial_guess.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial box that must superimpose one of its corners on a marker at the beginning of the movement\nand superimpose the same corner on a different marker at the end.\nIt is designed to investigate the different ways to define the initial guesses at each node sent to the solver.\n\nAll the types of interpolation are shown: `CONSTANT`, `CONSTANT_WITH_FIRST_AND_LAST_DIFFERENT`, `LINEAR`, `EACH_FRAME`,\n`SPLINE`, and `CUSTOM`. \n\nWhen the CUSTOM interpolation is chosen, the `custom_init_func` function is used to custom the initial guesses of the \nstates and controls. In this particular example, the CUSTOM interpolation mimics linear interpolation. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/custom_objectives.py\">custom_objectives.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial box that tries to superimpose one of its corners on a marker at the beginning of the movement\nand superimpose the same corner on a different marker at the end.\nIt is designed to show how one can define its own custom objective function if the provided ones are not\nsufficient.\n\nThis example reproduces the behavior of the `Mayer.SUPERIMPOSE_MARKERS` objective function. \n\nThis example is close to the example of the custom_constraint.py file. We use the custom_func_track_markers to define \nthe objective function. In this example, the CUSTOM objective mimics `ObjectiveFcn.SUPERIMPOSE_MARKERS`.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/custom_parameters.py\">custom_parameters.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a clone of the pendulum.py example with the difference that the\nmodel now evolves in an environment where gravity can be modified.\nThe goal of the solver is to find the optimal gravity (target = 8 N/kg) while performing the\npendulum balancing task.\n\nIt is designed to show how to define parameters.\n\nThe `my_parameter_function function` is used to modify the dynamics. In our case, we want to optimize the \ngravity. This function is called right before defining the dynamics of the system. The `my_target_function` function is \na penalty function. Both functions define a new parameter, and then a parameter objective function \nis linked to this new parameter.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/custom_phase_transitions.py\">custom_phase_transitions.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial multiphase box that must superimpose different markers at the beginning and end of each\nphase with one of its corners.\nIt is designed to show how to define CUSTOM phase transition constraints if the provided ones are insufficient.\n\nThis example mimics the behavior of the most common `PhaseTransitionFcn.CONTINUOUS`\n\nThe custom_phase_transition function defines the constraint of the transition to apply. This function can be \nused when adding some phase transitions to the list of phase transitions. \n\nDifferent phase transitions can be considered. By default, all the phase transitions are continuous. However, if one or more phase transitions are desired to be continuous, it is possible to define and use a function like \nthe `custom_phase_transition` function or directly use `PhaseTransitionFcn.IMPACT`. If a phase transition is desired \nbetween the last and the first phase, use the dedicated `PhaseTransitionFcn.Cyclic`. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/custom_plotting.py\">custom_plotting.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial example of using the pendulum without any objective. It is designed to show how to create new\nplots and expand pre-existing ones with new information.\n\nWe define the `custom_plot_callback` function, which returns the value(s) to plot. We use this function as an argument of \n`ocp.add_plot`. Let us describe the creation of the plot \"My New Extra Plot\". `custom_plot_callback` \ntakes two arguments, x and the array [0, 1, 3], as you can see below :\n\n```python\nocp.add_plot(\"My New Extra Plot\", lambda x, u, p: custom_plot_callback(x, [0, 1, 3]), plot_type=PlotType.PLOT)\n```\n\nWe use the plot_type `PlotType.PLOT`. It is a way to plot the first, \nsecond, and fourth states (i.e., `q_Seg1_TransY`, `q_Seg1_RotX` and `qdot_Seg1_RotX`) in a new window entitled \"My New \nExtra Plot\". Please note that for further information about the different plot types, you can refer to the section \n\"Enum: PlotType\".\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_continuity_as_objective.py\">example_continuity_as_objective.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_cyclic_movement.py\">example_cyclic_movement.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial box that must superimpose one of its corners on a marker at the beginning of the movement\nand superimpose the same corner on a different marker at the end. Moreover, the movement must be cyclic, meaning\nthat the states at the end and the beginning are equal. It is designed to provide a comprehensible example of the way\nto declare a cyclic constraint or objective function.\n\nA phase transition loop constraint is treated as a hard penalty (constraint)\nif weight is <= 0 [or if no weight is provided], or as a soft penalty (objective) otherwise, as shown in the example below :\n\n```python\nphase_transitions = PhaseTransitionList()\nif loop_from_constraint:\n    phase_transitions.add(PhaseTransitionFcn.CYCLIC, weight=0)\nelse:\n    phase_transitions.add(PhaseTransitionFcn.CYCLIC, weight=10000)\n```\n\n`loop_from_constraint` is a boolean. It is one of the parameters of the `prepare_ocp` function of the example. This parameter is a way to determine if the looping cost should be a constraint [True] or an objective [False]. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_external_forces.py\">example_external_forces.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial box that must superimpose one of its corners on a marker at the beginning of the movement\nand superimpose the same corner on a different marker at the end. While doing so, a force pushes the box upward.\nThe solver must minimize the force to lift the box while reaching the marker in time.\nIt is designed to show how to use external forces. An example of external forces that depends on the state (for\nexample, a spring) can be found at 'examples/torque_driven_ocp/spring_load.py'\n\n`Bioptim` expects `external_forces` to be a np.ndarray [6 x n x n_shooting], where the six components are \n[Mx, My, Mz, Fx, Fy, Fz], expressed at the origin of the global reference frame for each node.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_implicit_dynamics.py\">example_implicit_dynamics.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_inequality_constraint.py\">example_inequality_constraint.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example mimics what a jumper does when maximizing the predicted height of the center of mass at the peak of an aerial phase. It does so with a simplistic two segments model.\nIt is a clone of 'torque_driven_ocp/maximize_predicted_height_CoM.py' using\nthe option `MINIMIZE_PREDICTED_COM_HEIGHT`. It is different in that the contact forces on the ground have\nto be downward (meaning that the object is limited to push on the ground, as one would expect when jumping). \n\nMoreover, the lateral forces must respect some `NON_SLIPPING` constraint (i.e., the ground reaction\nforces have to remain inside of a cone of friction), as shown in the part of the code defining the constraints:\n\n```python\nconstraints = ConstraintList()\n   constraints.add(\n   ConstraintFcn.TRACK_CONTACT_FORCES,\n   min_bound=min_bound,\n   max_bound=max_bound,\n   node=Node.ALL,\n   contact_index=1,\n   )\nconstraints.add(\n    ConstraintFcn.TRACK_CONTACT_FORCES,\n    min_bound=min_bound,\n    max_bound=max_bound,\n    node=Node.ALL,\n    contact_index=2,\n    )\nconstraints.add(\n    ConstraintFcn.NON_SLIPPING,\n    node=Node.ALL,\n    normal_component_idx=(1, 2),\n    tangential_component_idx=0,\n    static_friction_coefficient=mu,\n    )\n```\n\nLet us describe the code above. First, we create a list of constraints. Then, two contact forces are defined with the indexes 1 and 2, respectively. The last step is the implementation of a non-slipping constraint for the two forces defined before.   \n\nThis example is designed to show how to use min_bound and max_bound values so they define inequality constraints instead\nof equality constraints, which can be used with any `ConstraintFcn`.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_joints_acceleration_driven.py\">example_joints_acceleration_driven.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example shows how to use the joints' acceleration dynamic to achieve the same goal as the simple pendulum but with a double pendulum for which only the angular acceleration of the second pendulum is controlled.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_mapping.py\">example_mapping.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "In fact, examples of mapping can be found at 'examples/symmetrical_torque_driven_ocp/symmetry_by_mapping.py'.\nand 'examples/getting_started/example_inequality_constraint.py'. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_multinode_constraints.py\">example_multinode_constraints.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_multinode_objective.py\">example_multinode_objective.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_multiphase.py\">example_multiphase.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial box that must superimpose one of its corners on a marker at the beginning of the movement and\na different marker at the end of each phase. Moreover, a constraint on the rotation is imposed on the cube.\nIt is designed to show how to define a multiphase optimal control program.\n\nIn this example, three phases are implemented. The `long_optim` boolean allows users to choose between solving the precise\noptimization or the approximate. In the first case, 500 points are considered: `n_shooting = (100, 300, 100)`. \nOtherwise, 50 points are considered: `n_shooting = (20, 30, 20)`. Three steps are necessary to define the \nobjective functions, the dynamics, the constraints, the path constraints, the initial guesses, and the control path \nconstraints. Each step corresponds to one phase. \n\nLet us take a look at the definition of the constraints:\n\n```python\nconstraints = ConstraintList()\nconstraints.add(\n    ConstraintFcn.SUPERIMPOSE_MARKERS, node=Node.START, first_marker_idx=0, second_marker_idx=1, phase=0\n)\nconstraints.add(ConstraintFcn.SUPERIMPOSE_MARKERS, node=Node.END, first_marker_idx=0, second_marker_idx=2, phase=0)\nconstraints.add(ConstraintFcn.SUPERIMPOSE_MARKERS, node=Node.END, first_marker_idx=0, second_marker_idx=1, phase=1)\nconstraints.add(ConstraintFcn.SUPERIMPOSE_MARKERS, node=Node.END, first_marker_idx=0, second_marker_idx=2, phase=2)\n```\n\nFirst, we define a list of constraints, and then we add constraints to the list. At the beginning, marker 0 must \nsuperimpose marker 1. At the end of the first phase (the first 100 shooting nodes if we solve the precise optimization), \nmarker 0 must superimpose marker 2. Then, at the end of the second phase, marker 0 must superimpose marker 1. At the \nend of the last step, marker 0 must superimpose marker 2. Please, note that the definition of the markers is \nimplemented in the `bioMod` file corresponding to the model. Further information about the definition of the markers is\navailable in the `biorbd` documentation.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_multistart.py\">example_multistart.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_optimal_time.py\">example_optimal_time.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "Examples of time optimization can be found in 'examples/optimal_time_ocp/'.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_save_and_load.py\">example_save_and_load.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a clone of  getting_started/pendulum.py. It is designed to show how to create and solve a problem\nand, afterward, save it to the hard drive and reload it. It shows an example of the *.bo method. \n\nLet us take a look at the most important lines of the example. To save the optimal control program and the solution, use\nocp.save(sol, \"pendulum.bo\"). To load the optimal control program and the solution, use \n`ocp_load, sol_load = OptimalControlProgram.load(\"pendulum.bo\")`. Then, to show the results, use `sol_load.animate()`.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_simulation.py\">example_simulation.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "The first part of this example is a single shooting simulation from initial guesses.\nIt is not an optimal control program. It is merely the simulation of values that is applying the dynamics.\nThe main goal of this kind of simulation is to get a sense of the initial guesses passed to the solver.\n\nThe second part of the example is to solve the program and simulate the results from this solution.\nThe main goal of this kind of simulation, especially in single shooting (i.e., not resetting the states at each node)\nis to validate the dynamics obtained by multiple shooting. If they both are equal, it usually means great confidence\ncan be held in the solution. Another goal would be to reload fast a previously saved optimized solution.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/example_variable_scaling.py\">example_variable_scaling.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/pendulum.py\">pendulum.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is another way to present the pendulum example of the 'Getting started' section.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/getting_started/pendulum_constrained_states_controls.py\">pendulum_constrained_states_controls.py</a> file",
        "parent_header": [
          "Examples",
          "Getting started"
        ],
        "type": "Text_excerpt",
        "value": "This example is a clone of the pendulum.py example with the difference that the\nstates and controls are constrained instead of bounded. Sometimes the OCP converges faster with constraints than boundaries. \n\nIt is designed to show how to use `bound_state` and `bound_control`.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Torque-driven OCP",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "In this section, you will find different examples showing how to implement torque-driven optimal control programs.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "<a href=\"./bioptim/examples/torque_driven_ocp/maximize_predicted_height_CoM.py\">The maximize_predicted_height_CoM.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This example mimics what a jumper does to maximize the predicted height of the\ncenter of mass at the peak of an aerial phase. It does so with a very simple two segments model.\nIt is designed to give a sense of the goal of the different MINIMIZE_COM functions and the use of\n`weight=-1` to maximize instead of minimize.\n\nLet us take a look at the definition of the objective functions used for this example to understand better how to \nimplement that:\n\n```python\nobjective_functions = ObjectiveList()\nif objective_name == \"MINIMIZE_PREDICTED_COM_HEIGHT\":\n    objective_functions.add(ObjectiveFcn.Mayer.MINIMIZE_PREDICTED_COM_HEIGHT, weight=-1)\nelif objective_name == \"MINIMIZE_COM_POSITION\":\n    objective_functions.add(ObjectiveFcn.Lagrange.MINIMIZE_COM_POSITION, axis=Axis.Z, weight=-1)\nelif objective_name == \"MINIMIZE_COM_VELOCITY\":\n    objective_functions.add(ObjectiveFcn.Lagrange.MINIMIZE_COM_VELOCITY, axis=Axis.Z, weight=-1)\n```\n\nAnother interesting point of this example is the definition of the constraints. Thanks to the `com_constraints` boolean, \nthe user can easily choose to apply or not constraints on the center of mass. Here is the definition of the constraints for our \nexample:\n\n```python\nconstraints = ConstraintList()\nif com_constraints:\n    constraints.add(\n        ConstraintFcn.TRACK_COM_VELOCITY,\n        node=Node.ALL,\n        min_bound=np.array([-100, -100, -100]),\n        max_bound=np.array([100, 100, 100]),\n    )\n    constraints.add(\n        ConstraintFcn.TRACK_COM_POSITION,\n        node=Node.ALL,\n        min_bound=np.array([-1, -1, -1]),\n        max_bound=np.array([1, 1, 1]),\n    )\n```\n\nThis example is designed to show how to use `min_bound` and `max_bound` values so they define inequality constraints \ninstead of equality constraints, which can be used with any `ConstraintFcn`. This example is close to the \nexample_inequality_constraint.py file available in 'examples/getting_started/example_inequality_constraint.py'.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/spring_load.py\">spring_load.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This trivial spring example aims to achieve the highest upward velocity. It can, however, only load a spring by\npulling downward and then letting it go so it gains velocity. It is designed to show how to use external forces to interact with the body.\n\nThis example is close to the custom_dynamics.py file you can find in 'examples/getting_started/custom_dynamics.py'. \nIndeed, we generate an external force thanks to the custom_dynamic function. Then, we configure the dynamics with \nthe `custom_configure` function. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/track_markers_2D_pendulum.py\">track_markers_2D_pendulum.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This example uses the data from the balanced pendulum example to generate data to track.\nWhen it optimizes the program, contrary to the vanilla pendulum, it tracks the values instead of 'knowing' that\nit is supposed to balance the pendulum. It is designed to show how to track marker and kinematic data.\n\nNote that the final node is not tracked. \n\nIn this example, we use both `ObjectiveFcn.Lagrange.TRACK_MARKERS` and `ObjectiveFcn.Lagrange.TRACK_TORQUE` objective \nfunctions to track data, as shown in the definition of the objective functions used in this example:\n\n```python\nobjective_functions = ObjectiveList()\nobjective_functions.add(\n    ObjectiveFcn.Lagrange.TRACK_MARKERS, axis_to_track=[Axis.Y, Axis.Z], weight=100, target=markers_ref\n)\nobjective_functions.add(ObjectiveFcn.Lagrange.TRACK_TORQUE, target=tau_ref)\n```\n\nThis is a good example of how to load data for tracking tasks and how to plot data. The extra parameter \n`axis_to_track` allows users to specify the axes to track the markers (x and y axes in this example).\nThis example is close to the example_save_and_load.py and custom_plotting.py files you can find in the \nexamples/getting_started repository. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/track_markers_with_torque_actuators.py\">track_markers_with_torque_actuators.py</a>  file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial box that must superimpose one of its corners on a marker at the beginning of the movement\nand superimpose the same corner to a different marker at the end. It is a clone of\n'getting_started/custom_constraint.py' \n\nIt is designed to show how to use the `TORQUE_ACTIVATIONS_DRIVEN`, which limits\nthe torque to [-1; 1]. This is useful when the maximal torques are not constant. Please note that such a dynamics may\nnot converge when it is used on a more complicated model. A solution that defines non-constant constraints seems a\nbetter idea. An example can be found in the `bioptim` paper.\n\nLet us take a look at the structure of the code. First, tau_min, tau_max, and tau_init are respectively initialized \nto -1, 1 and 0 if the integer `actuator_type` (a parameter of the `prepare_ocp` function) equals 1. \nIn this case, the dynamics function used is `DynamicsFcn.TORQUE_ACTIVATIONS_DRIVEN`. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/example_quaternions.py\">example_quaternions.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This example uses a representation of a human body by a trunk_leg segment and two arms.\nIt is designed to show how to use a model that has quaternions in their degrees of freedom.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/example_minimize_segment_velocity.py\">example_minimize_segment_velocity.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/example_multi_biorbd_model.py\">example_multi_biorbd_model.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/example_soft_contact.py\">example_soft_contact.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/miminize_maximum_torque_by_extra_parameter.py\">miminize_maximum_torque_by_extra_parameter.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/ocp_mass_with_ligament.py\">ocp_mass_with_ligament.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/phase_transition_uneven_variable_number_by_bounds.py\">phase_transition_uneven_variable_number_by_bounds.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/phase_transition_uneven_variable_number_by_mapping.py\">phase_transition_uneven_variable_number_by_mapping.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/slider.py\">slider.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/torque_driven_ocp/torque_activation_driven.py\">torque_activation_driven.py</a> file",
        "parent_header": [
          "Examples",
          "Torque-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Muscle-driven OCP",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "In this folder, you will find four examples of muscle-driven optimal control programs. The two first refer to tracking \nexamples. The two last refer to reaching tasks. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/muscle_driven_ocp/muscle_activations_tracker.py\">muscle_activations_tracker.py</a> file",
        "parent_header": [
          "Examples",
          "Muscle-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This example is about muscle activation/skin marker or state tracking.\nRandom data are created by generating a random set of muscle activations and then by generating the kinematics\nassociated with these controls. The solution is trivial since no noise is applied to the data. Still, it is a relevant\nexample of how to track data using a musculoskeletal model. In a real situation, muscle activation\nand kinematics would indeed be acquired using data acquisition devices.\n\nThe difference between muscle activation and excitation is that the latter is the derivative of the former.\n\nThe generate_data function is used to create random data. First, a random set of muscle activations is generated, as \nshown below:\n`U = np.random.rand(n_shooting, n_mus).T`\n\nThen, the kinematics associated with these data are generated by numerical integration, using \n`scipy.integrate.solve_ivp`. \n\nTo implement this tracking task, we use the ObjectiveFcn.Lagrange.TRACK_STATE objective function in the case of state tracking, or the `ObjectiveFcn.Lagrange.TRACK_MARKERS` objective function in the case of marker tracking. We also use \nthe `ObjectiveFcn.Lagrange.TRACK_MUSCLES_CONTROL` objective function. The user can choose between marker or state \ntracking thanks to the string `kin_data_to_track`, which is one of the `prepare_ocp` function parameters. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/muscle_driven_ocp/muscle_activations_tracker.py\">muscle_excitations_tracker.py</a>  file",
        "parent_header": [
          "Examples",
          "Muscle-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This example concerns muscle excitation(EMG)/skin marker or state tracking.\nRandom data are created by generating a random set of EMG and then by generating the kinematics associated with these\ndata. The solution is trivial since no noise is applied to the data. Still, it is a relevant example of how to\ntrack data using a musculoskeletal model. The EMG and kinematics would be acquired in the real world using data acquisition devices.\n\nThere is no major difference with the previous example. Some dynamic equations link muscle activation and excitation. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/muscle_driven_ocp/static_arm.py\">static_arm.py</a>  file",
        "parent_header": [
          "Examples",
          "Muscle-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This is a basic example of using the `biorbd` muscle-driven model to perform an optimal reaching task.\nThe arms must reach a marker placed upward in front while minimizing the muscles' activity.\n\nFor this reaching task, we use the `ObjectiveFcn.Mayer.SUPERIMPOSE_MARKERS` objective function. At the end of the \nmovement, marker 0 and marker 5 should superimpose. The weight applied to the `SUPERIMPOSE_MARKERS` objective function \nis 1000. Please note that the bigger this number, the greater the model will try to reach the marker. \n\nPlease note that using show_meshes=True in the animator may be long due to the creation of a large `CasADi` graph of the\nmesh points.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/muscle_driven_ocp/static_arm_with_contact.py\">static_arm_with_contact.py</a> file",
        "parent_header": [
          "Examples",
          "Muscle-driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This is a basic example of how to use biorbd model driven by muscle to perform an optimal reaching task with a\ncontact dynamics.\nThe arms must reach a marker placed upward in front while minimizing the muscles' activity.\n\nThe only difference with the previous example is that we use the arm26_with_contact.bioMod model and the \n`DynamicsFcn.MUSCLE_ACTIVATIONS_AND_TORQUE_DRIVEN_WITH_CONTACT` dynamics function instead of \n`DynamicsFcn.MUSCLE_ACTIVATIONS_AND_TORQUE_DRIVEN`.\n\nPlease note that using show_meshes=True in the animator may be long due to the creation of a huge `CasADi` graph of the\nmesh points.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/muscle_driven_with_contact/contact_forces_inequality_constraint_muscle.py\">contact_forces_inequality_constraint_muscle.py</a> file",
        "parent_header": [
          "Examples",
          "Muscle driven with contact"
        ],
        "type": "Text_excerpt",
        "value": "In this example, we implement inequality constraints on two contact forces. It is designed to show how to use min_bound \nand max_bound values for the definition of inequality constraints instead of equality constraints, which can be used with \nany ConstraintFcn.\n\nIn this case, the dynamics function used is `DynamicsFcn.MUSCLE_ACTIVATIONS_AND_TORQUE_DRIVEN_WITH_CONTACT`.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/muscle_driven_with_contact/contact_forces_inequality_constraint_muscle_excitations.py\">contact_forces_inequality_constraint_muscle_excitations.py</a> file",
        "parent_header": [
          "Examples",
          "Muscle driven with contact"
        ],
        "type": "Text_excerpt",
        "value": "In this example, we implement inequality constraints on two contact forces. It is designed to show how to use `min_bound` \nand `max_bound` values so they define inequality constraints instead of equality constraints, which can be used with any \n`ConstraintFcn`.\n\nIn this case, the dynamics function used is `DynamicsFcn.MUSCLE_EXCITATIONS_AND_TORQUE_DRIVEN_WITH_CONTACT` instead of \n`DynamicsFcn.MUSCLE_ACTIVATIONS_AND_TORQUE_DRIVEN_WITH_CONTACT` used in the previous example. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/muscle_driven_with_contact/muscle_activations_contacts_tracker.py\">muscle_activations_contacts_tracker.py</a> file",
        "parent_header": [
          "Examples",
          "Muscle driven with contact"
        ],
        "type": "Text_excerpt",
        "value": "In this example, we track both muscle controls and contact forces, as it is defined when adding the two objective \nfunctions below, using both `ObjectiveFcn.Lagrange.TRACK_MUSCLES_CONTROL` and \n`ObjectiveFcn.Lagrange.TRACK_CONTACT_FORCES` objective functions. \n\n```python\nobjective_functions = ObjectiveList()\nobjective_functions.add(ObjectiveFcn.Lagrange.TRACK_MUSCLES_CONTROL, target=muscle_activations_ref)\nobjective_functions.add(ObjectiveFcn.Lagrange.TRACK_CONTACT_FORCES, target=contact_forces_ref)\n```\n\nLet us take a look at the structure of this example. First, we load data to track and generate data using the \n`data_to_track.prepare_ocp` optimization control program. Then, we track these data using `muscle_activation_ref` and \n`contact_forces_ref` as shown below:\n\n```python\nocp = prepare_ocp(\n    biorbd_model_path=model_path,\n    phase_time=final_time,\n    n_shooting=ns,\n    muscle_activations_ref=muscle_activations_ref[:, :-1],\n    contact_forces_ref=contact_forces_ref,\n)\n```\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Optimal time OCP",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "In this section, you will find four examples showing how to play with time parameters.  \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/optimal_time_ocp/multiphase_time_constraint.py\">multiphase_time_constraint.py</a> file",
        "parent_header": [
          "Examples",
          "Optimal time OCP"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial multiphase box that must superimpose different markers at beginning and end of each\nphase with one of its corners. The time is free for each phase.\nIt is designed to show how to define a multiphase ocp problem with free time. \n\nIn this example, the number of phases is 1 or 3. prepare_ocp function takes `time_min`, `time_max` and `final_time` as \narguments. There are arrays of length 3 in the case of a 3-phase problem. In the example, these arguments are defined \nas shown below:\n\n```python\nfinal_time = [2, 5, 4]\ntime_min = [1, 3, 0.1]\ntime_max = [2, 4, 0.8]\nns = [20, 30, 20]\nocp = prepare_ocp(final_time=final_time, time_min=time_min, time_max=time_max, n_shooting=ns)\n```\n\nWe can make out different time constraints for each phase, as shown in the code below:\n\n```python\nconstraints.add(ConstraintFcn.TIME_CONSTRAINT, node=Node.END, min_bound=time_min[0], max_bound=time_max[0], phase=0)\nif n_phases == 3:\n    constraints.add(\n        ConstraintFcn.TIME_CONSTRAINT, node=Node.END, min_bound=time_min[1], max_bound=time_max[1], phase=1\n    )\n    constraints.add(\n        ConstraintFcn.TIME_CONSTRAINT, node=Node.END, min_bound=time_min[2], max_bound=time_max[2], phase=2\n    )\n```\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/optimal_time_ocp/pendulum_min_time_Mayer.py\">pendulum_min_time_Mayer.py</a>  file",
        "parent_header": [
          "Examples",
          "Optimal time OCP"
        ],
        "type": "Text_excerpt",
        "value": "This is a clone of the example/getting_started/pendulum.py where a pendulum must be balanced. The difference is that\nthe time to perform the task is now free and minimized by the solver, as shown in the definition of the objective \nfunction used for this example: \n\n```python\nobjective_functions = ObjectiveList()\nobjective_functions.add(ObjectiveFcn.Mayer.MINIMIZE_TIME, weight=weight, min_bound=min_time, max_bound=max_time)\n```\n\nPlease note that a weight of -1 will maximize time. \n\nThis example shows how to define such an optimal\ncontrol program with a Mayer criterion (value of `final_time`).\n\nThe difference between Mayer and Lagrange minimization time is that the former can define bounds to\nthe values, while the latter is the most common way to define optimal time.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/optimal_time_ocp/pendulum_min_time_Mayer.py\">time_constraint.py</a> file",
        "parent_header": [
          "Examples",
          "Optimal time OCP"
        ],
        "type": "Text_excerpt",
        "value": "This is a clone of the example/getting_started/pendulum.py where a pendulum must be balanced. The difference is that\nthe time to perform the task is now free for the solver to change. This example shows how to define such an optimal\ncontrol program. \n\nIn this example, a time constraint is implemented:\n\n```python\nconstraints = Constraint(ConstraintFcn.TIME_CONSTRAINT, node=Node.END, min_bound=time_min, max_bound=time_max)\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Symmetrical torque driven OCP",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "In this section, you will find an example using symmetry by constraint and another using symmetry by mapping. In both \ncases, we simulate two rods. We must superimpose a marker on one rod at the beginning and another on the\nsame rod at the end while keeping the degrees of freedom opposed. \n\nThe difference between the first example (symmetry_by_mapping) and the second one (symmetry_by_constraint) is that one \n(mapping) removes the degree of freedom from the solver, while the other (constraints) imposes a proportional \nconstraint (equals to -1), so they are opposed.\nPlease note that even though removing a degree of freedom seems a good idea, it is unclear if it is faster when\nsolving with `IPOPT`.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/symmetrical_torque_driven_ocp/symmetry_by_constraint.py\">symmetry_by_constraint.py</a> file",
        "parent_header": [
          "Examples",
          "Symmetrical torque driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This example imposes a proportional constraint (equals to -1) so that the rotation around the x-axis remains opposed \nfor the two rodes during the movement. \n\nLet us take a look at the definition of such a constraint:\n\n```python\nconstraints.add(ConstraintFcn.PROPORTIONAL_STATE, node=Node.ALL, first_dof=2, second_dof=3, coef=-1)\n```\n\nIn this case, a proportional constraint is generated between the third degree of freedom defined in the `bioMod` file \n(`first_dof=2`) and the fourth one (`second_dof=3`). Looking at the cubeSym.The bioMod file used in this example shows that the dof with index 2 corresponds to the rotation around the x-axis for the first segment `Seg1`. The dof \nwith index 3 corresponds to the rotation around the x-axis for the second segment `Seg2`. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/symmetrical_torque_driven_ocp/symmetry_by_mapping.py\">symmetry_by_mapping.py file</a>",
        "parent_header": [
          "Examples",
          "Symmetrical torque driven OCP"
        ],
        "type": "Text_excerpt",
        "value": "This example imposes the symmetry as a mapping by completely removing the degree of freedom from the solver \nvariables but interpreting the numbers properly when computing the dynamics.\n\nA `BiMapping` is used. The way to understand the mapping is that if one is provided with two vectors, what would be the correspondence between those vectors. For instance, `BiMapping([None, 0, 1, 2, -2], [0, 1, 2])`\nwould mean that the first vector (v1) has 3 components, and to create it from the second vector (v2), you would do the following:\nv1 = [v2[0], v2[1], v2[2]]. Conversely, the second v2 has 5 components and is created from the vector v1 using:\nv2 = [0, v1[0], v1[1], v1[2], -v1[2]]. For the dynamics, it is assumed that v1 is to be sent to the dynamic\nfunctions (the full vector with all the degrees of freedom), while v2 is the one sent to the solver (the one with fewer\ndegrees of freedom).\n\nThe `BiMapping` used is defined as a problem parameter, as shown below:\n\n```python\nall_generalized_mapping = BiMapping([0, 1, 2, -2], [0, 1, 2])\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Track",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "In this section, you will find the description of three tracking examples. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/track/track_marker_on_segment.py\">track_marker_on_segment.py</a> file",
        "parent_header": [
          "Examples",
          "Track"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial example where a stick must keep a corner of a box in line for the whole duration of the\nmovement. The initial and final positions of the box are dictated; the rest is fully optimized. It is designed\nto show how to use the tracking function for tracking a marker with a body segment.\n\nIn this case, we use the `ConstraintFcn.TRACK_MARKER_WITH_SEGMENT_AXIS` constraint function, as shown below in the \ndefinition of the constraints of the problem:\n\n```python\nconstraints = ConstraintList()\nconstraints.add(\nConstraintFcn.TRACK_MARKER_WITH_SEGMENT_AXIS, node=Node.ALL, marker_idx=1, segment_idx=2, axis=Axis.X\n)\n```\n\nHere, we minimize the distance between the marker with index 1 and the x-axis of the segment with index 2. We align \nthe axis toward the marker. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/track/track_segment_on_rt.py\">track_segment_on_rt.py</a> file",
        "parent_header": [
          "Examples",
          "Track"
        ],
        "type": "Text_excerpt",
        "value": "This example is a trivial example where a stick must keep its coordinate system of axes aligned with the one\nfrom a box during the whole duration of the movement. The initial and final positions of the box are dictated;\nthe rest is fully optimized. It is designed to show how to use the tracking RT function for tracking\nany RT (for instance, Inertial Measurement Unit [IMU]) with a body segment.\n\nTo implement this tracking task, we use the `ConstraintFcn.TRACK_SEGMENT_WITH_CUSTOM_RT` constraint function, which \nminimizes the distance between a segment and an RT. The extra parameters `segment_idx: int` and `rt_idx: int` must be \npassed to the Objective constructor.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/track/track_vector_orientation.py\">track_vector_orientation.py</a> file",
        "parent_header": [
          "Examples",
          "Track"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Moving estimation horizon (MHE)",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "In this section, we perform MHE on the pendulum example.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/moving_horizon_estimation/mhe.py\">mhe.py</a> file",
        "parent_header": [
          "Examples",
          "Moving estimation horizon (MHE)"
        ],
        "type": "Text_excerpt",
        "value": "In this example, MHE is applied to a simple pendulum simulation. Data are generated (states,\ncontrols, and marker trajectories) to simulate the movement of a pendulum, using `scipy.integrate.solve_ivp`. These data\nare used to perform MHE.\n\nIn this example, 500 shooting nodes are defined. As the size of the MHE window is 10, 490 iterations are performed to\nsolve the complete problem.\n\nFor each iteration, the new marker trajectory is considered so that real-time data acquisition is simulated.\nFor each iteration, the list of objectives is updated, the problem is solved with the new frame added to the window,\nthe oldest frame is discarded with the `warm_start_mhe function`, and it is saved. The results are plotted to compare estimated data to real data. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/moving_horizon_estimation/cyclic_nmpc.py\">cyclic_nmpc.py</a> file",
        "parent_header": [
          "Examples",
          "Moving estimation horizon (MHE)"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/moving_horizon_estimation/multi_cyclic_nmpc.py\">multi_cyclic_nmpc.py</a> file",
        "parent_header": [
          "Examples",
          "Moving estimation horizon (MHE)"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Acados",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "In this section, you will find three examples to investigate `bioptim` using `acados`. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/acados/cube.py\">cube.py</a> file",
        "parent_header": [
          "Examples",
          "Acados"
        ],
        "type": "Text_excerpt",
        "value": "This is a basic example of a cube that must reach a target at the end of the movement, starting from an initial \nposition while minimizing states and torques. This problem is solved using `acados`. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/acados/pendulum.py\">pendulum.py</a> file",
        "parent_header": [
          "Examples",
          "Acados"
        ],
        "type": "Text_excerpt",
        "value": "This simple yet meaningful optimal control program consists of a pendulum starting downward and ending upward\nwhile minimizing the generalized forces. The solver can only move the pendulum sideways.\n\nThis simple example is an excellent place to investigate `bioptim` using `acados` as it describes the most common\ndynamics (the joint torque driven). It also defines an objective function and some boundaries and initial guesses.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/acados/static_arm.py\">static_arm.py</a> file",
        "parent_header": [
          "Examples",
          "Acados"
        ],
        "type": "Text_excerpt",
        "value": "This basic example shows how to use biorbd model driven by muscle to perform an optimal reaching task.\nThe arm must reach a marker while minimizing the muscles' activity and the states. We solve the problem using both \n`acados` and `ipopt`.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Inverse optimal control",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "In this section, you will find an example of inverse optimal control with `bioptim`. \n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The <a href=\"./bioptim/examples/inverse_optimal_control/double_pendulum_torque_driven_IOCP.py\">double_pendulum_torque_driven_IOCP.py</a> file",
        "parent_header": [
          "Examples",
          "Inverse optimal control"
        ],
        "type": "Text_excerpt",
        "value": "This basic example is a rigid double pendulum that circles a fixed point.\nThe movement is inspired by the motion of gymnasts on the bar apparatus.\nThis example is separated into three parts:\n- The first part is the definition of the problem. The problem is solved with specific weightings.\n- The second part solves the problem with only one objective at a time for the Pareto front.\n- The third part solves the inverse optimal control problem aiming to retrieve the initial weightings.\nA the end of the example, the markers' trajectories are plotted to show that the movement is the same.\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Discrete mechanics and optimal control",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Fatigue",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Holonomic constraints",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "SQP method",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Stochastic optimal control",
        "parent_header": [
          "Examples"
        ],
        "type": "Text_excerpt",
        "value": "*#TODO*\n\n\n"
      },
      "source": "https://raw.githubusercontent.com/pyomeca/bioptim/master/README.md",
      "technique": "header_analysis"
    }
  ]
}
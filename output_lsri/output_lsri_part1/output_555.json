{
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/francescodc87/ipaPy2"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2022-08-31T15:05:14Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-02-20T04:08:28Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "New Python implementation of the Integrated Probabilistic Annotation (IPA) - A Bayesian annotation method for LC/MS data integrating biochemical relations, isotope patterns and adduct formation"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 0.989461267913352,
      "result": {
        "original_header": "ipaPy2",
        "type": "Text_excerpt",
        "value": "Python implementation of the Integrated Probabilistic Annotation (IPA) - A Bayesian annotation method for LC/MS data integrating biochemical relations,\nisotope patterns and adduct formation.\n![alt text](figure_paper.png)\n \n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9778870576686112,
      "result": {
        "original_header": "Databases",
        "type": "Text_excerpt",
        "value": "One of the most powerful features of the IPA method is that it is able to integrate the knowledge gained from previous experiments in the annotation process. There are three files that are used as the IPA database: \n**2. MS<sup>1</sup> database file (required)**\n<br />\nThe IPA method requires a pandas dataframe containing the database against which the annotation is performed.\nThis dataframe must contain the following columns in this exact order (optional columns can have empty fields):\n- **id**: unique id of the database entry (e.g., 'C00031') - *necessary*\n- **name**: compound name (e.g., 'D-Glucose') - *necessary*\n- **formula**: chemical formula (e.g., 'C6H12O6') - *necessary*\n- **inchi**: inchi string - *optional*\n- **smiles**: smiles string - *optional*\n- **RT**: if known, retention time range (in seconds) where this compound is expected to elute (e.g., '30;60') - *optional*\n- **adductsPos**: list of adducts that should be considered in Positive mode for this entry (e.g.,'M+Na;M+H;M+') - *necessary*\n- **adductsNeg**: list of adducts that should be considered in Negative mode for this entry (e.g.,'M-H;M-2H') - *necessary*\n- **description**: comments on the entry - *optional*\n- **pk**: previous knowledge on the likelihood of this compound to be present in the sample analyse. The value has to be between 1 (compound highly likely to be present in the sample) and 0 (compound cannot be present in the sample).\n- **MS2**: id for the MS<sup>2</sup> database entries related to this compound - *optional*\n- **reactions**: list of reaction ids involving this compound (e.g., 'R00010 R00015 R00028'). If required, these can be used to find possible biochemical connections - *optional*  \nThis example databases was obtained considering the [KEGG database](https://www.genome.jp/kegg/compound/), the [Natural Products Atlas database](https://www.npatlas.org) and the [MoNa database](https://mona.fiehnlab.ucdavis.edu) (only compounds having at least one fragmentation spectrum obtained with a QExactive).\nFor each entry, only a handful of the most common adducts are considered.\nTo fully exploit the IPA method, it is strongly recommended to constantly update the database when new knowledge is gained from previous experience. Providing a retention time window for compounds previously detected with the analytical system at hand it is particularly useful.\nFor the sake of the example in this tutorial, a reduced example database is also provided. \n**3. MS<sup>2</sup> database file (only required if MS<sup>2</sup> data is available)**\n<br />\nThis new implementation of the IPA method also allows the user to include MS<sup>2</sup> data in the annotation pipeline.\nIn order to exploit this functionality an MS<sup>2</sup> spectra database must be provided.\nThe MS<sup>2</sup> database must be provided as a pandas dataframe including the following columns in this exact order:\n- **compound_id**: unique id for each compound, it must match with the ids used in the MS<sup>1</sup> database - *necessary*\n- **id**: unique id for the single entry (i.e., spectra) of the database - *necessary*\n- **name**: compound name (e.g., 'D-Glucose') - *necessary*\n- **formula**: chemical formula (e.g., 'C6H12O6') - *necessary*\n- **inchi**: inchi string - *optional*\n- **precursorType**: the adduct form of the precursor ion (e.g., 'M+H') - *necessary*\n- **instrument**: the type of instrument the spectrum was acquired with - *optional*\n- **collision.energy**: the collision energy level used to acquire the spectrum (e.g., '15') - *necessary*\n- **spectrum**: the actual spectrum in the form of a string in the following format 'mz1:Int1 mz2:Int2 mz3:Int3 ...' \nIt is necessary that the user uses an MS<sup>2</sup> database specific to the instrument used to acquire the data.\nThe MS<sup>2</sup> database found [here](https://drive.google.com/file/d/15qduvtE8aSAAUCf1FE4ojcVLaTw-B2W6/view?usp=sharing), contains all the MS<sup>2</sup> spectra found in the [MoNa](https://mona.fiehnlab.ucdavis.edu) database acquired with a QExactive. This is a relatively big file, and for the sake of this tutorial a drastically reduced version of it has been included within this repository, and can be found [here](DB/DBMS2_test_pos.csv). \n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/francescodc87/ipaPy2/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "executable_example": [
    {
      "confidence": 1,
      "result": {
        "format": "jupyter_notebook",
        "type": "Url",
        "value": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/QTOF_DDA_example.ipynb"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/QTOF_DDA_example.ipynb",
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "format": "jupyter_notebook",
        "type": "Url",
        "value": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/Beer_example.ipynb"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/Beer_example.ipynb",
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "format": "jupyter_notebook",
        "type": "Url",
        "value": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/Integration_with_mzMatch.ipynb"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/Integration_with_mzMatch.ipynb",
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "format": "jupyter_notebook",
        "type": "Url",
        "value": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/Synthetic_example.ipynb"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/Synthetic_example.ipynb",
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "format": "jupyter_notebook",
        "type": "Url",
        "value": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "format": "jupyter_notebook",
        "type": "Url",
        "value": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/Ecoli_example.ipynb"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/Ecoli_example.ipynb",
      "technique": "file_exploration"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 1
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/francescodc87/ipaPy2/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "francescodc87/ipaPy2"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "ipaPy2"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "regular_expression"
    }
  ],
  "images": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/figure_paper.png"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "regular_expression"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Installation",
        "parent_header": [
          "ipaPy2"
        ],
        "type": "Text_excerpt",
        "value": "ipaPy2 requires Python 3.9 or higher\n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Install via pip (recommended)",
        "parent_header": [
          "ipaPy2",
          "Installation"
        ],
        "type": "Text_excerpt",
        "value": "```\npip install ipaPy2\n```\n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Install via bioconda",
        "parent_header": [
          "ipaPy2",
          "Installation"
        ],
        "type": "Text_excerpt",
        "value": "```\nconda install ipaPy2\n```\n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Compiling from source (macOS)",
        "parent_header": [
          "ipaPy2",
          "Installation"
        ],
        "type": "Text_excerpt",
        "value": "1. Create a folder in which you want to put the library\n```\nmkdir IPA\ncd IPA\n```\n2. Download the library. If Homebrew is not installed in your machine, you can install it from here https://brew.sh \n```\nbrew install git\n```\n```\ngit clone https://github.com/francescodc87/ipaPy2\ncd ipaPy2\n```\n3. Create and activate a virtual environment for your folder and install the necessary libraries\n```\npython3 -m venv ipaPy2\nsource ipaPy2/bin/activate\npip install wheel\npip install setuptools\npip install twine\npip install pytest==4.4.1\npip install pytest-runner==4.4\n```\n4. Run tests (optional)\n```\npython setup.py pytest\n```\n5. Build your library\n```\npython setup.py bdist_wheel\n```\n6. The wheel file will be stored in the \\dist folder. You can install the library in a new terminal as follows\n```\npip install /path/to/wheelfile.whl\n```\n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Compiling from source (Linux)",
        "parent_header": [
          "ipaPy2",
          "Installation"
        ],
        "type": "Text_excerpt",
        "value": "1. Create a folder in which you want to put the library\n```\nmkdir IPA\ncd IPA\n```\n2. Download the library\n```\nsudo apt-get install git\ngit clone https://github.com/francescodc87/ipaPy2\ncd ipaPy2\n```\n3. Create and activate a virtual environment for your folder and install the necessary libraries\n```\npython3 -m venv ipaPy2\nsource ipaPy2/bin/activate\npip install wheel\npip install setuptools\npip install twine\npip install pytest==4.4.1\npip install pytest-runner==4.4\n```\n4. Run tests (optional)\n```\npython setup.py pytest\n```\n5. Build your library\n```\npython setup.py bdist_wheel\n```\n6. The wheel file will be stored in the \\dist folder. You can install the library in a new terminal as follows\n```\npip install /path/to/wheelfile.whl\n```\n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Compiling from source (Windows)",
        "parent_header": [
          "ipaPy2",
          "Installation"
        ],
        "type": "Text_excerpt",
        "value": "1. Create a folder in which you want to put the library\n```\nmkdir IPA\ncd IPA\n```\n2. Install git (https://github.com/git-guides/install-git)\n3. Download the library\n```\ngit clone https://github.com/francescodc87/ipaPy2\ncd ipaPy2\n```\n3. Create and activate a virtual environment for your folder and install the necessary libraries\n```\npython3 -m venv ipaPy2\nsource ipaPy2/bin/activate\npip install wheel\npip install setuptools\npip install twine\npip install pytest==4.4.1\npip install pytest-runner==4.4\n```\n4. Run tests (optional)\n```\npython setup.py pytest\n```\n5. Build your library\n```\npython setup.py bdist_wheel\n```\n6. The wheel file will be stored in the \\dist folder. You can install the library in a new terminal as follows\n```\npip install /path/to/wheelfile.whl\n```\n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Data preparation",
        "parent_header": [
          "ipaPy2"
        ],
        "type": "Text_excerpt",
        "value": "Before using the ipaPy2 package, the processed data coming from an untargeted metabolomics experiment must be properly prepared.\n\n**1. MS<sup>1</sup> data**\n\nThe data must be organized in a pandas dataframe containing the following columns:\n- **ids**: an unique numeric id for each mass spectrometry feature feature\n- **rel.ids**: relation ids. Features must be clustered based on correlation/peak shape/retention time. Features in the same cluster are likely to come from the same metabolite.\n- **mzs**: mass-to-charge ratios, usually the average across different samples.\n- **RTs**: retention times in seconds, usually the average across different samples.\n- **Int**: representative (e.g., maximum or average) intensity detected for each feature across samples (either peak area or peak intensity)\n\n\nBelow is reported an example:\n\n\n```python\ndf1=pd.read_csv('ExampleDatasets/README/df_test_pos.csv')\ndf1.head()\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ids</th>\n      <th>rel.ids</th>\n      <th>mzs</th>\n      <th>RTs</th>\n      <th>Int</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>0</td>\n      <td>116.070544</td>\n      <td>45.770423</td>\n      <td>2.170017e+09</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>88</td>\n      <td>0</td>\n      <td>117.073678</td>\n      <td>45.787586</td>\n      <td>1.256520e+08</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>501</td>\n      <td>0</td>\n      <td>231.133673</td>\n      <td>46.183948</td>\n      <td>2.519223e+07</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4429</td>\n      <td>0</td>\n      <td>232.136923</td>\n      <td>46.176715</td>\n      <td>2.635594e+06</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2</td>\n      <td>1</td>\n      <td>104.106830</td>\n      <td>40.843309</td>\n      <td>1.889172e+09</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nThe clustering of the features is a necessary and must be performed before running the IPA method. For this step, the use of widely used data processing software such as [mzMatch](https://github.com/UoMMIB/mzmatch.R) and [CAMERA](https://bioconductor.org/packages/release/bioc/html/CAMERA.html) is recommended.\nNevertheless, the ipaPy2 library provides a function (clusterFeatures()) able to perform such step, starting from a dataframe containing the measured intensities across several samples (at least 3 samples, the more samples the better). \nSuch dataframe should be organized as follows:\n\n\n```python\ndf2=pd.read_csv('ExampleDatasets/README/df_test_pos_not_clustered.csv')\ndf2.head()\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ids</th>\n      <th>mzs</th>\n      <th>RTs</th>\n      <th>sample1</th>\n      <th>sample2</th>\n      <th>sample3</th>\n      <th>sample4</th>\n      <th>sample5</th>\n      <th>sample6</th>\n      <th>sample7</th>\n      <th>sample8</th>\n      <th>sample9</th>\n      <th>sample10</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>116.070544</td>\n      <td>45.770423</td>\n      <td>1.003660e+09</td>\n      <td>1.299828e+09</td>\n      <td>1.878029e+09</td>\n      <td>1.778238e+09</td>\n      <td>1.715394e+09</td>\n      <td>4.340034e+08</td>\n      <td>1.586635e+09</td>\n      <td>2.170017e+09</td>\n      <td>1.312151e+09</td>\n      <td>2.051875e+09</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>104.106830</td>\n      <td>40.843309</td>\n      <td>3.778343e+08</td>\n      <td>8.721901e+08</td>\n      <td>8.353805e+08</td>\n      <td>1.889172e+09</td>\n      <td>1.114844e+09</td>\n      <td>1.296362e+09</td>\n      <td>7.361379e+08</td>\n      <td>7.386887e+08</td>\n      <td>9.546864e+08</td>\n      <td>6.969054e+08</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>118.085998</td>\n      <td>43.584638</td>\n      <td>5.984715e+08</td>\n      <td>1.399106e+09</td>\n      <td>2.831220e+08</td>\n      <td>1.415610e+09</td>\n      <td>7.557607e+08</td>\n      <td>7.800359e+08</td>\n      <td>8.949854e+08</td>\n      <td>5.074069e+08</td>\n      <td>6.854525e+08</td>\n      <td>1.000501e+09</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>166.086047</td>\n      <td>143.321396</td>\n      <td>1.390905e+09</td>\n      <td>1.047887e+09</td>\n      <td>1.053413e+09</td>\n      <td>2.781809e+08</td>\n      <td>1.037486e+09</td>\n      <td>1.117700e+09</td>\n      <td>6.153332e+08</td>\n      <td>1.215932e+09</td>\n      <td>1.264092e+09</td>\n      <td>1.370995e+09</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>132.101745</td>\n      <td>89.387202</td>\n      <td>6.071912e+08</td>\n      <td>1.014152e+09</td>\n      <td>1.270735e+09</td>\n      <td>1.069765e+09</td>\n      <td>4.925938e+08</td>\n      <td>4.087633e+08</td>\n      <td>3.777945e+08</td>\n      <td>2.541470e+08</td>\n      <td>8.025257e+08</td>\n      <td>3.544281e+08</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\n\n```python\nfrom ipaPy2 import ipa\ndf=ipa.clusterFeatures(df2)\n```\n\n    Clustering features ....\n    0.0 seconds elapsed\n\n\nAll information about the function can be found in the help of the function\n\n\n```python\nhelp(ipa.clusterFeatures)\n```\n\n    Help on function clusterFeatures in module ipaPy2.ipa:\n    \n    clusterFeatures(df, Cthr=0.8, RTwin=1, Intmode='max')\n        Clustering MS1 features based on correlation across samples.\n        \n        Parameters\n        ----------\n        df: pandas dataframe with the following columns:\n            -ids: a unique id for each feature\n            -mzs: mass-to-charge ratios, usually the average across different\n                  samples.\n            -RTs: retention times in seconds, usually the average across different\n                  samples.\n            -Intensities: for each sample, a column reporting the detected\n                          intensities in each sample. \n        Cthr: Default value 0.8. Minimum correlation allowed in each cluster\n        RTwin: Default value 1. Maximum difference in RT time between features in\n               the same cluster\n        Intmode: Defines how the representative intensity of each feature is\n                 computed. If 'max' (default) the maximum across samples is used.\n                 If 'ave' the average across samples is computed\n        Returns\n        -------\n        df: pandas dataframe in correct format to be used as an input of the\n        map_isotope_patterns() function\n    \n\n\nAfter running, this function returns a pandas dataframe in the correct format for the ipaPy2 package\n\n\n```python\ndf.head()\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ids</th>\n      <th>rel.ids</th>\n      <th>mzs</th>\n      <th>RTs</th>\n      <th>Int</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>0</td>\n      <td>116.070544</td>\n      <td>45.770423</td>\n      <td>2.170017e+09</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>88</td>\n      <td>0</td>\n      <td>117.073678</td>\n      <td>45.787586</td>\n      <td>1.256520e+08</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>501</td>\n      <td>0</td>\n      <td>231.133673</td>\n      <td>46.183948</td>\n      <td>2.519223e+07</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4429</td>\n      <td>0</td>\n      <td>232.136923</td>\n      <td>46.176715</td>\n      <td>2.635594e+06</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2</td>\n      <td>1</td>\n      <td>104.106830</td>\n      <td>40.843309</td>\n      <td>1.889172e+09</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\n**2. MS<sup>2</sup> data**\n\nIf fragmentation data was acquired during the experiment, it can be included in the IPA annotation process.\nTo do so, the data must be organized in a pandas dataframe containing the following columns, in this exact order:\n- **id**: an unique id for each feature for which the MS<sup>2</sup> spectrum was acquired (same as in MS<sup>1</sup>)\n- **spectrum**: string containing the spectrum information in the following format 'mz1:Int1 mz2:Int2 mz3:Int3 ...'\n- **ev**: collision energy used to acquire the fragmentation spectrum\n\nBelow is reported an example:\n\n\n```python\ndfMS2=pd.read_csv('ExampleDatasets/README/MS2data_example.csv')\ndfMS2.head()\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>spectrum</th>\n      <th>ev</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>51.3066132836457:0.884272376680125 59.96532241...</td>\n      <td>35</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>51.3066132836457:0.884272376680125 59.96532241...</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>90</td>\n      <td>62.4153253406374:0.743812036877455 63.93291389...</td>\n      <td>35</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>992</td>\n      <td>50.983321052233:0.973529955385613 53.039006800...</td>\n      <td>35</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>3</td>\n      <td>55.0551847656264:5.67780579195993 57.058126021...</td>\n      <td>35</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.9724652792881773,
      "result": {
        "original_header": "Databases",
        "type": "Text_excerpt",
        "value": "**2. MS<sup>1</sup> database file (required)**\n<br />\nThe IPA method requires a pandas dataframe containing the database against which the annotation is performed.\nThis dataframe must contain the following columns in this exact order (optional columns can have empty fields):\n- **id**: unique id of the database entry (e.g., 'C00031') - *necessary*\n- **name**: compound name (e.g., 'D-Glucose') - *necessary*\n- **formula**: chemical formula (e.g., 'C6H12O6') - *necessary*\n- **inchi**: inchi string - *optional*\n- **smiles**: smiles string - *optional*\n- **RT**: if known, retention time range (in seconds) where this compound is expected to elute (e.g., '30;60') - *optional*\n- **adductsPos**: list of adducts that should be considered in Positive mode for this entry (e.g.,'M+Na;M+H;M+') - *necessary*\n- **adductsNeg**: list of adducts that should be considered in Negative mode for this entry (e.g.,'M-H;M-2H') - *necessary*\n- **description**: comments on the entry - *optional*\n- **pk**: previous knowledge on the likelihood of this compound to be present in the sample analyse. The value has to be between 1 (compound highly likely to be present in the sample) and 0 (compound cannot be present in the sample).\n- **MS2**: id for the MS<sup>2</sup> database entries related to this compound - *optional*\n- **reactions**: list of reaction ids involving this compound (e.g., 'R00010 R00015 R00028'). If required, these can be used to find possible biochemical connections - *optional*  \n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "supervised_classification"
    }
  ],
  "invocation": [
    {
      "confidence": 0.8882365845114423,
      "result": {
        "original_header": "Databases",
        "type": "Text_excerpt",
        "value": "```python\nimport pandas as pd\nimport numpy as np\nadducts = pd.read_csv('DB/adducts.csv')\nadducts.head()\n``` \n\n```python\nDB = pd.read_csv('DB/IPA_MS1.csv')\nDB.head()\n``` \n\n```python\nDB = pd.read_csv('DB/DB_test_pos.csv')\nDB.head()\n``` \n```python\nDBMS2 = pd.read_csv('DB/DBMS2_test_pos.csv')\nDBMS2.head()\n``` \n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/francescodc87/ipaPy2/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "MIT License",
        "spdx_id": "MIT",
        "type": "License",
        "url": "https://api.github.com/licenses/mit",
        "value": "https://api.github.com/licenses/mit"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "MIT License\n\nCopyright (c) 2022 francescodc87\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/LICENSE",
      "technique": "file_exploration"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "ipaPy2"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "User",
        "value": "francescodc87"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "Jupyter Notebook",
        "size": 281440,
        "type": "Programming_language",
        "value": "Jupyter Notebook"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Python",
        "size": 119164,
        "type": "Programming_language",
        "value": "Python"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "R",
        "size": 4045,
        "type": "Programming_language",
        "value": "R"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "releases": [
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "francescodc87",
          "type": "User"
        },
        "date_created": "2023-03-09T11:14:31Z",
        "date_published": "2023-03-13T16:42:42Z",
        "description": "**ipaPy2 v1.3.0**\r\n\r\nNew implementation of the **Integrated Probabilistic Annotation (IPA)** - A Bayesian annotation method for LC-MS/MS data integrating biochemical relations, isotope patterns and adduct formation.\r\n\r\nThis completely refactored version of method has been fully implemented in Python.  Compared to its predecessor, ipaPy2\r\n\r\n1. is able to integrate tandem MS fragmentation data\r\n2. provides auser-friendly interface\r\n3. isotope peaks are treated as fingerprints, \r\n4. is fully integrated with the mzMatch pipeline and with the newly developed PeakMLViewerPy tool available at https://github.com/UoMMIB/PeakMLViewerPy\r\n",
        "html_url": "https://github.com/francescodc87/ipaPy2/releases/tag/ipaPy2",
        "name": "ipaPy2 v1.3.0",
        "release_id": 95426385,
        "tag": "ipaPy2",
        "tarball_url": "https://api.github.com/repos/francescodc87/ipaPy2/tarball/ipaPy2",
        "type": "Release",
        "url": "https://api.github.com/repos/francescodc87/ipaPy2/releases/95426385",
        "value": "https://api.github.com/repos/francescodc87/ipaPy2/releases/95426385",
        "zipball_url": "https://api.github.com/repos/francescodc87/ipaPy2/zipball/ipaPy2"
      },
      "technique": "GitHub_API"
    }
  ],
  "somef_missing_categories": [
    "citation",
    "acknowledgement",
    "run",
    "download",
    "requirements",
    "contact",
    "contributors",
    "documentation",
    "faq",
    "support",
    "identifier",
    "has_build_file"
  ],
  "somef_provenance": {
    "date": "2024-10-04 01:11:30",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 6
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Usage",
        "parent_header": [
          "ipaPy2"
        ],
        "type": "Text_excerpt",
        "value": "The Integrated Probabilistic Annotation (IPA) method can be applied in different situations, and the ipaPy2 package allows the users to tailor the IPA pipeline around their specific needs.\n\nThis brief tutorial describes the most common scenarios the IPA method can be applied to.\n\n**1. Mapping isotope patterns**\n\nThe first step of the IPA pipeline consists in the mapping of the isotope patterns within the dataset considered. This is achieved through the map_isotope_patterns(). The help of this function provides a detailed description of it.\n\n\n```python\nhelp(ipa.map_isotope_patterns)\n```\n\n    Help on function map_isotope_patterns in module ipaPy2.ipa:\n    \n    map_isotope_patterns(df, isoDiff=1, ppm=100, ionisation=1, MinIsoRatio=0.5)\n        mapping isotope patterns in MS1 data.\n        \n        Parameters\n        ----------\n        df : pandas dataframe (necessary)\n             A dataframe containing the MS1 data including the following columns:\n                -ids: an unique id for each feature\n                -rel.ids:   relation ids. In a previous step of the data processing\n                            pipeline, features are clustered based on peak shape\n                            similarity/retention time. Features in the same\n                            cluster are likely to come from the same metabolite.\n                            All isotope patterns must be in the same rel.id\n                            cluster.\n                -mzs: mass-to-charge ratios, usually the average across\n                      different samples.\n                -RTs: retention times in seconds, usually the average across\n                      different samples.\n                -Ints: representative (e.g., maximum or average) intensity detected\n                       for each feature across samples (either peak area or peak\n                       intensity)\n        isoDiff : Default value 1. Difference between isotopes of charge 1, does\n                  not need to be exact\n        ppm:   Default value 100. Maximum ppm value allowed between 2 isotopes.\n                It is very high on purpose\n        ionisation: Default value 1. positive = 1, negative = -1\n        MinIsoRatio: mininum intensity ratio expressed (Default value 1%). Only\n                    isotopes with intensity higher than MinIsoRatio% of the main isotope\n                    are considered.\n        \n        Returns\n        -------\n        df: the main input is modified by adding and populating the following\n            columns\n            - relationship: the possible values are:\n                            * bp: basepeak, most intense peak within each rel id\n                            * bp|isotope: isotope of the basepeak\n                            * potential bp: most intense peak within each isotope\n                                            pattern (excluding the basepeak)\n                            * potential bp|isotope: isotope of one potential bp\n            - isotope pattern: feature used to cluster the different isotope\n                                patterns within the same relation id\n            - charge: predicted charge based on the isotope pattern (1,2,3,4,5 or\n                      -1,-2,-3,-4,-5 are the only values allowed)\n    \n\n\nFor the sake of this tutorial, the small dataset example introduced above is considered.\n\n\n```python\nipa.map_isotope_patterns(df,ionisation=1)\n```\n\n    mapping isotope patterns ....\n    0.1 seconds elapsed\n\n\nOnce finished, this function modifies the pandas dataframe provided as input annotating all isotope patterns.\n\n\n```python\ndf.head()\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ids</th>\n      <th>rel.ids</th>\n      <th>mzs</th>\n      <th>RTs</th>\n      <th>Int</th>\n      <th>relationship</th>\n      <th>isotope pattern</th>\n      <th>charge</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>0</td>\n      <td>116.070544</td>\n      <td>45.770423</td>\n      <td>2.170017e+09</td>\n      <td>bp</td>\n      <td>0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>88</td>\n      <td>0</td>\n      <td>117.073678</td>\n      <td>45.787586</td>\n      <td>1.256520e+08</td>\n      <td>bp|isotope</td>\n      <td>0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>501</td>\n      <td>0</td>\n      <td>231.133673</td>\n      <td>46.183948</td>\n      <td>2.519223e+07</td>\n      <td>potential bp</td>\n      <td>1</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4429</td>\n      <td>0</td>\n      <td>232.136923</td>\n      <td>46.176715</td>\n      <td>2.635594e+06</td>\n      <td>potential bp|isotope</td>\n      <td>1</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2</td>\n      <td>1</td>\n      <td>104.106830</td>\n      <td>40.843309</td>\n      <td>1.889172e+09</td>\n      <td>bp</td>\n      <td>0</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nSome data processing pipelines already have an isotope mapping function and the user can use them as long as they organise the data in the correct format.\n\n**2. Compute all adducts**\n\nThe second step of the pipeline consists in the calculation of all possible adducts that could be formed by the compounds included in the database.\nThis is done by the function compute_all_adducts(). This function comes with a very detailed help.\n\n\n```python\nhelp(ipa.compute_all_adducts)\n```\n\n    Help on function compute_all_adducts in module ipaPy2.ipa:\n    \n    compute_all_adducts(adductsAll, DB, ionisation=1, ncores=1)\n        compute all adducts table based on the information present in the database\n        \n        Parameters\n        ----------\n        adductsAll : pandas dataframe (necessary)\n                     Dataframe containing information on all possible\n                     adducts. The file must be in the same format as the example\n                     provided in the DB/adducts.csv\n        DB : pandas dataframe (necessary)\n             Dataframe containing the database against which the annotation is\n             performed. The DB must contain the following columns in this exact\n             order (optional fields can contain None):\n                 - id: unique id of the database entry (e.g., 'C00031') - necessary\n                 - name: compound name (e.g., 'D-Glucose') - necessary\n                 - formula: chemical formula (e.g., 'C6H12O6') - necessary\n                 - inchi: inchi string - optional\n                 - smiles: smiles string - optional\n                 - RT: if known, retention time range (in seconds) where this\n                       compound is expected to elute (e.g., '30;60') - optional\n                 - adductsPos: list of adducts that should be considered in\n                               positive mode for this entry (e.g.,'M+Na;M+H;M+')\n                 - adductsNeg: list of adducts that should be considered in\n                               negative mode for this entry (e.g.,'M-H;M-2H')\n                 - description: comments on the entry - optional\n                 - pk: previous knowledge on the likelihood of this compound to be\n                       present in the sample analysed. The value has to be between\n                       1 (compound likely to be present in the sample) and 0\n                       (compound cannot be present in the sample).\n                 - MS2: id for the MS2 database entries related to this compound\n                        (optional)\n                 - reactions: list of reactions ids involving this compound\n                              (e.g., 'R00010 R00015 R00028')-optional \n        ionisation : Default value 1. positive = 1, negative = -1\n        ncores : default value 1. Number of cores used\n        \n        Returns\n        -------\n        allAdds: pandas dataframe containing the information on all the possible\n        adducts given the database.\n    \n\n\nDepending on the size of the dataset used (i.e., number of compounds included), this step can become rather time-consuming, and the use of multiple cores should be considered.\nIn the context of this tutorial, the heavily reduced example dataset introduced before is considered.\n\n\n```python\nallAddsPos = ipa.compute_all_adducts(adducts, DB, ionisation=1, ncores=1)\n```\n\n    computing all adducts ....\n    0.1 seconds elapsed\n\n\n\n```python\nallAddsPos.head()\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>name</th>\n      <th>adduct</th>\n      <th>formula</th>\n      <th>charge</th>\n      <th>m/z</th>\n      <th>RT</th>\n      <th>pk</th>\n      <th>MS2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C00079</td>\n      <td>L-Phenylalanine</td>\n      <td>M+H</td>\n      <td>C9H12NO2</td>\n      <td>1</td>\n      <td>166.086255</td>\n      <td>120;160</td>\n      <td>1</td>\n      <td>UA005501_1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>C00079</td>\n      <td>L-Phenylalanine</td>\n      <td>M+Na</td>\n      <td>C9H11NNaO2</td>\n      <td>1</td>\n      <td>188.068197</td>\n      <td>120;160</td>\n      <td>1</td>\n      <td>UA005501_1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C00079</td>\n      <td>L-Phenylalanine</td>\n      <td>M+2H</td>\n      <td>C9H13NO2</td>\n      <td>2</td>\n      <td>83.546765</td>\n      <td>120;160</td>\n      <td>1</td>\n      <td>UA005501_1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>C00079</td>\n      <td>L-Phenylalanine</td>\n      <td>2M+H</td>\n      <td>C18H23N2O4</td>\n      <td>1</td>\n      <td>331.165233</td>\n      <td>120;160</td>\n      <td>1</td>\n      <td>UA005501_1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>C00082</td>\n      <td>L-Tyrosine</td>\n      <td>M+H</td>\n      <td>C9H12NO3</td>\n      <td>1</td>\n      <td>182.081169</td>\n      <td>50;90</td>\n      <td>1</td>\n      <td>UA005601_1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nIf the same database is used for subsequent experiments without introducing new information, it is recommended to save the results of this function into a .csv file. In this case, the user would need to repeat this step in the future only if the DB changed.\n\n**3. Annotation based on MS<sup>1</sup> information**\n\nAt this point, the actual annotation process can start. If no fragmentation data is available, the MS1annotation() function should be used. This function annotates the dataset using the MS<sup>1</sup> data and the information stored in the dataset. A detailed description of the function can be accessed through the help:\n\n\n```python\nhelp(ipa.MS1annotation)\n```\n\n    Help on function MS1annotation in module ipaPy2.ipa:\n    \n    MS1annotation(df, allAdds, ppm, me=0.000548579909065, ratiosd=0.9, ppmunk=None, ratiounk=None, ppmthr=None, pRTNone=None, pRTout=None, ncores=1)\n        Annotation of the dataset base on the MS1 information. Prior probabilities\n        are based on mass only, while post probabilities are based on mass, RT,\n        previous knowledge and isotope patterns.\n        \n        Parameters\n        ----------\n        df: pandas dataframe containing the MS1 data. It should be the output of the\n            function ipa.map_isotope_patterns()\n        allAdds: pandas dataframe containing the information on all the possible\n                adducts given the database. It should be the output of either\n                ipa.compute_all_adducts() or ipa.compute_all_adducts_Parallel()\n        ppm: accuracy of the MS instrument used\n        me: accurate mass of the electron. Default 5.48579909065e-04\n        ratiosd: default 0.9. It represents the acceptable ratio between predicted\n                 intensity and observed intensity of isotopes. It is used to compute\n                 the shape parameters of the lognormal distribution used to\n                 calculate the isotope pattern scores as sqrt(1/ratiosd)\n        ppmunk: ppm associated to the 'unknown' annotation. If not provided equal\n                to ppm.\n        ratiounk: isotope ratio associated to the 'unknown' annotation. If not\n                  provided equal to 0.5\n        ppmthr: Maximum ppm possible for the annotations. If not provided equal to\n                2*ppm\n        pRTNone: Multiplicative factor for the RT if no RTrange present in the\n                 database. If not provided equal to 0.8\n        pRTout: Multiplicative factor for the RT if measured RT is outside the\n                RTrange present in the database. If not provided equal to 0.4\n        ncores: default value 1. Number of cores used\n        \n        Returns\n        -------\n        annotations: a dictionary containing all the possible annotations for the\n                    measured features. The keys of the dictionary are the unique\n                    ids for the features present in df. For each feature, the\n                    annotations are summarized in a pandas dataframe.\n    \n\n\n\n```python\nannotations=ipa.MS1annotation(df,allAddsPos,ppm=3,ncores=1)\n```\n\n    annotating based on MS1 information....\n    0.4 seconds elapsed\n\n\nThis function returns all the possible annotations for all the mass spectrometry features (excluding the ones previously identified as isotopes). The annotations are provided in the form of a dictionary.  The keys of the dictionary are the unique ids for the features present in df.\nFor each feature, all possible annotations are summarised in a dataframe including the following information:\n\n- **id:** Unique id associated with the compound as reported in the database\n- **name:** Name of the compound\n- **formula:** Chemical formula of the putative annotation\n- **adduct:** Adduct type\n- **mz:** Theoretical m/z associated with the specific ion\n- **charge:** Theoretical charge of the ion\n- **RT range:** Retention time range reported in the database for the specific compound\n- **ppm:** mass accuracy\n- **isotope pattern score:** Score representing how similar the measured and theoretical isopattern scores are\n- **fragmentation pattern score:** Cosine similarity. Empty in this case as no MS<sup>2</sup> data was provided\n- **prior:** Probabilities associated with each possible annotation computed by only considering the mz values (i.e., only considering ppm)\n- **post:** Probabilities associated with each possible annotation computed by integrating all the additional information available: retention time range, ppm, isotope pattern score and prior knowledge.\n\nAs an example, possible annotations for the feature associated with id=1 (m/z=116.0705438, RT=45.77) is shown below:\n\n\n\n```python\nannotations[1]\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>name</th>\n      <th>formula</th>\n      <th>adduct</th>\n      <th>m/z</th>\n      <th>charge</th>\n      <th>RT range</th>\n      <th>ppm</th>\n      <th>isotope pattern score</th>\n      <th>fragmentation pattern score</th>\n      <th>prior</th>\n      <th>post</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C00148</td>\n      <td>L-Proline</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>35;55</td>\n      <td>-0.523247</td>\n      <td>0.331946</td>\n      <td>None</td>\n      <td>0.318084</td>\n      <td>0.454248</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>C00763</td>\n      <td>D-Proline</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>None</td>\n      <td>-0.523247</td>\n      <td>0.331946</td>\n      <td>None</td>\n      <td>0.318084</td>\n      <td>0.363398</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C18170</td>\n      <td>3-Acetamidopropanal</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>500;560</td>\n      <td>-0.523247</td>\n      <td>0.331946</td>\n      <td>None</td>\n      <td>0.318084</td>\n      <td>0.181699</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Unknown</td>\n      <td>Unknown</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>3.000000</td>\n      <td>0.004161</td>\n      <td>None</td>\n      <td>0.045748</td>\n      <td>0.000655</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nIt should be noticed that in this example, the prior probabilities associated with L-Proline M+H, D-Proline M+H and 3-Acetamidopropanal are exactly the same. This is because all three ions have exactly the same theoretical mass.\nHowever, the post probabilities are different. This is because the retention time associated with this feature is within the retention range reported in the database for L-Proline and outside the one reported for 3-Acetamidopropanal.\n\nAn expert in LC/MS-based mass spectrometry would argue that with most chromatographic columns stereoisomers such as L- and D-Proline would share the same RT range. While this is likely to be correct, it must be noted that the IPA method can only use the information present in the database. When populating it, we opted for a more agnostic approach and only included RT ranges for compounds that where actually detected as standards with our experimental setting. If the user wants to include the notion that \u2018stereoisomers share the same RT ranges\u2019, they should simply add this information in the database.\n\nHere another example:\n\n\n```python\nannotations[999]\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>name</th>\n      <th>formula</th>\n      <th>adduct</th>\n      <th>m/z</th>\n      <th>charge</th>\n      <th>RT range</th>\n      <th>ppm</th>\n      <th>isotope pattern score</th>\n      <th>fragmentation pattern score</th>\n      <th>prior</th>\n      <th>post</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C00079</td>\n      <td>L-Phenylalanine</td>\n      <td>C18H23N2O4</td>\n      <td>2M+H</td>\n      <td>331.165233</td>\n      <td>1</td>\n      <td>120;160</td>\n      <td>-0.941814</td>\n      <td>0.472049</td>\n      <td>None</td>\n      <td>0.240106</td>\n      <td>0.550778</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>C02265</td>\n      <td>D-Phenylalanine</td>\n      <td>C18H23N2O4</td>\n      <td>2M+H</td>\n      <td>331.165233</td>\n      <td>1</td>\n      <td>None</td>\n      <td>-0.941814</td>\n      <td>0.472049</td>\n      <td>None</td>\n      <td>0.240106</td>\n      <td>0.440622</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Unknown</td>\n      <td>Unknown</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>3.000000</td>\n      <td>0.055901</td>\n      <td>None</td>\n      <td>0.039575</td>\n      <td>0.0086</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>C03263</td>\n      <td>Coproporphyrinogen III</td>\n      <td>C36H46N4O8</td>\n      <td>M+2H</td>\n      <td>331.165233</td>\n      <td>2</td>\n      <td>None</td>\n      <td>-0.941814</td>\n      <td>0.0</td>\n      <td>None</td>\n      <td>0.240106</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>C05768</td>\n      <td>Coproporphyrinogen I</td>\n      <td>C36H46N4O8</td>\n      <td>M+2H</td>\n      <td>331.165233</td>\n      <td>2</td>\n      <td>None</td>\n      <td>-0.941814</td>\n      <td>0.0</td>\n      <td>None</td>\n      <td>0.240106</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nAlso in this case, all the prior probabilities associated with the four ions are exactly the same since all the ions have the same theoretical mass-to-charge ratio. However, the posterior probabilities are significantly different.\nTwo of these ions (Coproporphyrinogen III M+2H and Coproporphyrinogen I M+2H) have charge +2, while the other two possible annotations have charge +1. The observed isotope pattern is consistent with an ion with charge +1 (i.e., difference between isotopes = 1), and this is reflected in the isotope score pattern and consequently on the posterior probabilities. Moreover, the retention time associated with this feature is within the range reported for L-Phenylalanine in the database. Therefore, the posterior probability associated with L-Phenylalanine 2M+H is the most highest.\n\n**4. Annotation based on MS<sup>1</sup> and MS<sup>2</sup> information**\n\nAs already mentioned above, fragmentation data can be included in the annotation process by using the MSMSannotation() function. A detailed description of the function can be accessed through the help:\n\n\n```python\nhelp(ipa.MSMSannotation)\n```\n\n    Help on function MSMSannotation in module ipaPy2.ipa:\n    \n    MSMSannotation(df, dfMS2, allAdds, DBMS2, ppm, me=0.000548579909065, ratiosd=0.9, ppmunk=None, ratiounk=None, ppmthr=None, pRTNone=None, pRTout=None, mzdCS=0, ppmCS=10, CSunk=0.7, evfilt=False, ncores=1)\n        Annotation of the dataset base on the MS1 and MS2 information. Prior\n        probabilities are based on mass only, while post probabilities are based\n        on mass, RT, previous knowledge and isotope patterns.\n        \n        Parameters\n        ----------\n        df: pandas dataframe containing the MS1 data. It should be the output of the\n            function ipa.map_isotope_patterns()\n        dfMS2: pandas dataframe containing the MS2 data. It must contain 3 columns\n            -id: an unique id for each feature for which the MS2 spectrum was\n                 acquired (same as in df)\n            -spectrum: string containing the spectrum information in the following\n                       format 'mz1:Int1 mz2:Int2 mz3:Int3 ...'\n            -ev: collision energy used to acquire the fragmentation spectrum\n        allAdds: pandas dataframe containing the information on all the possible\n                adducts given the database. It should be the output of either\n                ipa.compute_all_adducts() or ipa.compute_all_adducts_Parallel()\n        DBMS2: pandas dataframe containing the database containing the MS2\n               information\n        ppm: accuracy of the MS instrument used\n        me: accurate mass of the electron. Default 5.48579909065e-04\n        ratiosd: default 0.9. It represents the acceptable ratio between predicted\n                intensity and observed intensity of isotopes. it is used to compute\n                the shape parameters of the lognormal distribution used to\n                calculate the isotope pattern scores as sqrt(1/ratiosd)\n        ppmunk: ppm associated to the 'unknown' annotation. If not provided equal\n                to ppm.\n        ratiounk: isotope ratio associated to the 'unknown' annotation. If not\n                  provided equal to 0.5\n        ppmthr: Maximum ppm possible for the annotations. Ff not provided equal to\n                2*ppm\n        pRTNone: Multiplicative factor for the RT if no RTrange present in the\n                database. If not provided equal to 0.8\n        pRTout: Multiplicative factor for the RT if measured RT is outside the\n                RTrange present in the database. If not provided equal to 0.4\n        mzdCS: maximum mz difference allowed when computing cosine similarity\n               scores. If one wants to use this parameter instead of ppmCS, this\n               must be set to 0. Default 0.\n        ppmCS: maximum ppm allowed when computing cosine similarity scores.\n               If one wants to use this parameter instead of mzdCS, this must be\n               set to 0. Default 10.\n        CSunk: cosine similarity score associated with the 'unknown' annotation.\n                Default 0.7\n        evfilt: Default value False. If true, only spectrum acquired with the same\n                collision energy are considered.\n        ncores: default value 1. Number of cores used\n        \n        Returns\n        -------\n        annotations: a dictionary containing all the possible annotations for the\n                     measured features. The keys of the dictionary are the unique\n                     ids for the features present in df. For each feature, the\n                     annotations are summarized in a pandas dataframe.\n    \n\n\nThe line below integrates the fragmentation data and the fragmentation database introduced above in the annotation process. The role of the CSunk (\u201ccosine unknown\u201d) parameter should be briefly discussed here. In most cases, the fragmentation database contains fragmentation spectra only for a subset of the compounds in the database. Therefore, when considering a feature for which the fragmentation spectra was acquired, it is often the case that the cosine similarity can only be computed for a subset of the possible annotations. The CSunk value is then assigned to the other possible annotations for comparison.\n\n\n```python\n annotations=ipa.MSMSannotation(df,dfMS2,allAddsPos,DBMS2,CSunk=0.7,ppm=3,ncores=1)\n```\n\n    annotating based on MS1 and MS2 information....\n    0.7 seconds elapsed\n\n\nThe output of this function has the same structure as the one from the MSannotation() function, but it also includes the fragmentation pattern scores when the fragmentation data is available.\nAs an example, possible annotations for the feature associated with id=1 is shown below:\n\n\n```python\nannotations[1]\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>name</th>\n      <th>formula</th>\n      <th>adduct</th>\n      <th>m/z</th>\n      <th>charge</th>\n      <th>RT range</th>\n      <th>ppm</th>\n      <th>isotope pattern score</th>\n      <th>fragmentation pattern score</th>\n      <th>prior</th>\n      <th>post</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C00148</td>\n      <td>L-Proline</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>35;55</td>\n      <td>-0.523247</td>\n      <td>0.331946</td>\n      <td>0.999759</td>\n      <td>0.318084</td>\n      <td>0.543121</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>C00763</td>\n      <td>D-Proline</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>None</td>\n      <td>-0.523247</td>\n      <td>0.331946</td>\n      <td>0.7</td>\n      <td>0.318084</td>\n      <td>0.304221</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C18170</td>\n      <td>3-Acetamidopropanal</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>500;560</td>\n      <td>-0.523247</td>\n      <td>0.331946</td>\n      <td>0.7</td>\n      <td>0.318084</td>\n      <td>0.15211</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Unknown</td>\n      <td>Unknown</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>3.000000</td>\n      <td>0.004161</td>\n      <td>0.7</td>\n      <td>0.045748</td>\n      <td>0.000548</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nIn this case, the cosine similarity score for the annotation L-Proline M+H is very high, therefore the posterior probability associated with it is higher than the one obtained without considering the MS<sup>2</sup> data.\n\nHere another example for a feature having a very similar mass-to-charge ratio (id=90, m/z=117.0705223, RT=63.45).\n\n\n```python\nannotations[90]\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>name</th>\n      <th>formula</th>\n      <th>adduct</th>\n      <th>m/z</th>\n      <th>charge</th>\n      <th>RT range</th>\n      <th>ppm</th>\n      <th>isotope pattern score</th>\n      <th>fragmentation pattern score</th>\n      <th>prior</th>\n      <th>post</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C00763</td>\n      <td>D-Proline</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>None</td>\n      <td>-0.708479</td>\n      <td>None</td>\n      <td>0.7</td>\n      <td>0.317329</td>\n      <td>0.480821</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>C18170</td>\n      <td>3-Acetamidopropanal</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>500;560</td>\n      <td>-0.708479</td>\n      <td>None</td>\n      <td>0.7</td>\n      <td>0.317329</td>\n      <td>0.24041</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C00148</td>\n      <td>L-Proline</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>35;55</td>\n      <td>-0.708479</td>\n      <td>None</td>\n      <td>0.59986</td>\n      <td>0.317329</td>\n      <td>0.206018</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Unknown</td>\n      <td>Unknown</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>3.000000</td>\n      <td>None</td>\n      <td>0.7</td>\n      <td>0.048013</td>\n      <td>0.072751</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nIn this case, the cosine similarity score for the annotation L-Proline M+H is not very high. Moreover, the retention time assigned to this feature is outside both retention time ranges reported in the database for L-Proline and 3-Acetamidopropanal. Therefore, the most likely annotation for this feature is D-Proline M+H, the one annotation not rejected directly by the available evidence.\nIt should be noted that the fragmentation pattern score has a rather weak effect on the posterior probability associated with L-Proline, given how close it is to the fragmentation pattern score associated features that do not have MS<sup>2</sup> info in the database (CSunk=0.7). The main reason why the D-Proline annotation appears to be the most likely is due to the fact that the retention time associated to this feature (63.45 s) is outside the retention time ranges associated with L-Proline and 3-Acetamidopropanal.\n\n**5. Computing posterior probabilities integrating adducts connections**\n\nUntil this point, the putative annotations and the associated probabilities computed for each feature are independent from each other. However, the IPA method can be used to update the probabilities by considering the possible relationship between annotations.\nFor example, the Gibbs_sampler_add() function uses a Gibbs sampler to estimate the posterior probabilities obtained by considering all possible adduct connections.\n\nThe help() provides a detailed description of this function:\n\n\n```python\nhelp(ipa.Gibbs_sampler_add)\n```\n\n    Help on function Gibbs_sampler_add in module ipaPy2.ipa:\n    \n    Gibbs_sampler_add(df, annotations, noits=100, burn=None, delta_add=1, all_out=False, zs=None)\n        Gibbs sampler considering only adduct connections. The function computes\n        the posterior probabilities of the annotations considering the adducts\n        connections.\n        \n        Parameters\n        ----------\n        df: pandas dataframe containing the MS1 data. It should be the output of the\n            function ipa.map_isotope_patterns()\n        annotations: a dictionary containing all the possible annotations for the\n                    measured features. The keys of the dictionary are the unique\n                    ids for the features present in df. For each feature, the\n                    annotations are summarized in a pandas dataframe. Output of\n                    functions MS1annotation(), MS1annotation_Parallel(),\n                    MSMSannotation() or MSMSannotation_Parallel\n        noits: number of iterations if the Gibbs sampler to be run\n        burn: number of iterations to be ignored when computing posterior\n              probabilities. If None, is set to 10% of total iterations\n        delta_add: parameter used when computing the conditional priors. The\n                   parameter must be positive. The smaller the parameter the more\n                   weight the adducts connections have on the posterior\n                   probabilities. Default 1.\n        all_out: logical value. If true the list of assignments found in each\n                 iteration is returned by the function. Default False.\n        zs: list of assignments computed in a previous run of the Gibbs sampler. \n            Optional, default None.\n        \n        Returns\n        -------\n        annotations: the function modifies the annotations dictionary by adding 2\n                     columns to each entry. One named 'post Gibbs' contains the\n                     posterior probabilities computed. The other is called\n                     'chi-square pval' containing the p-value from a chi-squared\n                     test comparing the 'post' with the 'post Gibbs' probabilities.\n        zs: optional, if all_out==True, the function return the full list of\n            assignments computed. This allows restarting the sampler from where\n            you are from a previous run.\n    \n\n\n\n```python\nzs = ipa.Gibbs_sampler_add(df,annotations,noits=1000,delta_add=0.1, all_out=True)\n```\n\n    computing posterior probabilities including adducts connections\n    initialising sampler ...\n\n\n    Gibbs Sampler Progress Bar: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03<00:00, 258.48it/s]\n\n    parsing results ...\n    Done -  3.9 seconds elapsed\n\n\n    \n\n\nThe function modifies the annotations dictionary by adding two additional columns to each dataframe:\n- **post Gibbs:** posterior probabilities obtained from the Gibbs sampler.\n- **chi-square pval:** In order to see if the posterior probabilities obtained are statistically different from the priors, a chi-square test is used. The obtained p-value is reported in this coloumn.\n\nIf all_out=True, the function also returns the full list of assignments computed. If provided as an input to the Gibbs sampler, it allows to restart it from where you finished.\n\n\n```python\nipa.Gibbs_sampler_add(df,annotations, noits=4000,delta_add=0.1,zs=zs)\n```\n\n    computing posterior probabilities including adducts connections\n    initialising sampler ...\n\n\n    Gibbs Sampler Progress Bar: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4000/4000 [00:15<00:00, 261.29it/s]\n\n    parsing results ...\n    Done -  15.4 seconds elapsed\n\n\n    \n\n\nAs an example, the possible annotations for the feature associated with the id 501 is shown below.\n\n\n```python\nannotations[501]\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>name</th>\n      <th>formula</th>\n      <th>adduct</th>\n      <th>m/z</th>\n      <th>charge</th>\n      <th>RT range</th>\n      <th>ppm</th>\n      <th>isotope pattern score</th>\n      <th>fragmentation pattern score</th>\n      <th>prior</th>\n      <th>post</th>\n      <th>post Gibbs</th>\n      <th>chi-square pval</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C00148</td>\n      <td>L-Proline</td>\n      <td>C10H19N2O4</td>\n      <td>2M+H</td>\n      <td>231.133933</td>\n      <td>1</td>\n      <td>35;55</td>\n      <td>-1.124747</td>\n      <td>0.328045</td>\n      <td>None</td>\n      <td>0.314538</td>\n      <td>0.453117</td>\n      <td>0.662075</td>\n      <td>4.087367e-186</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>C00763</td>\n      <td>D-Proline</td>\n      <td>C10H19N2O4</td>\n      <td>2M+H</td>\n      <td>231.133933</td>\n      <td>1</td>\n      <td>None</td>\n      <td>-1.124747</td>\n      <td>0.328045</td>\n      <td>None</td>\n      <td>0.314538</td>\n      <td>0.362494</td>\n      <td>0.266163</td>\n      <td>4.087367e-186</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C18170</td>\n      <td>3-Acetamidopropanal</td>\n      <td>C10H19N2O4</td>\n      <td>2M+H</td>\n      <td>231.133933</td>\n      <td>1</td>\n      <td>500;560</td>\n      <td>-1.124747</td>\n      <td>0.328045</td>\n      <td>None</td>\n      <td>0.314538</td>\n      <td>0.181247</td>\n      <td>0.071540</td>\n      <td>4.087367e-186</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Unknown</td>\n      <td>Unknown</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>3.000000</td>\n      <td>0.015864</td>\n      <td>None</td>\n      <td>0.056386</td>\n      <td>0.003143</td>\n      <td>0.000222</td>\n      <td>4.087367e-186</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nThis feature is clustered with feature id=1, the most likely annotation of which is L-Proline M+H. As expected, considering the adducts connections the 'post Gibbs' probability associated with L-Proline 2M+H is significantly higher than the alternative.\n\n**6. Computing posterior probabilities integrating biochemical connections**\n\nThe IPA method can also update the probabilities associated to each possible annotations by considering all possible biochemical connections.\n\nBefore doing so, it is necessary to provide a pandas dataframe reporting which compounds can be considered biochemically related.\nThe function Compute_Bio() can be used to compute such a dataframe.\nThe help() provides a detailed description of this function:\n\n\n```python\nhelp(ipa.Compute_Bio)\n```\n\n    Help on function Compute_Bio in module ipaPy2.ipa:\n    \n    Compute_Bio(DB, annotations=None, mode='reactions', connections=['C3H5NO', 'C6H12N4O', 'C4H6N2O2', 'C4H5NO3', 'C3H5NOS', 'C6H10N2O3S2', 'C5H7NO3', 'C5H8N2O2', 'C2H3NO', 'C6H7N3O', 'C6H11NO', 'C6H11NO', 'C6H12N2O', 'C5H9NOS', 'C9H9NO', 'C5H7NO', 'C3H5NO2', 'C4H7NO2', 'C11H10N2O', 'C9H9NO2', 'C5H9NO', 'C4H4O2', 'C3H5O', 'C10H12N5O6P', 'C10H15N2O3S', 'C10H14N2O2S', 'CH2ON', 'C21H34N7O16P3S', 'C21H33N7O15P3S', 'C10H15N3O5S', 'C5H7', 'C3H2O3', 'C16H30O', 'C8H8NO5P', 'CH3N2O', 'C5H4N5', 'C10H11N5O3', 'C10H13N5O9P2', 'C10H12N5O6P', 'C9H13N3O10P2', 'C9H12N3O7P', 'C4H4N3O', 'C10H13N5O10P2', 'C10H12N5O7P', 'C5H4N5O', 'C10H11N5O4', 'C10H14N2O10P2', 'C10H12N2O4', 'C5H5N2O2', 'C10H13N2O7P', 'C9H12N2O11P2', 'C9H11N2O8P', 'C4H3N2O2', 'C9H10N2O5', 'C2H3O2', 'C2H2O', 'C2H2', 'CO2', 'CHO2', 'H2O', 'H3O6P2', 'C2H4', 'CO', 'C2O2', 'H2', 'O', 'P', 'C2H2O', 'CH2', 'HPO3', 'NH2', 'PP', 'NH', 'SO3', 'N', 'C6H10O5', 'C6H10O6', 'C5H8O4', 'C12H20O11', 'C6H11O8P', 'C6H8O6', 'C6H10O5', 'C18H30O15'], ncores=1)\n        Compute matrix of biochemical connections. Either based on a list of\n        possible connections in the form of a list of formulas or based on the\n        reactions present in the database.\n        \n        Parameters\n        ----------\n        DB: pandas dataframe containing the database against which the annotation\n            is performed. The DB must contain the following columns in this exact\n            order (optional fields can contain None):\n            - id: unique id of the database entry (e.g., 'C00031') - necessary\n            - name: compound name (e.g., 'D-Glucose') - necessary\n            - formula: chemical formula (e.g., 'C6H12O6') - necessary\n            - inchi: inchi string - optional\n            - smiles: smiles string - optional\n            - RT: if known, retention time range (in seconds) where this compound\n                    is expected to elute (e.g., '30;60') - optional\n            - adductsPos: list of adducts that should be considered in positive mode\n                          for this entry (e.g.,'M+Na;M+H;M+') - necessary\n            - adductsNeg: list of adducts that should be considered in negative\n                          mode for this entry (e.g.,'M-H;M-2H') - necessary\n            - description: comments on the entry - optional\n            - pk: previous knowledge on the likelihood of this compound to be\n                 present in the sample analyse. The value has to be between 1\n                 (compound likely to be present in the sample) and 0 (compound\n                 cannot be present in the sample).\n            - MS2: id for the MS2 database entries related to this compound\n                   (optional)\n            - reactions: list of reactions ids involving this compound\n                        (e.g., 'R00010 R00015 R00028')-optional, but necessary if \n                        mode='reactions'.\n        annotations: If equal to None (default) all entries in the DB are considered \n                    (used to pre-compute the Bio matrix), alternatively it should be\n                    a dictionary containing all the possible annotations for the\n                    measured features. The keys of the dictionary are the unique ids\n                    for the features present in df. For each feature, the\n                    annotations are summarized in a pandas dataframe. Output of\n                    functions MS1annotation(), MS1annotation_Parallel(),\n                    MSMSannotation() or MSMSannotation_Parallel. In this case\n                    only the entries currently considered as possible annotations\n                    are used.\n        mode: either 'reactions' (connections are computed based on the reactions\n              present in the database) or 'connections' (connections are computed\n              based on the list of connections provided). Default 'reactions'.\n        connections: list of possible connections between compounds defined as\n                    formulas. Only necessary if mode='connections'. A list of\n                    common biotransformations is provided as default.\n        ncores: default value 1. Number of cores used\n        \n        Returns\n        -------\n            Bio: dataframe containing all the possible connections computed.\n    \n\n\nAccording to the value assigned to the 'mode' parameter, the function can compute all possible biochemical connections in two ways.\nIf mode='reactions', the function connects the compounds that share the same reaction id(s) according to what is reported in the database.\n\n\n```python\nBio = ipa.Compute_Bio(DB,annotations,mode='reactions')\nBio\n```\n\n    computing all possible biochemical connections\n    considering the reactions stored in the database ...\n    0.0 seconds elapsed\n\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C00082</td>\n      <td>C00079</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>C00082</td>\n      <td>C04368</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C21092</td>\n      <td>C00407</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>C02265</td>\n      <td>C00079</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>C00123</td>\n      <td>C02486</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>C00763</td>\n      <td>C00431</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>C00079</td>\n      <td>C20807</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>C00407</td>\n      <td>C00183</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nIf mode='connections', the function computes the 'chemical formula difference' for each pair of compounds considered. If the difference is included in the list of connections, the two compounds are considered connected.\nA list of connections is provided as default, but it can be modified.\n\n\n```python\nBio = ipa.Compute_Bio(DB,annotations,mode='connections')\nBio\n```\n\n    computing all possible biochemical connections\n    considering the provided connections ...\n    3.1 seconds elapsed\n\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C04282</td>\n      <td>C05131</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>C04282</td>\n      <td>C22140</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C04282</td>\n      <td>C16744</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>C01879</td>\n      <td>C05131</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>C01879</td>\n      <td>C22140</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>C01879</td>\n      <td>C16744</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>C01877</td>\n      <td>C05131</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>C01877</td>\n      <td>C22140</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>C01877</td>\n      <td>C16744</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>C05131</td>\n      <td>C02237</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>C05131</td>\n      <td>C04281</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>C05131</td>\n      <td>C22141</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>C02237</td>\n      <td>C22140</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>C02237</td>\n      <td>C16744</td>\n    </tr>\n    <tr>\n      <th>14</th>\n      <td>C22140</td>\n      <td>C04281</td>\n    </tr>\n    <tr>\n      <th>15</th>\n      <td>C22140</td>\n      <td>C22141</td>\n    </tr>\n    <tr>\n      <th>16</th>\n      <td>C16744</td>\n      <td>C04281</td>\n    </tr>\n    <tr>\n      <th>17</th>\n      <td>C16744</td>\n      <td>C22141</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nDepending on the size of the database and the dataset, computing all possible biochemical connections can be extremely computationally demanding and can drastically increase the computation time needed for the annotation. For this reason, a precomputed list of biochemical connections based on the database provided (computed based on 'reaction' or 'connections' mode) is included in the library and can be used directly without the need of computing the biochemical connections.\n\n\n```python\nBio = pd.read_csv('DB/allBIO_reactions.csv')\n```\n\nThe list of connections computed with mode='connections' needs to be unzipped first.\n\n\n```python\nimport zipfile\nwith zipfile.ZipFile(\"DB/allBio_connections.csv.zip\",\"r\") as zip_ref:\n    zip_ref.extractall(\"DB/\")\n\nBio=pd.read_csv('DB/allBio_connections.csv')\n\n```\n\nAlternatively, the user can define their own biochemical connections.\nFor example:\nL-Proline C00148\nL-Valine C00183\nL-Phenylalanine C00079\nL-Leucine C00123\n5-Oxoproline C01879\nBetaine C00719\nHordatine A C08307\nL-Tyrosine C00082\nD-Proline C00763\nD-Phenylalanine C02265\n\n\n\n\n\n```python\nBio=pd.DataFrame([['C00148','C00763'],\n                  ['C00079','C02265'],\n                  ['C08307','C00082'],\n                  ['C08307','C00079']])\n```\n\n\n```python\nipa.Gibbs_sampler_bio(df,annotations,Bio,noits=5000,delta_bio=0.1)\n```\n\n    computing posterior probabilities including biochemical connections\n    initialising sampler ...\n\n\n    Gibbs Sampler Progress Bar: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:23<00:00, 217.12it/s]\n\n\n    parsing results ...\n    Done -  23.1 seconds elapsed\n\n\nAs an example, the possible annotations for the feature associated with the id 992 is shown below.\n\n\n```python\nannotations[992]\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>name</th>\n      <th>formula</th>\n      <th>adduct</th>\n      <th>m/z</th>\n      <th>charge</th>\n      <th>RT range</th>\n      <th>ppm</th>\n      <th>isotope pattern score</th>\n      <th>fragmentation pattern score</th>\n      <th>prior</th>\n      <th>post</th>\n      <th>post Gibbs</th>\n      <th>chi-square pval</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C00763</td>\n      <td>D-Proline</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>None</td>\n      <td>-0.65851</td>\n      <td>None</td>\n      <td>0.7</td>\n      <td>0.317559</td>\n      <td>0.531683</td>\n      <td>0.770667</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C00148</td>\n      <td>L-Proline</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>35;55</td>\n      <td>-0.65851</td>\n      <td>None</td>\n      <td>0.324512</td>\n      <td>0.317559</td>\n      <td>0.123241</td>\n      <td>0.180889</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>C18170</td>\n      <td>3-Acetamidopropanal</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>500;560</td>\n      <td>-0.65851</td>\n      <td>None</td>\n      <td>0.7</td>\n      <td>0.317559</td>\n      <td>0.265841</td>\n      <td>0.035556</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Unknown</td>\n      <td>Unknown</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>3.00000</td>\n      <td>None</td>\n      <td>0.7</td>\n      <td>0.047324</td>\n      <td>0.079234</td>\n      <td>0.012889</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\nThe probability associated with the D-Proline M+H is significantly higher after considering the biochemical connections. This is because D-Proline is biochemically connected to L-Proline (by proline racemase), and the most likely annotation for the feature id=1 is L-Proline M+H (>50%).\n\n**7. Computing posterior probabilities integrating both adducts and biochemical connections**\n\nIt is also possible to run the Gibbs sampler considering biochemical and adduct connections at the same time.\nTo do so, one can use the function Gibbs_sampler_bio_add().\nThe help() provides a detailed explanation of the function. \n\n\n```python\nhelp(ipa.Gibbs_sampler_bio_add)\n```\n\n    Help on function Gibbs_sampler_bio_add in module ipaPy2.ipa:\n    \n    Gibbs_sampler_bio_add(df, annotations, Bio, noits=100, burn=None, delta_bio=1, delta_add=1, all_out=False, zs=None)\n        Gibbs sampler considering both biochemical and adducts connections. The\n        function computes the posterior probabilities of the annotations\n        considering the possible biochemical connections reported in Bio and the\n        possible adducts connection.\n        \n        Parameters\n        ----------\n        df: pandas dataframe containing the MS1 data. It should be the output of the\n            function ipa.map_isotope_patterns()\n        annotations: a dictionary containing all the possible annotations for the\n                     measured features. The keys of the dictionary are the unique\n                     ids for the features present in df. For each feature, the\n                     annotations are summarized in a pandas dataframe. Output of\n                     functions MS1annotation(), MS1annotation_Parallel(),\n                     MSMSannotation() or MSMSannotation_Parallel\n        Bio: dataframe (2 columns), reporting all the possible connections between\n             compounds. It uses the unique ids from the database. It could be the\n             output of Compute_Bio() or Compute_Bio_Parallel().\n        noits: number of iterations if the Gibbs sampler to be run\n        burn: number of iterations to be ignored when computing posterior\n              probabilities. If None, is set to 10% of total iterations\n        delta_bio: parameter used when computing the conditional priors.\n                   The parameter must be positive. The smaller the parameter the\n                   more weight the adducts connections have on the posterior\n                   probabilities. Default 1.\n        delta_add: parameter used when computing the conditional priors. The\n                   parameter must be positive. The smaller the parameter the more\n                   weight the adducts connections have on the posterior\n                   probabilities. Default 1.\n        all_out: logical value. If true the list of assignments found in each\n                iteration is returned by the function. Default False.\n        zs: list of assignments computed in a previous run of the Gibbs sampler.\n            Optional, default None.\n        \n        Returns\n        -------\n        annotations: the function modifies the annotations dictionary by adding 2\n                    columns to each entry. One named 'post Gibbs' contains the\n                    posterior probabilities computed. The other is called\n                    'chi-square pval' containing the p-value from a chi-squared\n                    test comparing the 'post' with the 'post Gibbs' probabilities.\n        zs: optional, if all_out==True, the function return the full list of\n            assignments computed. This allows restarting the sampler from where you\n            are from a previous run\n    \n\n\n\n```python\nipa.Gibbs_sampler_bio_add(df,annotations,Bio,noits=5000,delta_bio=0.1,delta_add=0.1)\n```\n\n    computing posterior probabilities including biochemical and adducts connections\n    initialising sampler ...\n\n\n    Gibbs Sampler Progress Bar: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:24<00:00, 204.74it/s]\n\n\n    parsing results ...\n    Done -  24.5 seconds elapsed\n\n\n\n```python\nannotations[1]\n```\n\n\n\n\n<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>name</th>\n      <th>formula</th>\n      <th>adduct</th>\n      <th>m/z</th>\n      <th>charge</th>\n      <th>RT range</th>\n      <th>ppm</th>\n      <th>isotope pattern score</th>\n      <th>fragmentation pattern score</th>\n      <th>prior</th>\n      <th>post</th>\n      <th>post Gibbs</th>\n      <th>chi-square pval</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C00148</td>\n      <td>L-Proline</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>35;55</td>\n      <td>-0.523247</td>\n      <td>0.331946</td>\n      <td>0.999759</td>\n      <td>0.318084</td>\n      <td>0.543121</td>\n      <td>0.783111</td>\n      <td>1.468730e-271</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>C00763</td>\n      <td>D-Proline</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>None</td>\n      <td>-0.523247</td>\n      <td>0.331946</td>\n      <td>0.7</td>\n      <td>0.318084</td>\n      <td>0.304221</td>\n      <td>0.212444</td>\n      <td>1.468730e-271</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C18170</td>\n      <td>3-Acetamidopropanal</td>\n      <td>C5H10NO2</td>\n      <td>M+H</td>\n      <td>116.070605</td>\n      <td>1</td>\n      <td>500;560</td>\n      <td>-0.523247</td>\n      <td>0.331946</td>\n      <td>0.7</td>\n      <td>0.318084</td>\n      <td>0.15211</td>\n      <td>0.004444</td>\n      <td>1.468730e-271</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Unknown</td>\n      <td>Unknown</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>3.000000</td>\n      <td>0.004161</td>\n      <td>0.7</td>\n      <td>0.045748</td>\n      <td>0.000548</td>\n      <td>0.000000</td>\n      <td>1.468730e-271</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n\n\n**8. Running the whole pipeline with a single function**\n\nFinally, the ipaPy2 library also include a wrapper function that allows running the whole IPA pipeline in one step.\nA detailed description of the function can be accessed with the help.\n\n\n```python\nhelp(ipa.simpleIPA)\n```\n\n    Help on function simpleIPA in module ipaPy2.ipa:\n    \n    simpleIPA(df, ionisation, DB, adductsAll, ppm, dfMS2=None, DBMS2=None, noits=100, burn=None, delta_add=None, delta_bio=None, Bio=None, mode='reactions', CSunk=0.5, isodiff=1, ppmiso=100, ncores=1, me=0.000548579909065, ratiosd=0.9, ppmunk=None, ratiounk=None, ppmthr=None, pRTNone=None, pRTout=None, mzdCS=0, ppmCS=10, evfilt=False, connections=['C3H5NO', 'C6H12N4O', 'C4H6N2O2', 'C4H5NO3', 'C3H5NOS', 'C6H10N2O3S2', 'C5H7NO3', 'C5H8N2O2', 'C2H3NO', 'C6H7N3O', 'C6H11NO', 'C6H11NO', 'C6H12N2O', 'C5H9NOS', 'C9H9NO', 'C5H7NO', 'C3H5NO2', 'C4H7NO2', 'C11H10N2O', 'C9H9NO2', 'C5H9NO', 'C4H4O2', 'C3H5O', 'C10H12N5O6P', 'C10H15N2O3S', 'C10H14N2O2S', 'CH2ON', 'C21H34N7O16P3S', 'C21H33N7O15P3S', 'C10H15N3O5S', 'C5H7', 'C3H2O3', 'C16H30O', 'C8H8NO5P', 'CH3N2O', 'C5H4N5', 'C10H11N5O3', 'C10H13N5O9P2', 'C10H12N5O6P', 'C9H13N3O10P2', 'C9H12N3O7P', 'C4H4N3O', 'C10H13N5O10P2', 'C10H12N5O7P', 'C5H4N5O', 'C10H11N5O4', 'C10H14N2O10P2', 'C10H12N2O4', 'C5H5N2O2', 'C10H13N2O7P', 'C9H12N2O11P2', 'C9H11N2O8P', 'C4H3N2O2', 'C9H10N2O5', 'C2H3O2', 'C2H2O', 'C2H2', 'CO2', 'CHO2', 'H2O', 'H3O6P2', 'C2H4', 'CO', 'C2O2', 'H2', 'O', 'P', 'C2H2O', 'CH2', 'HPO3', 'NH2', 'PP', 'NH', 'SO3', 'N', 'C6H10O5', 'C6H10O6', 'C5H8O4', 'C12H20O11', 'C6H11O8P', 'C6H8O6', 'C6H10O5', 'C18H30O15'])\n         Wrapper function performing the whole IPA pipeline.\n         \n         Parameters\n         ----------\n         df: pandas dataframe containing the MS1 data. It should be the output of the\n             function ipa.map_isotope_patterns()\n             \n         DB: pandas dataframe containing the database against which the annotation\n             is performed. The DB must contain the following columns in this exact\n             order (optional fields can contain None):\n             - id: unique id of the database entry (e.g., 'C00031') - necessary\n             - name: compound name (e.g., 'D-Glucose') - necessary\n             - formula: chemical formula (e.g., 'C6H12O6') - necessary\n             - inchi: inchi string - optional\n             - smiles: smiles string - optional\n             - RT: if known, retention time range (in seconds) where this compound\n                     is expected to elute (e.g., '30;60') - optional\n             - adductsPos: list of adducts that should be considered in positive mode\n                           for this entry (e.g.,'M+Na;M+H;M+') - necessary\n             - adductsNeg: list of adducts that should be considered in negative\n                           mode for this entry (e.g.,'M-H;M-2H') - necessary\n             - description: comments on the entry - optional\n             - pk: previous knowledge on the likelihood of this compound to be\n                  present in the sample analyse. The value has to be between 1\n                  (compound likely to be present in the sample) and 0 (compound\n                  cannot be present in the sample).\n             - MS2: id for the MS2 database entries related to this compound\n                    (optional)\n             - reactions: list of reactions ids involving this compound\n                         (e.g., 'R00010 R00015 R00028')-optional, but necessary if \n                         mode='reactions'.\n         adductsAll:a dataframe containing information on all possible adducts.              1\n         ppm: accuracy of the MS instrument used\n         dfMS2: pandas dataframe containing the MS2 data (optional). It must contain\n                3 columns:\n                        -id: an unique id for each feature for which the MS2 spectrum\n                            was acquired (same as in df)\n                        -spectrum: string containing the spectrum inforamtion in the\n                                   following format 'mz1:Int1 mz2:Int2 mz3:Int3 ...'\n                        -ev: collision energy used to aquire the fragmentation\n                            spectrum\n         DBMS2: pandas dataframe containing the database containing the MS2\n                information (optional)\n         evfilt: Default value False. If true, only spectra acquired with the same\n                 collision energy are considered.\n         noits: number of iterations if the Gibbs sampler to be run\n         burn: number of iterations to be ignored when computing posterior\n               probabilities. If None, is set to 10% of total iterations\n         delta_bio: parameter used when computing the conditional priors.\n                    The parameter must be positive. The smaller the parameter the\n                    more weight the adducts connections have on the posterior\n                    probabilities. Default 1.\n         delta_add: parameter used when computing the conditional priors. The\n                    parameter must be positive. The smaller the parameter the more\n                    weight the adducts connections have on the posterior\n                    probabilities. Default 1.\n         Bio: dataframe (2 columns), reporting all the possible connections between\n              compounds. It uses the unique ids from the database. It could be the\n              output of Compute_Bio() or Compute_Bio_Parallel().\n         mode: either 'reactions' (connections are computed based on the reactions\n               present in the database) or 'connections' (connections are computed\n               based on the list of connections provided). Default 'reactions'.\n        CSunk: cosine similarity score associated with the 'unknown' annotation.\n                Default 0.7    \n        isoDiff: Default value 1. Difference between isotopes of charge 1, does not\n                 need to be exact\n         ppmiso: Default value 100. Maximum ppm value allowed between 2 isotopes.\n                 It is very high on purpose\n         ncores: default value 1. Number of cores used\n         \n        \n         me: accurate mass of the electron. Default 5.48579909065e-04\n         ratiosd: default 0.9. It represents the acceptable ratio between predicted\n                 intensity and observed intensity of isotopes. it is used to compute\n                 the shape parameters of the lognormal distribution used to\n                 calculate the isotope pattern scores as sqrt(1/ratiosd)\n         ppmunk: ppm associated to the 'unknown' annotation. If not provided equal\n                 to ppm.\n         ratiounk: isotope ratio associated to the 'unknown' annotation. If not\n                   provided equal to 0.5\n         ppmthr: Maximum ppm possible for the annotations. Ff not provided equal to\n                 2*ppm\n         pRTNone: Multiplicative factor for the RT if no RTrange present in the\n                 database. If not provided equal to 0.8\n         pRTout: Multiplicative factor for the RT if measured RT is outside the\n                 RTrange present in the database. If not provided equal to 0.4\n         mzdCS: maximum mz difference allowed when computing cosine similarity\n                scores. If one wants to use this parameter instead of ppmCS, this\n                must be set to 0. Default 0.\n         ppmCS: maximum ppm allowed when computing cosine similarity scores.\n                If one wants to use this parameter instead of mzdCS, this must be\n                set to 0. Default 10.\n         connections: list of possible connections between compounds defined as\n                     formulas. Only necessary if mode='connections'. A list of\n                     common biotransformations is provided as default.\n         Output:\n             annotations: a dictionary containing all the possible annotations for the measured features. The keys of the dictionary are the\n                          unique ids for the features present in df. For each feature, the annotations are summarized in a pandas dataframe.\n    \n\n\nBased on the parameters passed on to the function, the end-result of this function will be different.\n\nFor example, if one wants to use both the MS<sup>1</sup> and MS<sup>2</sup> data and not use the Gibbs sampler, the following should be used:\n\n\n```python\nannotations= ipa.simpleIPA(df,ionisation=1, DB=DB,adductsAll=adducts,ppm=3,dfMS2=dfMS2,DBMS2=DBMS2)\n```\n\n    isotopes already mapped\n    computing all adducts ....\n    0.1 seconds elapsed\n    annotating based on MS1 and MS2 information....\n    0.8 seconds elapsed\n\n\nIf instead one wants to use only the MS<sup>1</sup> data and only consider the adducts connections in the Gibbs sampler, one should use the following:\n\n\n```python\nannotations= ipa.simpleIPA(df,ionisation=1, DB=DB,adductsAll=adducts,ppm=3,noits=5000,delta_add=0.1)\n```\n\n    isotopes already mapped\n    computing all adducts ....\n    0.1 seconds elapsed\n    annotating based on MS1 information....\n    0.4 seconds elapsed\n    computing posterior probabilities including adducts connections\n    initialising sampler ...\n\n\n    Gibbs Sampler Progress Bar: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:19<00:00, 255.13it/s]\n\n    parsing results ...\n    Done -  19.7 seconds elapsed\n\n\n    \n\n\nOr, if one wants to use both the MS<sup>1</sup> and MS<sup>2</sup> data and consider both adducts and biochemical connections in the Gibbs sampler, the following should be used.\n\n\n```python\nannotations= ipa.simpleIPA(df,ionisation=1, DB=DB,adductsAll=adducts,ppm=3,dfMS2=dfMS2,DBMS2=DBMS2,noits=5000,\n                             Bio=Bio,\n                             delta_add=0.1, \n                             delta_bio=0.4)\n```\n\n    isotopes already mapped\n    computing all adducts ....\n    0.1 seconds elapsed\n    annotating based on MS1 and MS2 information....\n    0.7 seconds elapsed\n    computing posterior probabilities including biochemical and adducts connections\n    initialising sampler ...\n\n\n    Gibbs Sampler Progress Bar: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:24<00:00, 207.29it/s]\n\n\n    parsing results ...\n    Done -  24.2 seconds elapsed\n\n"
      },
      "source": "https://raw.githubusercontent.com/francescodc87/ipaPy2/main/README.ipynb",
      "technique": "header_analysis"
    }
  ]
}
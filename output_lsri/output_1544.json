{
  "citation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Compute a projection to a reference data set",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "To project the single-cell RNA-seq data against a reference, we use the *dataProject* function:\n\n```R\nPBMCs<-RCAv2::dataProject(PBMCs,\n                     method = \"GlobalPanel\",\n                     corMeth = \"pearson\")\n```\n\nThe method parameter specifies the reference panel to be used. In this example, we use the *GlobalPanel* which is the original RCA panel used by Li et al. (Nat Genet, 2017).\nThe correlation with the reference panel and the single-cell data is assessed using Pearson correlation, as indiciated by the *corMeth* option.\nUpon calling the *dataProject* function, the PBMCs object has been extended:\n\n```R\nPBMCs\n```\n\n\tRCA reference class object\n\tRaw data: 5247 cells and 33570 features.\n\tFiltered data: 4973 cells and 17120 features.\n\tProjection data: 4973 cells to 179 cell-types\n\nIn addition to the *GlobalPanel*, RCA now provides *12* reference panels:\n\n* *GlobalPanel* from the original RCA (Li et al., 2017) containing both primary cell types and tissues. Can be limited to only cell types with *\"GlobalPanel_CellTypes*. \n* *ColonEpiPanel*: 9 colon epithelial samples from Li et al. (Nature genetics, 2017).\n* *MonacoPanel*: 29 PBMC cell types from Monaco, G., et al. (Cell reports, 2019).\n* *MonacoBCellPanel*: 5 B cell sub-types from Monaco, G., et al. (Cell reports, 2019).\n* *MonacoMonoPanel*: 5 Monocyte sub-types from Monaco, G., et al. (Cell reports, 2019).\n* *MonacoTCellPanel*: 15 T cell sub-types from Monaco, G., et al. (Cell reports, 2019).\n* *CITESeqPanel* based on Seurat 4.0 containing 34 cell types.\n* *ENCODEHumanPanel*: 93 human cell types from ENCODE.\n* *NovershternPanel*: 15 PBMC cell types from Novershtern et al. (Cell, 2011).\n* *NovershternTCellPanel*: 6 T cell sub-types from Novershtern et al. (Cell, 2011).\n* *ENCODEMousePanel*: 15 mouse cell types from ENCODE.\n* *ZhangMouseBrainPanel*: 7 mouse brain cell types from Tasic et al. (Nature neuroscience, 2016).\n\n\nRCAv2 directly allows the user to utilize any custom panel. A user generated panel **has to** have a distinct structure:\n* the panel has to be a R *data.frame* that is stored in *RDS* format,\n* row names of the *data.frame* are gene names that match the gene names present in the RNA-seq data,\n* column names of *data.frame* are cell-type/tissue names,\n\nTo use the custom panel *MyPanel.RDS* use the following command: \n\n```R\nPBMCs<-RCAv2::dataProject(PBMCs,\n                     method = \"Custom\",\n\t\t     customPath = \"MyPanel.RDS\",\n                     corMeth = \"pearson\")\n```\n\nTo benefit from multiple panels at the same time, users can exploit the *dataProjectMultiPanel* function:\n\n```R\nPBMCs<-RCAv2::dataProjectMultiPanel(PBMCs,method=list(\"NovershternPanel\", \"MonacoPanel\", \"GlobalPanel_CellTypes\"),corMeth=\"pearson\")\n```\n\nThe *dataProjectMultiPanel* function projects cells by default against the *Novershtern*, the *Monaco* and cell types from the *Global panel*.\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/prabhakarlab/RCAv2"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2019-09-02T09:38:56Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-07-29T20:56:22Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "R package for robust clustering of single cell RNA sequencing data"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 0.9948783169796392,
      "result": {
        "original_header": "RCA version 2.0",
        "type": "Text_excerpt",
        "value": "RCA (Reference Component Analysis) is a computational approach for robust cell type annotation of single cell RNA sequencing data (scRNAseq). \nIt is developed by the Prabhakar lab at the Genome Institute of Singapore (GIS). \nThe original version of RCA is published in Nature Genetics (doi: 10.1038/ng.3818, Li et al., 2017).\n \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9926491532537882,
      "result": {
        "original_header": "Functionality of RCA",
        "type": "Text_excerpt",
        "value": "RCA takes scRNA-seq data as input. For 10X Genomics data processed with CellRanger, build in quality control and preprocessing functions are available. Other data sets that have been preprocessed elsewhere can be incorporated as a count matrix. Reference datasets that can be included in RCA include (sorted) bulk RNA-seq, microarray and scRNA-seq data sets. Within RCA, we provide a function that allows users to easily generate custom reference panels from raw count data. Additionally we provide several reference panels for human cell types as well as for mouse. RCA considers a selected reference panel as well as query single cell data to compute a correlation matrix indicating the similarity of single cell transcriptomes to the reference transcriptomes. This, so called, reference projection, can be clustered and visualized in a heatmap, and/or directly visualized in a UMAP. The most likely cell type can be calculated either per cell or per cluster. \nAn overview on all features of RCA is provided in the Figure below: \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9133510957528875,
      "result": {
        "original_header": "Cluster/Cell-type specific quality control",
        "type": "Text_excerpt",
        "value": "RCAv2 offers straightforward ways to perform cluster-specific quality control. We illustrate this functionality using an inhouse dataset of 45926 cells obtained from five bone marrow samples.\nA link to download the data will be made available here at a later stage.\nFirst, we load the data, project it against the global panel and cluster it:\n```R\nnormalBoneMarow<-readRDS(\"../Documents/DUKE_Normal.RDS\")\ncreateRCAObject()\nPBMCs<-RCAv2::createRCAObject(normalCML@assays$RNA@data,dataIsNormalized = T)\n\nPBMCs<-RCAv2::dataProject(PBMCs,\n                          method = \"GlobalPanel\",\n                          corMeth = \"pearson\")\n\nPBMCs<-RCAv2::dataSClust(PBMCs,res = 0.1)\nRCAv2::plotRCAHeatmap(PBMCs,filename = \"Control_HeatmapPostQC.pdf\")\n```\nBased on the following projection heatmap \nwe identify the cluster IDs as:\n```R\ncellTypes<-c(\"Progenitor B\",\"CMP/MEP\",\"CMP/GMP\",\"GMP/Dendritic cells\",\"CD8 T cells\",\"NK cells\",\"CD4 T cells\", \"B cells\", \"Erythroid Progenitor\",\"Monocytes\",\"BT\")\nclusterColors<-c(\"purple\",\"black\",\"blue\",\"magenta\",\"turquoise\",\"yellow\",\"green\",\"pink\",\"greenyellow\",\"red\",\"brown\")\nnames(cellTypes)<-clusterColors\ncellTypeLabels<-cellTypes[PBMCs$clustering.out$dynamicColorsList[[1]]]\n```\nand plot cluster quality scores using\nBASH3*\nwhere *width* and *height* allow the user to customize plot size.\nAs shown in the generated scatter plot different clusters require distinct QC parameters:\n \nTherefore, we apply cluster specific NODG thresholds:\n```R\nRCAv2::performClusterSpecificQC(PBMCs,cluster.labels = PBMCs$clustering.out$dynamicColorsList[[1]],\n\tnGene.low.thresholds = c(500,2000,1000,500,750,750,750,800,3500,500,1250),\n\tnGene.high.thresholds = c(5000,6000,5000,5000,1800,2000,2000,2000,6500,3000,3000))\n```\nand replot the QC metrics\nBASH5*\nresulting in a satisfying, cluster-specific QC.\n \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9863106784809658,
      "result": {
        "original_header": "Combining RCA with Seurat",
        "type": "Text_excerpt",
        "value": "Data processing can also be carried out with Seurat. Here is an example how you can combine a RCA analysis with data preprocessed in Seurat.\n \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9007277309512282,
      "result": {
        "original_header": "Load and preprocess data",
        "type": "Text_excerpt",
        "value": "Using the same 10x data as before, we generate a Seurat object and perform an initial analysis:\n```R\nlibrary(Seurat)\n\n#Load the data\nPBMCs.10x.data<-Seurat::Read10X(\"../Downloads/10xExample/\",)\n\n#Generate a Seurat object\npbmc_Seurat <- CreateSeuratObject(counts = PBMCs.10x.data$`Gene Expression`, \n                  min.cells = 3, \n                  min.features  = 200, \n                  project = \"10X_PBMC\", \n                  assay = \"RNA\")\n\n#Compute the percentage of mitochondrial rates\nmito.genes<-grep(pattern=\"^MT-\",x=rownames(pbmc_Seurat@assays[[\"RNA\"]]),value=T)\npercent.mito <- Matrix::colSums(pbmc_Seurat@assays[[\"RNA\"]][mito.genes, ])/\n                                Matrix::colSums(pbmc_Seurat@assays[[\"RNA\"]])\npbmc_Seurat <- AddMetaData(object = pbmc_Seurat, metadata = percent.mito, col.name = \"percent.mito\")\n\n#Perform QC using the same parameters as above\npbmc_Seurat <- subset(pbmc_Seurat, nFeature_RNA >300 & nFeature_RNA < 5000 &\n                        nCount_RNA > 400 & nCount_RNA<30000 &\n                        percent.mito > 0.025 & percent.mito < 0.2)\n\n#Normalize the data\npbmc_Seurat <- NormalizeData(object = pbmc_Seurat, normalization.method = \"LogNormalize\", scale.factor = 10000)\n```\n \nTo run RCA, no further processing steps would be needed. However, we want to also compare the RCA result to the Seurat based clustering, therefore we first go on with a Seurat based analysis:\n```R\n\n#Find HVGs\npbmc_Seurat <- FindVariableFeatures(object = pbmc_Seurat, \n                   mean.function = ExpMean, \n                   dispersion.function = LogVMR, \n                   x.low.cutoff = 0.0125, \n                   x.high.cutoff = 3, \n                   y.cutoff = 0.5, \n                   nfeatures = 2000)\n\n#Center and scale the data\npbmc_Seurat <- ScaleData(object = pbmc_Seurat)\n\n#Run PCA on the data\npbmc_Seurat <- RunPCA(object = pbmc_Seurat,  npcs = 50, verbose = FALSE)\n\n#Plot different aspsects of the pca\nElbowPlot(object = pbmc_Seurat,ndims = 50)\n``` \nBased on the Elbowplot (not shown here), we use 20 PCs for further analysis. \n```R\n#Find Neighbors\npbmc_Seurat <- FindNeighbors(pbmc_Seurat, reduction = \"pca\", dims = 1:20)\n\n#Find Clusters\npbmc_Seurat <- FindClusters(pbmc_Seurat, resolution = 0.2, algorithm = 1)\n``` \nWe generate a UMAP of the data stored in the Seurat object using the umap R package:\n```R\n#Load required libraries\nlibrary(umap)\nlibrary(ggplot2)\nlibrary(randomcoloR)\n\n#Compute Umap from first 20PCs\numap_resultS<- umap(pbmc_Seurat@reductions$pca@cell.embeddings[,c(1:20)])\numap_resultSL<-as.data.frame(umap_resultS$layout)\n\n#Derive distinguishable colors for the seurat clusters\nmyColors<-distinctColorPalette(length(unique(pbmc_Seurat$seurat_clusters)))\n\n#Generate a UMAP\numapAll_Seurat_RCA<-ggplot(umap_resultSL,aes(x=V1,y=V2,color=pbmc_Seurat$seurat_clusters))+theme_bw(30)+\n  geom_point(size=1.5)+labs(colour=\"ClusterID\")+theme(legend.title = element_text(size=10))+\n  guides(colour = guide_legend(override.aes = list(size=4)))+theme(legend.position = \"right\")+\n  theme(legend.text=element_text(size=10))+scale_color_manual(values=myColors)+xlab(\"UMAP1\")+ylab(\"UMAP2\")\numapAll_Seurat_RCA\n```\nWe obtain the following UMAP:\n![](man/figures/UMAP_Seurat.png)\n \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8490843145411996,
      "result": {
        "original_header": "Generate a RCA object and perform RCA analysis",
        "type": "Text_excerpt",
        "value": "We use the RCA function *createRCAObject* to generate a RCA object from the raw and optionally also the normalized data stored in our Seurat object.\n```R\nlibrary(RCAv2)\nRCA_from_Seurat<-RCAv2::createRCAObject(pbmc_Seurat@assays$RNA@counts, pbmc_Seurat@assays$RNA@data)\n```\nNext, we can compute the projection, cluster the data, and estimate the most likely cell type for each cell as above:\nBASH2*\nUsing the RCA cell type labels, RCA and Seurat clusters, we generate two new UMAPs whose coordinates are based on the PCs derived from HVGs and that are colored according to RCA clusters and cell type labels.\n```R\n#Simplify the cell type annotation\nSimplifiedAnnotation<-unlist(RCA_from_Seurat$cell.Type.Estimate.per.cluster)\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"CD33._Myeloid\")]<-\"Myeloid\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"CD4._Tcells\")]<-\"T cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"CD8._Tcells\")]<-\"T cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"CD14._Monocytes\")]<- \"Monocytes\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"BDCA4._DentriticCells\")]<-\"Dentritic cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L93_B.Cell_Plasma.Cell\")]<- \"B cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L52_Platelet\")]<-\"Myeloid\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L74_T.Cell_CD4.Centr..Memory\")]<-\"T cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L51_B.Cell_Bone.Marrow\")]<-\"T cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L75_T.Cell_CD4.Centr..Memory\")]<-\"T cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L85_NK.Cell_CD56Hi\")]<-\"NK cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"CD34.\")]<-\"Progenitor\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L45_CMP_Bone.Marrow\")]<- \"Progenitor\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"WholeBlood\")]<- \"Myeloid\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L69_Dendritic.Cell_Monocyte.derived\")]<- \"Myeloid\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L80_T.Cell_CD8.Eff..Memory\")]<-\"T cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L60_Monocyte_CD16\")]<- \"Monocytes\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L86_NK.Cell_CD56Lo\")]<-\"NK cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"L73_T.Cell_CD4.Naive\")]<-\"T cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"CD56._NKCells\")]<-\"NK cells\"\nSimplifiedAnnotation[which(SimplifiedAnnotation==\"CD19._BCells.neg._sel..\")]<- \"B cells\"\n\n#Plot a umap colored by the simplified cell type labels\nmyColors<-distinctColorPalette(length(unique(SimplifiedAnnotation)))\numapAll_Seurat_Estimated_CT<-ggplot(umap_resultSL,\naes(x=V1,y=V2,color=SimplifiedAnnotation))+\ntheme_bw(30)+\ngeom_point(size=1.5)+\ntheme(legend.position = \"bottom\")+\nlabs(colour=\"Cell type\")+\nguides(colour = guide_legend(override.aes = list(size=4)))+\ntheme(legend.text=element_text(size=10))+\nscale_color_manual(values=myColors)+\nggtitle(\"b)\")+\nxlab(\"UMAP1\")+ylab(\"UMAP2\")+\ntheme(legend.title = element_text(size=12))\n\n#Plot a umap colored by the RCA cluster ID\numapAll_Seurat_RCA_Clusters<-ggplot(umap_resultSL,\naes(x=V1,y=V2,color=RCA_from_Seurat$clustering.out$dynamicColorsList[[1]]))+\ntheme_bw(30)+\ngeom_point(size=1.5)+\ntheme(legend.position = \"bottom\")+\nlabs(colour=\"RCA Cluster ID\")+\nguides(colour = guide_legend(override.aes = list(size=4)))+\ntheme(legend.text=element_text(size=10))+\nxlab(\"UMAP1\")+ylab(\"UMAP2\")+\nscale_color_identity(guide=guides(color=RCA_from_Seurat$clustering.out$dynamicColorsList[[1]]))+\nggtitle(\"a)\")+\ntheme(legend.title = element_text(size=12))\n\n#Combine the Figures into one\nlibrary(gridExtra)\ngrid.arrange(umapAll_Seurat_RCA_Clusters,umapAll_Seurat_Estimated_CT,nrow=1)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9717808941847094,
      "result": {
        "original_header": "Add projection and annotations to the Seurat object",
        "type": "Text_excerpt",
        "value": "For greater convenience the results of RCA can be saved within the Seurat object for further analysis.\n```R\npbmc_Seurat[[\"RCA.clusters\"]]<-RCA_from_Seurat$clustering.out$dynamicColorsList\npbmc_Seurat[[\"cellTypeLabel\"]]<-RCA_from_Seurat$cell.Type.Estimate.per.cluster\npbmc_Seurat[[\"Projection\"]]<-CreateAssayObject(data=RCA_from_Seurat$projection.data)\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.875586280538324,
      "result": {
        "original_header": "Add a UMAP based on the projection to the Seurat object",
        "type": "Text_excerpt",
        "value": "Also, a UMAP reduction based on the projection space can be added to the Seurat object:\n```R\nRCA_from_Seurat<-computeUMAP(RCA_from_Seurat)\npbmc_Seurat[[\"RCA_umap\"]]<-CreateDimReducObject(embeddings=as.matrix(RCA_from_Seurat$umap.coordinates),key=\"RCA_umap_\",assay=DefaultAssay(pbmc_Seurat))\n``` \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9493812131346328,
      "result": {
        "original_header": "Visualizing RNA velocity on RCA result",
        "type": "Text_excerpt",
        "value": "RNA velocity describes the rate of gene expression change for an individual gene at a given time point based on the ratio of its spliced and unspliced messenger RNA (mRNA). Here, we describe how one can use the [scvelo](https://scvelo.readthedocs.io/) package, in Python, to visualize RNA velocity on the RCA generated result. \nTo transfer spliced RNA counts to scvelo, first transpose the raw RCA data matrix to get a cells x genes matrix, and export it to a CSV file.\n```R\n# R\nraw.data.counts <- t(rca_obj$raw.data)\nwrite.table(x = raw.data.counts, file = \"raw_counts.csv\", append = FALSE, quote = FALSE, sep = \",\")\n```\n\nIn addition, export the RCA projection and UMAP embeddings to respective CSV files too.\n```R\n# R\nprojection.data <- as.matrix(t(rca_obj$projection.data[, -doublet_index]))\nwrite.table(x = projection.data, file = \"projection_data.csv\", append = FALSE, quote = FALSE, col.names = F, row.names = F, sep = \",\")\n\numap.data <- as.matrix(rca_obj$umap.coordinates)\nwrite.table(x = umap.data, file = \"umap_data.csv\", append = FALSE, quote = FALSE, col.names = F, row.names = F, sep = \",\")\n```\n \nThen, create a Scanpy object using the raw counts from the CSV file.\n```Python\n# Python\nadata = sc.read_csv(filename='raw_counts.csv')\n```\nPopulate the PCA slot in the Scanpy object as the projection data from RCA.\n```Python\n\n# Python\nprojection_data = np.loadtxt('bm_input/projection_data.csv',delimiter=',')\nprojection_data.shape\n\nadata.obsm['X_pca'] = projection_data\n```\nPopulate the UMAP slot in the Scanpy object as the umap coordinates from RCA.\n```Python\n# Python\numap_data = np.loadtxt('bm_input/umap_data.csv',delimiter=',')\numap_data.shape\n\nadata.obsm['X_umap'] = umap_data\n```\nLoad the unspliced loom object generated by [velocyto](http://velocyto.org/).\n```Python\n# Python\nldata = scv.read('merged.loom', cache=True)\n```\nThen, merge the spliced and unspliced objects together as described below:\n```Python\n# Python\nmerged_data = scv.utils.merge(adata, ldata)\n```\nAs recommended by the scvelo tutorial, perform the following steps to compute RNA velocity:\n```Python\n# Python\nscv.pp.filter_and_normalize(merged_data)\nscv.pp.moments(merged_data)\nscv.tl.velocity(merged_data, mode='stochastic')\nscv.tl.velocity_graph(merged_data)\n```\nIt is possible that not all barcodes had sufficient quality of both spliced and unspliced reads, and thus some cells may have been discarded during the merging process. To ensure your cell type labels are still maintained, export the merged data observations from the merged scvelo object to a CSV file.\n```Python\n# Python\nmerged_data.obs.to_csv('merged_data_obs.csv')\n```\nIn R, load this CSV file in and extract the RCA labels and filter only those which were considered in the merged data by scvelo.\n```R\n# R\nmerged_data_obs <- read.csv(file = \"merged_data_obs.csv\", row.names = 1)\nrca_clusters <- rca_obj$clustering.out$dynamicColorsList$Clusters\nnames(rca_clusters) <- colnames(rca_obj$raw.data)\nrca_clusters <- rca_clusters[rownames(merged_data_obs)]\n```\n**Note: If your cell names have underscores in them, scanpy will automatically split the cell name into barcode and sample_batch.**\nIn this case, replace the last line of the above block of code with the following:\n```R\n# R\nmerged_barcodes <- paste0(merged_data_obs$sample_batch, rownames(merged_data_obs))\nrca_clusters <- rca_clusters[merged_barcodes]\n```\nNow export these cluster labels to a CSV file.\n```R\n# R\nrca_cluster_df <- data.frame(Clusters = rca_clusters)\nwrite.table(x = rca_cluster_df, file = \"rca_cluster_df.csv\", append = FALSE, quote = FALSE, col.names = T, row.names = F, sep = \",\")\n```\nBack in the scvelo iPynb, load this RCA cluster annotation table and set it as the observation slot of your merged data.\n```Python\n# Python\nrca_clusters = pd.read_csv('rca_cluster_df.csv')\nmerged_data.obs = rca_clusters\n```\nNow, it's finally time to visualize the RNA velocity results. There are 3 visualization options provided by scvelo, namely velocity_embedding, velocity_embedding_grid and velocity_embedding_stream. Use them as demonstrated below\n```Python\n# Python\n### Velocity embedding\nscv.pl.velocity_embedding(merged_data, basis='umap', color = ['Clusters'], legend_loc = 'right margin', palette = 'tab20', figsize = (10,10), save = 'embedding.png')\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/prabhakarlab/RCAv2/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "faq": [
    {
      "confidence": 1,
      "result": {
        "original_header": "FAQ",
        "parent_header": [
          "RCA version 2.0"
        ],
        "type": "Text_excerpt",
        "value": "**What is the difference between the original RCA version (Li et al., Nat Genet, 2017) and RCA version 2?**\n\n*RCA version 2 improves upon version 1 in terms of performance, applicability, functionality and usability. We reimplented the algorithm more efficiently and use faster packages. We considerably extended the included reference data sets and provide new ways of cluster free cell type annotation for large data sets and added graph based clustering in addition to the previously used hierachical clustering. Also the automated generation of figures has been improved to scale better with the size of current data sets.*\n\n**The clustering is very slow (or it doesn't work at all), what can I do?**\n\n*First make sure you are indeed using RCA version 2. Secondly you may check whether you want to cluster cells in PC space and avoid to compute a full distance matrix. Also consider to run RCA on a compute cluster or in the cloud using a machine with large main memory.*\n\n**The cell-type I am interested in are not part of the provided panels, can I generate and use my own reference data set in RCA?**\n\n*Yes you can. Any custom panel can be considered in RCA. An example is shown above.*\n\n**I do not have 10X data, can I just use a count matrix as input for RCA?**\n\n*Yes, that is possible as well. You can generate a RCA object from a custom count matrix using. Guidelines are provided above (Compute a projection to a reference data set)*\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 10
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/prabhakarlab/RCAv2/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "prabhakarlab/RCAv2"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "RCA version 2.0"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "images": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/Overview_Figure.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/QC_Example.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/Heatmap_Example_With_Threshold.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/Umap_clusters_Example.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/Example_3D_Umap.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/Cluster_Enrichment.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/Umap_ct_based_clustering_Example.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/Umap_NK_marker_CD56_Example.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/PerClusterAssignment.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/ParameterPlotDBSCAN.PNG"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/RCA_Heatmap_Seurat.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/RCA_GO_Example.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/RCA_KEGG_Example.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/BM_heatmap.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/BM_BeforeQC.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/UMAP_Seurat.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/man/figures/Combined_UMAPs_Seurat_RCA.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/../man/figures/scvelo_embedding.png"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "A beginner's guide to RCA",
        "parent_header": [
          "RCA version 2.0"
        ],
        "type": "Text_excerpt",
        "value": "This guide will walk you through installing RCA2 and will showcase a exemplary analysis of publicly available scRNA-seq data from *10X Genomics*.\nIf you are using the *Seurat* R-package already and want to stick to that, we suggest you to look at the Section *Combining Seurat and RCA*. \nFurther details on parameters and function of the mentioned R functions are provided in the R help"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Install the RCA R-package",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "Before you try to install RCA make sure that your R-version is at least R 3.5.0. We have tested RCA on Windows, Linux and Mac devices up to R version 4.0.2.\nYou can directly install RCA from github using the commands:\n\n```R\nlibrary(remotes)\ninstall_github(\"prabhakarlab/RCAv2\")\n```\n\nThe current release of RCA requires the following packages to be available on your system:\n* remotes\n* Matrix\n* qlcMatrix\n* WGCNA\n* fastcluster\n* dbscan\n* BiocManager\n* ggplot2\n* plotly\n* plotrix\n* gridExtra\n* dplyr\n* ComplexHeatmap\n* circlize\n* umap\n* ggpubr\n* irlba\n\nAll missing CRAN-packages can be *automatically installed* during the RCA installation.\nNote that the *HiClimR*, package is optional, it allows to speed up the computationally expensive steps. Also the\n*randomColoR* package is optional, it is useful to obtain distinguishable colors.\nFurther optional packages are *Seurat*, available from CRAN, and *clusterProfiler*, *enrichplot* as well as corresponding annotation libraries.\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Load the package",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "After installation, load the package with the command\n```R\nlibrary(\"RCAv2\")\n```\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Generate a RCA object from scRNA-seq data",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "In this example, we consider a publicly available PBMC dataset generated by [10X Genomics](https://support.10xgenomics.com/single-cell-gene-expression/datasets/3.0.2/5k_pbmc_protein_v3).\nWe assume the data is [downloaded](http://cf.10xgenomics.com/samples/cell-exp/3.0.2/5k_pbmc_protein_v3/5k_pbmc_protein_v3_raw_feature_bc_matrix.tar.gz), unpacked and stored in the folder *10xPBMCs*, which should be placed in the working directory.\n\nWe generate a RCA object called **PBMCs** using the function *createRCAObjectFrom10X* by providing the path to the data.\n```R\nPBMCs<-RCAv2::createRCAObjectFrom10X(\"10xPBMCs/\")\n```\n\nThe resulting RCA object has its own print function providing basic information on the data\n```R\nPBMCs\n```\n\n\tRCA reference class object\n\tRaw data: 5247 cells and 33570 features.\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Perform basic QC steps and data normalization",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "Quality control can performed directly within RCA. We use the command\n\n```R\nPBMCs<-RCAv2::dataFilter(PBMCs,\n                  nGene.thresholds = c(300,5000), \n                  nUMI.thresholds = c(400,30000),\n                  percent.mito.thresholds = c(0.025,0.2),\n                  min.cell.exp = 3,\n                  plot=T,\n                  filename = \"PBMCs_filter_example.pdf\")\n```\n\nto filter the raw data according to\n* the number of detected genes (*nGene.thresholds*)\n* the number of unique molecular identifiers (*nUMI.thresholds*)\n* the percentage of mitochondrial reads (*percent.mito.thresholds*)\n* the minimum number of cells any gene needs to be expressed (*min.cell.exp*)\n\n\nFor easy interpretation of the data, the *dataFilter* function automatically generates a graphical representation of various QC metrics: \n\n![](man/figures/QC_Example.png)\n\nPlotting can be disabled using the *plot* option.\n\nInterrogating the R-object with\n\n```R\nPBMCs\n```\n\ntells us that the RCA object now holds both the intial unfiltered data as well as the data after QC.\n\n\tRCA reference class object\n\tRaw data: 5247 cells and 33570 features.\n\tFiltered data: 4973 cells and 17120 features.\n\nUpon filtering, we can normalize the data by sequencing depth and log transform it:\n\n```R\nPBMCs<-RCAv2::dataLogNormalise(PBMCs)\n```\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Compute a projection to a reference data set",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "To project the single-cell RNA-seq data against a reference, we use the *dataProject* function:\n\n```R\nPBMCs<-RCAv2::dataProject(PBMCs,\n                     method = \"GlobalPanel\",\n                     corMeth = \"pearson\")\n```\n\nThe method parameter specifies the reference panel to be used. In this example, we use the *GlobalPanel* which is the original RCA panel used by Li et al. (Nat Genet, 2017).\nThe correlation with the reference panel and the single-cell data is assessed using Pearson correlation, as indiciated by the *corMeth* option.\nUpon calling the *dataProject* function, the PBMCs object has been extended:\n\n```R\nPBMCs\n```\n\n\tRCA reference class object\n\tRaw data: 5247 cells and 33570 features.\n\tFiltered data: 4973 cells and 17120 features.\n\tProjection data: 4973 cells to 179 cell-types\n\nIn addition to the *GlobalPanel*, RCA now provides *12* reference panels:\n\n* *GlobalPanel* from the original RCA (Li et al., 2017) containing both primary cell types and tissues. Can be limited to only cell types with *\"GlobalPanel_CellTypes*. \n* *ColonEpiPanel*: 9 colon epithelial samples from Li et al. (Nature genetics, 2017).\n* *MonacoPanel*: 29 PBMC cell types from Monaco, G., et al. (Cell reports, 2019).\n* *MonacoBCellPanel*: 5 B cell sub-types from Monaco, G., et al. (Cell reports, 2019).\n* *MonacoMonoPanel*: 5 Monocyte sub-types from Monaco, G., et al. (Cell reports, 2019).\n* *MonacoTCellPanel*: 15 T cell sub-types from Monaco, G., et al. (Cell reports, 2019).\n* *CITESeqPanel* based on Seurat 4.0 containing 34 cell types.\n* *ENCODEHumanPanel*: 93 human cell types from ENCODE.\n* *NovershternPanel*: 15 PBMC cell types from Novershtern et al. (Cell, 2011).\n* *NovershternTCellPanel*: 6 T cell sub-types from Novershtern et al. (Cell, 2011).\n* *ENCODEMousePanel*: 15 mouse cell types from ENCODE.\n* *ZhangMouseBrainPanel*: 7 mouse brain cell types from Tasic et al. (Nature neuroscience, 2016).\n\n\nRCAv2 directly allows the user to utilize any custom panel. A user generated panel **has to** have a distinct structure:\n* the panel has to be a R *data.frame* that is stored in *RDS* format,\n* row names of the *data.frame* are gene names that match the gene names present in the RNA-seq data,\n* column names of *data.frame* are cell-type/tissue names,\n\nTo use the custom panel *MyPanel.RDS* use the following command: \n\n```R\nPBMCs<-RCAv2::dataProject(PBMCs,\n                     method = \"Custom\",\n\t\t     customPath = \"MyPanel.RDS\",\n                     corMeth = \"pearson\")\n```\n\nTo benefit from multiple panels at the same time, users can exploit the *dataProjectMultiPanel* function:\n\n```R\nPBMCs<-RCAv2::dataProjectMultiPanel(PBMCs,method=list(\"NovershternPanel\", \"MonacoPanel\", \"GlobalPanel_CellTypes\"),corMeth=\"pearson\")\n```\n\nThe *dataProjectMultiPanel* function projects cells by default against the *Novershtern*, the *Monaco* and cell types from the *Global panel*.\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Cluster the projection and visualize it",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "The projected data can be clustered using the command:\n```R\nPBMCs<-RCAv2::dataClust(PBMCs)\n```\nThe clustering can be influenced by the parameters *deepSplitValues* and *minClustSize*, indicating the deepness of the cut in the clustering and the minimum number of cells within a cluster, respectively. \n\nRCA offers a heatmap plotting function using the *ComplexHeatmap* package:\n\n```R\nRCAv2::plotRCAHeatmap(PBMCs,filename = \"Heatmap_PBMCs.pdf\",var.thrs=1)\n```\n\nThe heatmap can be used to manually assign cell-types based on the projection. Via the *var.thrs* parameter, the heatmap can be reduced to show only cell-types with the indicated degree of variation.\n\n![](man/figures/Heatmap_Example_With_Threshold.png)\n\nIn addition to the visuzalization in the heatmap, it can make sense to look at the projection using a UMAP.\nTo do so, simple use the functions\n\n```R\nPBMCs<-computeUMAP(PBMCs)\nRCAv2::plotRCAUMAP(PBMCs,filename = \"UMAP_PBMCs.pdf\")\n```\nThe *plotRCAUMAP* returns a list of *ggplot2* objects to allow for simple modification of the generated figures. \n\n![](man/figures/Umap_clusters_Example.png)\n\nIn addition to the standard 2D umaps, RCA also allows the generation of 3D umaps.\n```R\nPBMCs<-computeUMAP(PBMCs, nDIMS = 3)\nRCAv2::plotRCAUMAP3D(PBMCs,filename = \"UMAP3D_PBMCs.html\")\n```\n3D umaps are stored as *html* files that can be interactively inspected with any browser. Due to github limitations, only a screenshot is shown below:\n\n![](man/figures/Example_3D_Umap.png)\n\n\nTo better understand the composition of each cluster we generate a stacked bar plot Figure using the *plotRCAClusterComposition* function:\n```R\n#Generate the cluster composition plot\nRCAv2::plotRCAClusterComposition(PBMCs,filename=\"Cluster_Composition.pdf\")\n```\n\n__We highly recommend that you aggregate individual cell type labels across a cluster, identify the cell type label that corresponds to the majority of the cells in the cluster, and use this majority-vote cell type label as the cell type annotation for the cluster.__\n\n__Please see _estimateCellTypeFromProjectionPerCluster_ below for an automated implementation of this procedure in RCAv2.__\n\n![](man/figures/Cluster_Enrichment.png)\n\nIn a) we show the relative composition of each cluster and b) shows the absolute number of cells in each cluster. The color code indicates the most likely annotation of the cells.\n\nBased on the heatmap as well as the stacked bar plots we can relabel the clusters according to the major cell type annotations:\n```R\nRCAcellTypes<-PBMCs$clustering.out$dynamicColorsList[[1]]\nRCAcellTypes[which(RCAcellTypes==\"blue\")]<-\"Monocytes\"\nRCAcellTypes[which(RCAcellTypes==\"green\")]<-\"Dentritic cells\"\nRCAcellTypes[which(RCAcellTypes==\"yellow\")]<-\"B cells\"\nRCAcellTypes[which(RCAcellTypes==\"grey\")]<-\"B cells\"\nRCAcellTypes[which(RCAcellTypes==\"brown\")]<-\"NK cells\"\nRCAcellTypes[which(RCAcellTypes==\"turquoise\")]<-\"T cells\"\nRCAcellTypes[which(RCAcellTypes==\"red\")]<-\"Myeloid cells\"\nRCAcellTypes[which(RCAcellTypes==\"black\")]<-\"Progenitor cells\"\n```\n\nAlso, we generate a vector holding the expression of *CD56*, a common NK cell marker. The gene name of *CD56* is NCAM1.\n\n```R\nCD56Exp<-PBMCs$data[which(rownames(PBMCs$data)==\"NCAM1\"),]\n```\n\nWe can use the RCA plot function to obtain two additional UMAPs that are labelled according to the cell types and the CD56 marker:\n\n```R\nRCAv2::plotRCAUMAP(PBMCs,cellPropertyList = list(CellTypes=RCAcellTypes,CD56=CD56Exp),filename = \"UMAP_PBMCs.pdf\")\n```\nEach UMAP will be stored in a separate *pdf* where the filename indicates which element from the *cellPropertyList* is depicted in the UMAP.\n\n![](man/figures/Umap_ct_based_clustering_Example.png)\n\n![](man/figures/Umap_NK_marker_CD56_Example.png)\n\nFor numerical data, the dots are transparent for low values to avoid overplotting issues. In our example, we can see that *CD56* expression corresponds to the NK annotation.\n\nTo obtain a less noisy cell type labelling, cell types should be predicted at the cluster level. To this end, RCAv2 carries out a majority vote using the cluster-composition plot mentioned above.\n\nTo obtain cluster based cell type predictions, the user can run the function *estimateCellTypeFromProjectionPerCluster*:\n```R\n\nPBMCs<-RCAv2::createRCAObjectFrom10X(\"../Documents/10xExample/\")\nPBMCs<-RCAv2::dataFilter(PBMCs,nGene.thresholds = c(300,4500),\n                  percent.mito.thresholds = c(0.025,0.1),\n                  min.cell.exp = 3)\nPBMCs<-RCAv2::dataLogNormalise(PBMCs)\nPBMCs<-RCAv2::dataProject(PBMCs,\n                          method = \"NovershternPanel\",\n                          corMeth = \"pearson\", \n\t\t\t  nPCs=0,\n\t\t\t  approx= FALSE)\nPBMCs<-RCAv2::dataSClust(PBMCs,res = 0.15)\nPBMCs<-estimateCellTypeFromProjectionPerCluster(PBMCs)\n```\nThe figure below shows an example using the PBMC dataset using the Novershtern panel.\n![](man/figures/PerClusterAssignment.png)\n\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Graph based clustering as an alternative to hierarchical clustering",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "Due to the increasing size of single cell datasets, hierarchical clustering requires machines with large main memory. To overcome this putative limitation, RCAv2 also offers graph based clustering using a shared neirest neighbour (snn) approach (Halser et al., Journal of Statistical Software, 2019).\nTo cluster the PBMC projection using the snn approach run\n```R\nPBMCs<-RCAv2::dataSNN(PBMCs,k=100,eps=25,minPts=30,dist.fun=\"All\",corMeth=\"pearson\")\n```\nThis function has three main parameters:\n* *k* as the number of considered neighbours per cell,\n* *eps* as the minimum number of shared neighbours between to cells,\n* *minPts* minimum number of points that share *eps* neighbours such that a point is considered a core point.\n\nThe *dist.fun* parameter controls whether the distance matrix used for SNN clustering is based on the full correlation distance matrix or, if *dist.fun* is set to *PCA*, on a PC reduction of the reference projection. The *corMeth* sets which correlation function is used for the distance computation (pearson (default), spearman or kendal).\nAs for the hierarchical clustering, heatmaps and umaps can be generated as well.\n\nTo help the user choosing the parameters for clustering, we provide a parameter space exploration feature leading to a 3D umap illustrating the number of clusters depending on the three parameters, as shown below. \n\n![](man/figures/ParameterPlotDBSCAN.PNG)\n\nThis figure can be generated using the function\n```R\nparameterSpaceSNN(PBMCs,kL=c(30:50),epsL=c(5:20),minPtsL=c(5:10),folderpath=\".\",filename=\"Graph_based_Clustering_Parameter_Space.html\") \n```\nwhere *kL*, *epsL* and *minPtsL* define the search space for *k*, *eps* and *minPts* respectively. Note that executing this function will take longer for large search spaces.\nIn addition to those clustering parameters, via the *dist.fun* parameter one can choose whether a PCA reduction of the projection matrix, or the entire projection matrix should be used to construct the snn graph.\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Using Louvain graph clustering implemented in Seurat",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "As the snn clustering approach mentioned above requires multiple parameteres to be tuned, RCAv2 also allows to cluster cells using the Louvain graph based clustering used in Seurat (Butler et al., Nature Biotechnology, 2018).\nTo cluster the PBMC projection using Seurat clustering, run:\n```R\nPBMCs<-dataSClust(PBMCs,res=0.5)\n```\nwhere res is the resolution parameter parsed on to the Seurat clustering function. \n\nUpon graph based clustering, the RCA projection heatmap will be plotted without column dendrogramms.\n\n![](man/figures/RCA_Heatmap_Seurat.png)\n\nThis function uses the same approximation of the PCA as the original Seurat function. Setting *approx* to FALSE will compute the exact PCA. If the *corMeth* parameter is set to either *pearson, spearman* or *kendal*, the function will compute a full distance matrix using correlation distance instead of the default euclidean distance. This can also be combined with the exact PCA. However, not that these options require more memory to be available than the default. With the *elbowPlot* function, an ElbowPlot that guides the selection of the number of PCs to be considered can be generated.\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Compute DE genes for RCA clusters",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "To ease cluster interpretation further, RCAv2 allows the user to compute pairwise DE genes for all identified clusters.\nComputation can be initiated with the command:\n```R\nPBMCs<-RCAv2::dataDE(PBMCs,\n  logFoldChange = 1.5,\n  method = \"wilcox\",\n  mean.Exp = 0.5,\n  deep.Split.Values = 1,\n  min.pct = 0.25,\n  min.diff.pct = -Inf,\n  random.seed = 1,\n  min.cells.group = 3,\n  pseudocount.use = 1,\n  p.adjust.methods = \"BH\",\n  top.genes.per.cluster = 10\n)\n```\nHere, *logFoldChange* is the required logFoldChange to call a gene to be differentially expressed. The *method* parameter indicates which statistical test is used. Multiple test correction is perfomed using the method indicated in *p.adjust.methods*.\nThe parameters *mean.Exp* and *min.pct* indicat the minimum expression value as well as the minimum percentage of cells expressing a gene. Furthermore, the pseudocount\ncan be adjusted via the *pseudocount.use* parameter. The *top.genes.per.cluster* parameter indicats how many genes should be selected as top DE genes per pairwise comparison for each cluster.\nBoth the entire set of DE genes as well as the top DE genes are stored in the PBMCs *rca.obj*.\nThe topDE genes can be plotted in a heatmap via the *plotDEHeatmap* function:\n```R\nRCAv2::plotDEHeatmap(PBMCs,scale=FALSE)\n```\nThe *scale* parameter allows the user to plot either the normalized UMI counts or scaled count (z-transformed). An example is shown below.\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.9938110274579668,
      "result": {
        "original_header": "Release notes",
        "type": "Text_excerpt",
        "value": "Version 2.0 <br>\nRelease date: September 3, 2019\n \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9526878098062654,
      "result": {
        "original_header": "Visualizing RNA velocity on RCA result",
        "type": "Text_excerpt",
        "value": "[Create an iPython notebook](https://www.dataquest.io/blog/jupyter-notebook-tutorial/) in the same folder and import the required packages as below. \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "invocation": [
    {
      "confidence": 0.8070736508825537,
      "result": {
        "original_header": "Cluster/Cell-type specific quality control",
        "type": "Text_excerpt",
        "value": "we identify the cluster IDs as:\n```R\ncellTypes<-c(\"Progenitor B\",\"CMP/MEP\",\"CMP/GMP\",\"GMP/Dendritic cells\",\"CD8 T cells\",\"NK cells\",\"CD4 T cells\", \"B cells\", \"Erythroid Progenitor\",\"Monocytes\",\"BT\")\nclusterColors<-c(\"purple\",\"black\",\"blue\",\"magenta\",\"turquoise\",\"yellow\",\"green\",\"pink\",\"greenyellow\",\"red\",\"brown\")\nnames(cellTypes)<-clusterColors\ncellTypeLabels<-cellTypes[PBMCs$clustering.out$dynamicColorsList[[1]]]\n```\nand plot cluster quality scores using\nBASH3*\nwhere *width* and *height* allow the user to customize plot size.\nAs shown in the generated scatter plot different clusters require distinct QC parameters:\n \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.871134867223193,
      "result": {
        "original_header": "Visualizing RNA velocity on RCA result",
        "type": "Text_excerpt",
        "value": "To transfer spliced RNA counts to scvelo, first transpose the raw RCA data matrix to get a cells x genes matrix, and export it to a CSV file.\n```R\n# R\nraw.data.counts <- t(rca_obj$raw.data)\nwrite.table(x = raw.data.counts, file = \"raw_counts.csv\", append = FALSE, quote = FALSE, sep = \",\")\n```\n\nIn addition, export the RCA projection and UMAP embeddings to respective CSV files too.\n```R\n# R\nprojection.data <- as.matrix(t(rca_obj$projection.data[, -doublet_index]))\nwrite.table(x = projection.data, file = \"projection_data.csv\", append = FALSE, quote = FALSE, col.names = F, row.names = F, sep = \",\")\n\numap.data <- as.matrix(rca_obj$umap.coordinates)\nwrite.table(x = umap.data, file = \"umap_data.csv\", append = FALSE, quote = FALSE, col.names = F, row.names = F, sep = \",\")\n```\n \n```Python\n# Python\nimport scvelo as scv\nimport scanpy as sc\nimport numpy as np\nimport pandas as pd\nscv.set_figure_params()\n``` \nThen, create a Scanpy object using the raw counts from the CSV file.\n```Python\n# Python\nadata = sc.read_csv(filename='raw_counts.csv')\n```\nPopulate the PCA slot in the Scanpy object as the projection data from RCA.\n```Python\n\n# Python\nprojection_data = np.loadtxt('bm_input/projection_data.csv',delimiter=',')\nprojection_data.shape\n\nadata.obsm['X_pca'] = projection_data\n```\nPopulate the UMAP slot in the Scanpy object as the umap coordinates from RCA.\n```Python\n# Python\numap_data = np.loadtxt('bm_input/umap_data.csv',delimiter=',')\numap_data.shape\n\nadata.obsm['X_umap'] = umap_data\n```\nLoad the unspliced loom object generated by [velocyto](http://velocyto.org/).\n```Python\n# Python\nldata = scv.read('merged.loom', cache=True)\n```\nThen, merge the spliced and unspliced objects together as described below:\n```Python\n# Python\nmerged_data = scv.utils.merge(adata, ldata)\n```\nAs recommended by the scvelo tutorial, perform the following steps to compute RNA velocity:\n```Python\n# Python\nscv.pp.filter_and_normalize(merged_data)\nscv.pp.moments(merged_data)\nscv.tl.velocity(merged_data, mode='stochastic')\nscv.tl.velocity_graph(merged_data)\n```\nIt is possible that not all barcodes had sufficient quality of both spliced and unspliced reads, and thus some cells may have been discarded during the merging process. To ensure your cell type labels are still maintained, export the merged data observations from the merged scvelo object to a CSV file.\n```Python\n# Python\nmerged_data.obs.to_csv('merged_data_obs.csv')\n```\nIn R, load this CSV file in and extract the RCA labels and filter only those which were considered in the merged data by scvelo.\n```R\n# R\nmerged_data_obs <- read.csv(file = \"merged_data_obs.csv\", row.names = 1)\nrca_clusters <- rca_obj$clustering.out$dynamicColorsList$Clusters\nnames(rca_clusters) <- colnames(rca_obj$raw.data)\nrca_clusters <- rca_clusters[rownames(merged_data_obs)]\n```\n**Note: If your cell names have underscores in them, scanpy will automatically split the cell name into barcode and sample_batch.**\nIn this case, replace the last line of the above block of code with the following:\n```R\n# R\nmerged_barcodes <- paste0(merged_data_obs$sample_batch, rownames(merged_data_obs))\nrca_clusters <- rca_clusters[merged_barcodes]\n```\nNow export these cluster labels to a CSV file.\n```R\n# R\nrca_cluster_df <- data.frame(Clusters = rca_clusters)\nwrite.table(x = rca_cluster_df, file = \"rca_cluster_df.csv\", append = FALSE, quote = FALSE, col.names = T, row.names = F, sep = \",\")\n```\nBack in the scvelo iPynb, load this RCA cluster annotation table and set it as the observation slot of your merged data.\n```Python\n# Python\nrca_clusters = pd.read_csv('rca_cluster_df.csv')\nmerged_data.obs = rca_clusters\n```\nNow, it's finally time to visualize the RNA velocity results. There are 3 visualization options provided by scvelo, namely velocity_embedding, velocity_embedding_grid and velocity_embedding_stream. Use them as demonstrated below\n```Python\n# Python\n### Velocity embedding\nscv.pl.velocity_embedding(merged_data, basis='umap', color = ['Clusters'], legend_loc = 'right margin', palette = 'tab20', figsize = (10,10), save = 'embedding.png')\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/prabhakarlab/RCAv2/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "Other",
        "spdx_id": "NOASSERTION",
        "type": "License",
        "url": null,
        "value": null
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "USER LICENSE for the software suite RCAv2\n\nAuthorship and Copyright (c) \n2022; Shyam Prabhakar, Shyam's Lab\n\nReferences of associated scientific publications\n1) Li, Huipeng, et al. \"Reference component analysis of single-cell transcriptomes elucidates cellular heterogeneity in human colorectal tumors.\" Nature genetics 49.5 (2017): 708-718. DOI: 10.1038/ng.3818. \n\n2) Schmidt, Florian, et al. \"RCA2: a scalable supervised clustering algorithm that reduces batch effects in scRNA-seq data.\" Nucleic Acids Research 49.15 (2021): 8505-8519. DOI: 10.1093/nar/gkab632.\n\n***\n\nShyam Prabhakar\nprabhakars@gis.a-star.edu.sg\nGenome Institute of Singapore, 60 Biopolis Street, Singapore 138672\n\nShyam's Lab\nshyam_lab@gis.a-star.edu.sg\nGenome Institute of Singapore, 60 Biopolis Street, Singapore 138672\n\n***\n\nLicense conditions\n\n1. Definitions\n\n\u201cAuthor\u201d refers to the person(s) that hold the authors\u2019 rights or to an organization that has been entitled by them or their employer during the work on the software suite to protect the respective rights and to issue user licenses. \n\n\u201cSoftware\u201d includes all program or database files as well as associated documentation files together with this license document. \n\nThis license refers to the software suite in the title of this document with all its author\u2019s versions. This includes the newest one and any preceding version - be it in \u201csource code form\u201d (the preferred form of the work for making modifications to it) or \u201cobject form\u201d (any compiled/executable version of it). This license covers both the whole software as well as any part of it. It is applicable to the standalone versions of this software as well as its incorporation as integral part into other software packages. \n\n\u201cUser\u201d is the licensee of this software. \n\n2. Copyright notice\n\nAll rights are reserved, whether the whole or part of the software is concerned. The software may not be used or distributed without specific, prior written permission of the author beyond the exceptions described in this license. \n\nThis especially concerns respecting the authors\u2019 rights. The user will always refer to the authors, their publications and this software package when communicating about this software, any of its modifications or about results obtained with this software. \n\nThe copyright messages (if any) will not be modified or suppressed. The software package will always remain associated with this license agreement.\n\n3. Academic (non-commercial) usage\n\nPermission is hereby granted, free of charge for academic purposes, to obtaining a copy of this software, to use, copy, modify it and to integrate it into other software within the same research team and its immediate collaborators, to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission/license notice shall be included in all copies or substantial portions of the Software. \n\nThe user will not redistribute this software beyond the range allowed in this academic license exception but refer the interested party to the author and/or its distribution site. \n\n4. Commercial usage\n\nThe usage of this software in commercial activities is not allowed without a prior written commercial licence agreement issued by the author. \n\nAny software package that contains this software or parts of it can only be commercialized with a license agreement issued by the author. \n\n5. Bugs and other erroneous behaviour of the software\n\nThe user will report bugs and errors observed in using the software to the author as soon as possible, without delay. \n\nThe author will provide software user support, maintenance and software updates on a good will basis. \n\n6. Warranty and liability\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \nIN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING OUT OF OR IN CONNECTION WITH THE USE, PERFORMANCE OF THIS SOFTWARE OR ANY OTHER DEALINGS WITH IT, WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY. \n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/LICENSE",
      "technique": "file_exploration"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "RCAv2"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "User",
        "value": "prabhakarlab"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "R",
        "size": 198721,
        "type": "Programming_language",
        "value": "R"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "related_documentation": [
    {
      "confidence": 1,
      "result": {
        "format": "readthedocs",
        "type": "Url",
        "value": "https://scvelo.readthedocs.io/"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "somef_missing_categories": [
    "acknowledgement",
    "run",
    "download",
    "requirements",
    "contact",
    "contributors",
    "documentation",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-10-06 05:24:15",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 34
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Compute enrichment for GO terms and KEGG pathways",
        "parent_header": [
          "RCA version 2.0",
          "A beginner's guide to RCA"
        ],
        "type": "Text_excerpt",
        "value": "Using the *clusterProfiler* package, RCAv2 supports enrichment tests for GO terms and KEGG pathways using the\nfunctions *doEnrichGo* and *doEnrichKEGG*, respectively. Both require the parameter *annotation* to be set, which\nis needed both for ID mapping and GO-term assignment. An example for an annotation for human is the *org.Hs.eg.db* available at\nBioconductor.\n\nTo compute GO enrichment for all identified RNA-seq clusters, call the function:\n```R\ndoEnrichGo<-function(rca.obj,\n                    annotation=NULL,\n                    ontology=\"BP\",\n                    p.Val=0.05,\n                    q.Val=0.2,\n                    p.Adjust.Method=\"BH\",\n                    gene.label.type=\"SYMBOL\",\n                    filename=\"GoEnrichment.pdf\",\n\t\t    background.set=\"ALL\",\n                    background.set.threshold=NULL,\n                    n.Cells.Expressed=NULL,\n                    cluster.ID=NULL,\n                    deep.split=NULL)\n```\nwhere ontology is either *BP, MF* or *CC*, *p.Val* and *q.Val* are thresholds used by clusterprofiler, and *p.Adjust.Method* indicates which method is used to correct for multiple testing.\nFor greater user convenience, the function automatically maps geneIDs. To this end, the *gene.label.type* holds the type of the original labels. In concordance with 10X data, this is set to SYMBOL by default. \nThe background set is either based on all clusters or only on the investigated one. Cells are selected either via the *background.set.threshold* or the *n.Cells.Expressed\" parameter. Note that the former is either a numerical value or one of the following: Min, 1stQ, Mean, Median, 3thQ. Those thresholds are computed for the distribution of all mean expression values of all genes.\nThe parameter *cluster.ID* can be set if the anaysis should be performed for only one particular cluster, the value of *deep.split* can be specified to select a custom split in case hierarchical clustering has been used.\n\nThe doEnrichGo functions generates barplots, goplots and dotplots for each cluster separately. The filenames can be modified using the *filename* parameter. Example barplots and dotplots are shown for a PBMC NK-cell cluster. Goplots are depicted for a PBMC B-cell.\n\n![](man/figures/RCA_GO_Example.png)\n\n\nTo perform enrichment against KEGG pathways, the *doEnrichKEGG function* can be used:\n```R\ndoEnrichKEGG<-function(rca.obj,\n                     annotation=NULL,\n                     org=\"hsa\",\n                     key=\"kegg\",\n                     p.Val=0.05,\n                     q.Val=0.2,\n                     p.Adjust.Method=\"BH\",\n                     gene.label.type=\"SYMBOL\",\n                     filename=\"KEGGEnrichment.pdf\",\n\t\t     background.set=\"ALL\",\n                     background.set.threshold=NULL,\n                     n.Cells.Expressed=NULL,\n                     cluster.ID=NULL,\n                     deep.split=NULL)\n```\nThe parameters are similar to the GO enrichment function except for the *org* parameter, which must represent an organism supported by KEGG. This is set to *hsa* for homo sapiens by default.\nNote that the KEGG function does not generate goPlots but only bar- and dotplots. An example for NK cells is shown below.\n\n![](man/figures/RCA_KEGG_Example.png)\n"
      },
      "source": "https://raw.githubusercontent.com/prabhakarlab/RCAv2/master/README.md",
      "technique": "header_analysis"
    }
  ]
}
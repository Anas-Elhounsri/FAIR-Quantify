{
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/CahanLab/epoch"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2019-06-04T19:19:29Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-09-26T15:56:24Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "gene regulatory network reconstruction from scRNA-Seq"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Introduction",
        "parent_header": [
          "Epoch"
        ],
        "type": "Text_excerpt",
        "value": "Epoch leverages single-cell transcriptomic data, single-cell analysis methods, and graph theoretic approaches to reconstruct dynamic GRNs. Additionally, Epoch contains functionality for top regulator prediction, network comparision, signaling pathway integration, amongst others. Here we show some examples of Epoch in action.\n\nFor a more in depth look at Epoch, and to see how we applied it to elucidate signaling-induced GRN topology changes in early mouse embryonic stem cell (ESC) directed differentiation, check out our [publication here][1].\n\n[1]: https://www.cell.com/stem-cell-reports/fulltext/S2213-6711(21)00657-3\n\n\n1. [Setup](#setup)\n2. [Example 1: Reconstruction](#example1)\n3. [Example 2: Network Comparison](#example2)\n4. [Example 3: Signaling Pathway Integration](#example3)\n\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.861825566859865,
      "result": {
        "original_header": "Epoch",
        "type": "Text_excerpt",
        "value": "Dynamic gene regulatory network reconstruction from scRNA-seq data. \n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/pcahan1/epoch/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 12
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/CahanLab/epoch/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "CahanLab/epoch"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "Epoch"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "images": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/pcahan1/epoch/master/img/example1_heatmapTFs.png"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/pcahan1/epoch/master/img/example1_topregulators.png"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/pcahan1/epoch/master/img/example1_regulatorsoftargets.png"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/pcahan1/epoch/master/img/example2_network1_on.png"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/pcahan1/epoch/master/img/example3_WNT_heatmap.png"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Setup <a name=\"setup\"></a>",
        "parent_header": [
          "Epoch"
        ],
        "type": "Text_excerpt",
        "value": "```R\ndevtools::install_github(\"pcahan1/epoch\")\nlibrary(epoch)\n\n```\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/CahanLab/epoch/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "MIT License",
        "spdx_id": "MIT",
        "type": "License",
        "url": "https://api.github.com/licenses/mit",
        "value": "https://api.github.com/licenses/mit"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "MIT License\n\nCopyright (c) 2021 Patrick Cahan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/LICENSE",
      "technique": "file_exploration"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "epoch"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "Organization",
        "value": "CahanLab"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "R",
        "size": 153420,
        "type": "Programming_language",
        "value": "R"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "somef_missing_categories": [
    "citation",
    "acknowledgement",
    "run",
    "download",
    "requirements",
    "contact",
    "contributors",
    "documentation",
    "faq",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-10-06 07:11:36",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 23
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Data",
        "parent_header": [
          "Epoch",
          "Example 3: Signaling Pathway Integration <a name=\"example3\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "Epoch reconstructs networks from single-cell RNA-sequencing data. \n\nThis data is sampled from day 0 through day 4 mESC directed differentiation toward mesodermal fate guided by Wnt3a, Activin A, and GSKi. It has already been normalized, and the varying genes have been identified. It has also been clustered, and analyzed with RNA Velocity.\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Load data",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "```R\nlibrary(epoch)\n\nlist12<-loadDataFromLoom(\"data/sampled_mesoderm_WAG.loom\")\nexpDat<-list12[['expDat']]\nsampTab<-list12[['sampTab']] \n\nmmTFs<-utils_loadObject(\"data/mmTFs.rda\")\nmmTFs<-intersect(rownames(expDat),mmTFs)\n\n# Note: 'loadDataFromLoom' uses loomR, and is sensitive to the version\n# when calling lfile$get.attributes.df(). Versions of loomR that accept \n# parameters 'attributes' or 'attribute.names' in get.attributes.df()\n# are supported here. Future versions may require some adjustment.\n\n```\nNow, expDat contains the normalized and log-transformed gene-by-cell expression data, and sampTab contains the corresponding metadata, including pseudotime annotation.\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Static Network Reconstruction",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "Reconstruction occurs in three steps: \n\n1. Find dynamically expressed genes\n2. Infer edges across dynamic genes using CLR (or other supported method)\n3. Perform optional cross-weighting to refine network structure\n  \n```R\n# Find dynamically expressed genes\nxdyn <- findDynGenes(expDat, sampTab, group_column=\"cluster\", pseudotime_column=\"latent_time\")\npThresh<-0.05\ndgenes<-names(xdyn$genes)[xdyn$genes<pThresh]\n\n# Reconstruct and perform crossweighting\ngrnDF <- reconstructGRN(expDat, mmTFs, dgenes, method=\"pearson\", zThresh=3)\ngrnDF <- crossweight(grnDF,expDat,xdyn,filter_thresh=0)\n\n# Example alternative: to reconstruct using GENIE3, run reconstructGRN_GENIE3 prior to crossweighting.\n# grnDF <- reconstructGRN_GENIE3(expDat, mmTFs, dgenes, weightThresh=.5)\n\n```\nNote: To use Mutual Information, set method to \"MI\". Set zThresh and filter_thresh to tune interactions via removing edges below the threshold.\n\n\nThe object grnDF contains the reconstructed network. TG and TF refer to target gene and transcription factor respectively. The column \"zscore\" is the network prior to crossweighting. The column \"weighted_score\" is the network after crossweighting:\n\n```R\ngrnDF[5:15,]\n\n#        TG     TF   zscore       corr     offset weighted_score\n# 5  Prdm14   Nfib 3.846711  0.2371545  3.0895522       3.846711\n# 6  Prdm14 Zfp990 3.390523  0.2574008  3.7761194       3.390523\n# 7  Prdm14   Rest 3.102711  0.2485766  1.7761194       3.102711\n# 8  Prdm14  Nanog 4.598733  0.2892227 11.4776119       2.896073\n# 9  Prdm14  Tead2 3.114365 -0.2491080  7.1492537       3.114365\n# 10 Prdm14  Zfp42 5.641972  0.3185379 -0.6865672       5.641972\n# 11 Prdm14   Klf2 3.344418  0.2563452  0.9104478       3.344418\n# 12 Prdm14  Rhox6 3.648716  0.2528058 -8.4477612       3.648716\n# 13   Eya1  Hoxb4 3.133878  0.1504617 11.7313433       1.947923\n# 14   Eya1   Gli3 4.176600  0.1663259  5.5671642       4.176600\n# 15   Eya1  Foxc1 3.976296  0.1660566  3.3582090       3.976296\n\n```\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Dynamic Network Extraction",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "We can further explore changes in the network across time by defining \"epochs\" or time periods in our trajectory, assigning genes to these epochs, and extracting a dynamic network across time.  \n\nDefining epochs can be done in a number of ways. Here we show an example with method=\"pseudotime\". This will partition cells based on pseudotime (pseudotime will be divided evenly, unless specified with parameter psuedotime_cuts). The following sets of parameters are alternative methods of defining epochs:\n\n* __method = \"pseudotime\", num_epochs = n__ : This will divide pseudotime evenly, and paritition the cells into n epochs.\n* __method = \"pseudotime\", pseudotime_cuts = c(a,b)__ : This will partition by cells by pseudotime, cutting pseudotime at a and b. The resulting number of epochs is length(pseudotime_cuts)+1.\n* __method = \"cell_order\", num_epochs = n__ : This will evenly partition cells based on raw cell order.\n* __method = \"group\", group_assignment = L__ : This will partition cells into pre-defined epochs. L is a list describing the assignment. names(L) correspond to epoch names; elements in L are vectors containing groups in dynRes$cells$group.\n* __method = \"con_similarity\"__ : This will automatically detect epochs based on consecutive similarity (i.e. measures correlation between groups of cells along a sliding window across pseudotime). This method does not require specifying num_epochs.\n* __method=\"kmeans\", num_epochs = n__ : This will automatically detect epochs based on k-means clustering.\n* __method=\"hierarchical\", num_epochs = n__ : This will automatically detect epochs based on hierarchical clustering.\n  \n\n\"con_similarity\", \"kmeans\", and \"hierarchical\" call functions \"find_cuts_by_similarity\" and \"find_cuts_by_clustering\". You can refine the epoch definitions by employing these two functions separately and using the psuedotime cuts they return in the second method described above. \n\nAdditionally, define_epochs takes as input the expression matrix. For smoother epoch definitions, you can optionally pass a smoothed expression matrix instead. Smoothing can be done using the function grnKsmooth. See [plotting dynamically expressed genes](#plotdyngenes) for an example.\n\nFor a simpler approach, assign_epoch_simple() will define and assign epochs based on maximum mean expression of a gene. However, unlike the standard approach, this approach assumes genes cannot belong to more than one epoch.\n\n```R\nxdyn<-define_epochs(xdyn,expDat,method=\"pseudotime\",num_epochs=3)\nepoch_assignments<-assign_epochs(expDat,xdyn)\n\ndynamic_grn<-epochGRN(grnDF,epoch_assignments)\n\n#     from     to           name\n# 1 epoch1 epoch2 epoch1..epoch2\n# 2 epoch2 epoch3 epoch2..epoch3\n# 3 epoch1 epoch1 epoch1..epoch1\n# 4 epoch2 epoch2 epoch2..epoch2\n# 5 epoch3 epoch3 epoch3..epoch3\n\n\n# Example alternative:\n# assignment_list<-assign_epochs_simple(expDat[dgenes,],xdyn)\n\n# Another example alternative:\n# ccells <- xdyn$cells\n# expSmoothed <- grnKsmooth(expDat, ccells, BW=0.02)\n# xdyn <- define_epochs(xdyn,expSmoothed,method=\"kmeans\",num_epochs=3)\n\n```\n  \n  The object dynamic_grn stores the dynamic network across epochs. The list includes active subnetworks at each epoch (in this example, \"epoch1..epoch1\",\"epoch2..epoch2\", etc.) as well as potential transition networks (in this example, \"epoch1..epoch2\" and \"epoch2..epoch3\") describing how network topology transitions from one epoch to another.\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Influential TFs",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "We can use Epoch to identify the most influential regulators in the reconstructed dynamic (or static) network. Here's an example of accomplishing this via a PageRank approach on the dynamic network. \n\n```R\ngene_rank<-compute_pagerank(dynamic_grn,weight_column=\"weighted_score\")\n\n```\n  \n  The object gene_rank now contains a list of rankings for each epoch and transition network:\n  \n```R\nhead(gene_rank$epoch1..epoch1)\n#          gene  page_rank is_regulator\n# Utf1     Utf1 0.03967890         TRUE\n# Zfp42   Zfp42 0.03151797         TRUE\n# Klf2     Klf2 0.03036168         TRUE\n# Sox2     Sox2 0.02456489         TRUE\n# Tead2   Tead2 0.01598365         TRUE\n# Arid5b Arid5b 0.01581432         TRUE\n\nhead(gene_rank$epoch3..epoch3)\n#        gene  page_rank is_regulator\n# Tead2 Tead2 0.02687836         TRUE\n# Sox11 Sox11 0.02512396         TRUE\n# Rest   Rest 0.01709808         TRUE\n# Peg3   Peg3 0.01599903         TRUE\n# Basp1 Basp1 0.01265988         TRUE\n# Meis2 Meis2 0.01253277         TRUE\n\n```\n  \n  We can also use betweenness and degree. \n\n```R\nanother_gene_rank<-compute_betweenness_degree(dynamic_grn,weight_column=\"weighted_score\")\n\n```\nThe object another_gene_rank now contains a list of rankings for each epoch and transition network:\n  \n```R\nhead(another_gene_rank$epoch1..epoch1)\n#        gene betweenness     degree is_regulator\n# Utf1   Utf1  0.27817182 0.42617801         TRUE\n# Sox2   Sox2  0.27811474 0.39581152         TRUE\n# Klf2   Klf2  0.15267323 0.45863874         TRUE\n# Zfp42 Zfp42  0.12816798 0.45026178         TRUE\n# Tead2 Tead2  0.09685535 0.26387435         TRUE\n# Tgif1 Tgif1  0.16497086 0.04397906         TRUE\n\n```\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Some Useful functions for networks",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "Here are some useful functions for understanding details of reconstructed networks.\n\nFirst, we can add in the interaction type (also automatically added in plotting functions). This works on both static and dynamic GRNs.\n```R\ndynamic_grn<-add_interaction_type(dynamic_grn)\n#grnDF<-add_interaction_type(grnDF)\n\nhead(dynamic_grn$epoch2..epoch2)\n#        TG    TF   zscore       corr    offset weighted_score interaction\n# 4  Prdm14 Basp1 3.096282 -0.2482408  5.164179       3.096282  repression\n# 7  Prdm14  Rest 3.102711  0.2485766  1.776119       3.102711  activation\n# 9  Prdm14 Tead2 3.114365 -0.2491080  7.149254       3.114365  repression\n# 18 Ptp4a1  Lhx1 3.288639  0.1531601 -6.074627       3.288639  activation\n# 19 Ptp4a1 Gata4 3.975216  0.1649048 13.432836       2.252686  activation\n# 23 Sema4c  Sox4 3.009982  0.2526573  7.701493       3.009982  activation\n\n```\n\nWe can apply community detection to these networks. This is particularly useful when examining mean module expression (see below). This works on both static and dynamic GRNs.\n```R\ncommunity_assignments<-find_communities(dynamic_grn)\n#community_assignments<-find_communities(grnDF)\n\nhead(community_assignments$epoch3..epoch3)\n#            gene communities\n# 1        Prdm14           2\n# 2          Eya1           3\n# 3        Ptp4a1           3\n# 4        Sema4c           2\n# 5 1700019D03Rik           5\n# 6          Fzd5           1\n\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Plotting",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "Epoch contains various plotting tools to visualize dynamic activity of genes and networks.\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "We can visualize dynamically expressed genes across time <a name=\"plotdyngenes\"></a>",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>",
          "Plotting"
        ],
        "type": "Text_excerpt",
        "value": "This is particularly useful for verifying epoch assignments, and gauging how many epochs should occur in a trajectory. Here we plot the expression of 50 TFs along pseudotime.\n\n```R\n# First, smooth expression for a cleaner plot\nccells <- xdyn$cells\nexpSmoothed <- grnKsmooth(expDat, ccells, BW=0.03)\n\n# Plot a heatmap of the dynamic TFs\ntfstoplot<-intersect(dgenes,mmTFs)\ndynTFs<-xdyn\ndynTFs$genes<-dynTFs$genes[names(dynTFs$genes) %in% tfstoplot]\nhm_dyn(expSmoothed,dynTFs,topX=50)\n\n# Plot a heatmap of all dynamic TFs and target genes\n# dyngenes<-xdyn\n# dyngenes$genes<-dyngenes$genes[names(dynTFs$genes) %in% dgenes]\n# hm_dyn(expSmoothed,dyngenes,topX=100)\n\n```\n<img src=\"img/example1_heatmapTFs.png\">\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "We can plot a basic plot of the dynamic network",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>",
          "Plotting"
        ],
        "type": "Text_excerpt",
        "value": "```R\nplot_dynamic_network(dynamic_grn,mmTFs,only_TFs=TRUE,order=c(\"epoch1..epoch1\",\"epoch2..epoch2\",\"epoch3..epoch3\"))\n\n```  \n  \n  To plot all targets, we can set only_TFs=FALSE. We can specify which epochs to plot using the \"order\" parameter. These coincide with names(dynamic_grn). If left empty, all epoch networks and transition networks will be plotted.  \n  \n  The same function can be used to plot a static network.  \n\n```R\nplot_dynamic_network(list(mesoderm_network=grnDF),mmTFs,only_TFs=TRUE)\n\n```\n\n  These may be cumbersome, so instead it may be useful to limit which interactions to plot. For example, we can limit the plot to edges with weight above a certain threshold, using the \"thresh\" parameter. Alternatively, it may be more informative to look at top regulators and their top targets:\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "We can plot the dynamic network with some more detail",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>",
          "Plotting"
        ],
        "type": "Text_excerpt",
        "value": "This function will color the nodes by community and optionally fade by betweenness. If the 'communities' parameter is not specified, 'find_communities' will be run to detect community structure.\n```R\nplot_dynnet_detail(dynamic_grn,tfs=mmTFs,only_TFs=TRUE,order=c(\"epoch1..epoch1\",\"epoch2..epoch2\",\"epoch3..epoch3\"),communities=NULL,compute_betweenness=TRUE)\n\n```  \n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "We can plot top regulators and their top targets",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>",
          "Plotting"
        ],
        "type": "Text_excerpt",
        "value": "In the same fashion as above, we can do this for both the dynamic network and static network. Limiting visualization to top regulators and their targets is less cumbersome than the above plots.\n\n```R\nplot_top_regulators(dynamic_grn, gene_rank, mmTFs, numTopTFs=6, only_TFs=FALSE,order=c(\"epoch1..epoch1\",\"epoch3..epoch3\"))\n\n# We can specify additional parameters including the number of top TFs and targets:\n# plot_top_regulators(dynamic_grn, gene_rank, tfs, numTopTFs=3, numTargets=5, only_TFs=TRUE, order=c(\"epoch1..epoch1\",\"epoch1..epoch2\",\"epoch2..epoch2\"))\n\n```\n<img src=\"img/example1_topregulators.png\">\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "We can plot top regulators of specified targets",
        "parent_header": [
          "Epoch",
          "Example 1: Reconstruction <a name=\"example1\"></a>",
          "Plotting"
        ],
        "type": "Text_excerpt",
        "value": "If we are interested in specific target genes, we can use one of the following functions to plot those and their top regulators as follows.\n\n```R\ninteresting_targets<-c(\"Mesp1\",\"Foxc1\",\"Tbx6\",\"Meis2\")\n\n# plot_targets_with_top_regulators(dynamic_grn,interesting_targets,weight_column=\"zscore\")\n\nplot_targets_with_top_regulators_detail(dynamic_grn,interesting_targets,epoch_assignments,weight_column=\"weighted_score\",numTopRegulators=3,declutter=FALSE,order=c(\"epoch2..epoch2\",\"epoch3..epoch3\"))\n\n\n```\n<img src=\"img/example1_regulatorsoftargets.png\">\n\n\n\n  "
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 2: Network Comparison <a name=\"example2\"></a>",
        "parent_header": [
          "Epoch"
        ],
        "type": "Text_excerpt",
        "value": "We can use Epoch to compare networks. Here's an example of doing so at the edge level. In this instance we use Epoch to extract \"differential networks\".  \n\n\nStarting with the network we reconstructed in Example 1, we can compare it to a network reconstructed using data collected from mESC directed differentiation toward mesoderm guided by a separate treatment. Alternatively, such a method may be used to compare in vitro networks with in vivo networks.\n\n\n### Data\n\nIn this section, Epoch requires at least two reconstructed networks (in order to carry out the comparison) and the epoch assignments for these networks. These inputs are derived from the reconstruction in the previous section.\n\nFirst, load in the data. The reconstructed network and epoch assignments from the previous section are provided here as 'net1' and epochs1': \n\n```R\n# load in the reconstructed network and epochs\nnet1<-utils_loadObject(\"data/example1_net.rda\")\nepochs1<-utils_loadObject(\"data/example1_epochs.rda\")\n\n# load in a second network and epochs\nnet2<-utils_loadObject(\"data/example2_net2.rda\")\nepochs2<-utils_loadObject(\"data/example2_epochs2.rda\")\n\nmmTFs<-utils_loadObject(\"data/mmTFs.rda\")\n\n```\n  \n  "
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Compute the differential network",
        "parent_header": [
          "Epoch",
          "Example 2: Network Comparison <a name=\"example2\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "We can compute the differential network between network1 (GRN reconstructed in Example 1) and network2 (GRN just loaded in).\n\n```R\n# Run edge_uniqueness to tally differences in edges\nres<-edge_uniqueness(list(network1=net1,network2=net2),mmTFs,weight_column=\"weighted_score\")\n\n# Run dynamic_difference_network to extract the dynamic differential network\nnetwork1_on<-dynamic_difference_network(res, list(network1=epochs1,network2=epochs2), \"network1\", type=\"on\", diff_thresh=7.5, condition_thresh=10)\n\n# Add interaction type\nnetwork1_on<-add_type(network1_on,\"on\",net1,list(x=net2))\n\n\n``` \nThe edges in the resulting differential network are those that are differentially active in network 1.\nWe can tune the threshold \"diff_thresh\" to increase or decrease the difference threshold at which an edge is considered differentially active. We can tune the threshold \"condition_thresh\" to change the threshold at which an edge is considered active in a given network.\n\nThe weight_column parameter in edge_uniquness can be changed to reflect the proper edge weight. For example, other metrics of importance can be used in place of the crossweighted score, such as degree product. \n\nThis is what the differential network looks like:\n\n```R\nhead(network1_on$epoch2)\n#              TG     TF network1     diff       corr interaction\n# 1 1700003F12Rik   Nfia 4.666154 4.666154  0.2032498  activation\n# 2 1700019D03Rik   Peg3 3.126144 2.746125 -0.3131408  repression\n# 3 1700019D03Rik    Sp5 3.168844 3.003888 -0.3071091  repression\n# 4 1700097N02Rik  Basp1 4.037780 2.194030 -0.4412966  repression\n# 5 1700097N02Rik   Sox4 3.409004 2.396285 -0.4235951  repression\n# 6 1700097N02Rik Zfp428 4.664102 2.319699  0.3700874  activation\n\nhead(network1_on$epoch3)\n#              TG     TF network1     diff       corr interaction\n# 1 1700003F12Rik Mllt11 3.737788 3.513406  0.1830396  activation\n# 2 1700019D03Rik   Peg3 3.126144 2.746125 -0.3131408  repression\n# 3 1700019D03Rik    Sp5 3.168844 3.003888 -0.3071091  repression\n# 4 1700097N02Rik  Basp1 4.037780 2.194030 -0.4412966  repression\n# 5 1700097N02Rik    Id2 3.039247 2.389706 -0.2079808  repression\n# 6 1700097N02Rik   Sox4 3.409004 2.396285 -0.4235951  repression\n\n```\n\n  "
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Find communities",
        "parent_header": [
          "Epoch",
          "Example 2: Network Comparison <a name=\"example2\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "We can find community structure within the differential network (or other dynamic network). (Also mentioned above)\n```R\ncommunities<-find_communities(network1_on)\n\n```\n  \n  "
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Plot the differential network",
        "parent_header": [
          "Epoch",
          "Example 2: Network Comparison <a name=\"example2\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "We can plot the differential network, with or without some details (e.g. colored by cluster, faded by betweenness). Tune threshold parameters when calling dynamic_difference_network to change strictness of including or not including an edge. Here's what the third epoch looks like (with relatively strict thresholds for readability), using two separate methods:\n\n```R\n# plot_dyn_diffnet(network1_on,mmTFs,only_TFs=TRUE)\n\nplot_diffnet_detail(network1_on,tfs=mmTFs,order=c(\"epoch3\"),weight_column=\"network1\")\n\n```\n\n<img src=\"img/example2_network1_on.png\">\n\nThe above plotting will re-find clusters via Louvain clustering. Alternatively, we can use the earlier plotting function 'plot_dynnet_detail'. This function is more general, and allows us to specify a community assignment to use. For example:\n```R\n\nplot_dynnet_detail(network1_on,tfs=mmTFs,order=c(\"epoch3\"),weight_column=\"network1\",communities=communities,compute_betweenness=TRUE)\n\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 3: Signaling Pathway Integration <a name=\"example3\"></a>",
        "parent_header": [
          "Epoch"
        ],
        "type": "Text_excerpt",
        "value": "We can use Epoch to integrate signaling activity and trace paths through the network. Starting with the dynamic network we constructed in Example 1. \n\n### Data\n\nIn this section, Epoch requires a reconstructed network (which can be derived from [Example 1: Reconstruction](#example1). As described below, Epoch will also require pre-computed effector targets. \n\n\n```R\nlist12<-loadDataFromLoom(\"data/sampled_mesoderm_WAG.loom\")\nexpDat<-list12[['expDat']]\nsampTab<-list12[['sampTab']] \n\ndynamic_grn<-utils_loadObject(\"data/example1_dyanmicGRN.rda\")\n\nxdyn <- findDynGenes(expDat, sampTab, group_column=\"cluster\", pseudotime_column=\"latent_time\")\n\n```\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Get effector targets",
        "parent_header": [
          "Epoch",
          "Example 3: Signaling Pathway Integration <a name=\"example3\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "Effector targets of major signaling pathways are pre-computed and available within Epoch (mouse: see 'data/effectortargets_mouse.rda').\nThese lists were computed by: (1) aquiring binding score (MACS2) data for 18 signaling effector TFs from the ChIP-Atlas (Oki et al., 2018), (2) target genes were ranked by maximum binding score, (3) the top 2000 targets were retained (or all retained, if less than 2000 targets).\n\n  Alternatively, here's how we can derive new effector target lists:\n\n```R\neffectors<-load_SP_effectors(path=\"data/mouse_signaling_binding\")\neffectors<-score_targets(effectors)\neffectortargets<-find_targets(effectors,column=\"max_score\",by_rank=TRUE,n_targets=2000)\n\n# Instead of \"max_score\", we could have also ranked by \"mean_score\" or \"percent_freq\".\n# Instead of retaining the top n_targets, we could have also specified a cutoff threshold by specifying the 'threshold' parameter.\n\n```\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Signaling pathway activity",
        "parent_header": [
          "Epoch",
          "Example 3: Signaling Pathway Integration <a name=\"example3\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "We can estimate signaling activity over time by quantifying the expression of effector targets. As an example, let's look at Wnt signaling. Unsurprisingly, we see strong activity as cells progress toward mesodermal fate. \n\nAlternatively, we could instead look at all pathways to understand differences in major signaling pathways between treatments, conditions, etc. (See manuscript for details)\n\n```R\n# Wnt signaling\nwnt_targets<-effectortargets[c(\"WNT_Ctnnb1\",\"WNT_Lef1\",\"WNT_Tcf7\",\"WNT_Tcf7l2\")]\n\n# lets separate by pre-treatment and treatment\n# adding in the treatment information\nccells<-xdyn$cells\nccells$treatment<-sampTab$treatment[match(as.character(ccells$cell_name),as.character(sampTab$obs_names))]\n\n# compute mean module expression over time\npre_exp<-mean_module_expression(expDat[,rownames(ccells[ccells$treatment=='pre',])],wnt_targets)\ntreatment_exp<-mean_module_expression(expDat[,rownames(ccells[ccells$treatment=='WAG',])],wnt_targets)\n\nheatmap_by_treatment_group(list(pre=pre_exp,treatment=treatment_exp),sampTab,pseudotime_column=\"latent_time\",limits=c(0,3),order_by=\"treatment\")\n\n```\n\n<img src=\"img/example3_WNT_heatmap.png\">\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Paths toward target genetic programs",
        "parent_header": [
          "Epoch",
          "Example 3: Signaling Pathway Integration <a name=\"example3\"></a>"
        ],
        "type": "Text_excerpt",
        "value": "Now that we have reconstructed a dynamic network and predicted effector target genes, we can integrate signaling pathway activity with the GRN. For example, we can trace the effects of Wnt signaling in activating a mesoderm-like program (or simply, some genes of interest). \n\n\n```R\n# Some interesting mesoderm TFs, plus Sox17 (an endoderm TF)\ninteresting_genes<-c(\"Mesp1\",\"Foxc1\",\"Foxc2\",\"Tbx6\",\"Sox17\")\n\n# Paths from b-catenin to interesting genes\nbcat_to_meso<-dynamic_shortest_path_multiple(dynamic_grn,effectortargets$WNT_Ctnnb1,interesting_genes)\nbcat_to_meso<-cor_and_add_action(bcat_to_meso,expDat)\n\n# Paths from Tcf7 to interesting genes\ntcf7_to_meso<-dynamic_shortest_path_multiple(dynamic_grn,effectortargets$WNT_Tcf7,interesting_genes)\ntcf7_to_meso<-cor_and_add_action(tcf7_to_meso,expDat)\n\n# Paths from Tcf7l2 to interesting genes\ntcf7l2_to_meso<-dynamic_shortest_path_multiple(dynamic_grn,effectortargets$WNT_Tcf7l2,interesting_genes)\ntcf7l2_to_meso<-cor_and_add_action(tcf7l2_to_meso,expDat)\n\n```\n\nHere's what this looks like:\n```R\nhead(tcf7l2_to_meso)\n\n#     from    to                     path distance action distance_over_average action_by_corr\n# 1 Zfp703 Mesp1      Zfp703--Peg3--Mesp1 1.815449      1             0.6427952              1\n# 2 Zfp703 Foxc1      Zfp703--Hey1--Foxc1 1.784579      1             0.6318649              1\n# 3 Zfp703 Foxc2    Zfp703--Notch1--Foxc2 1.755712      1             0.6216439              1\n# 4 Zfp703  Tbx6       Zfp703--Lmo2--Tbx6 1.794707      1             0.6354509              1\n# 5   Mtf2 Mesp1        Mtf2--Utf1--Mesp1 1.907707     -1             0.6754609             -1\n# 6   Mtf2 Foxc1 Mtf2--Utf1--Mesp1--Foxc1 2.747748     -1             0.9728935             -1\n\n```\n\nTF's in the column 'from' are targets of the effector TF Tcf7l2. Genes in the column \"to\" are targets from interesting_genes. The column 'path' describes the shortest path through the reconstructed network. The column 'distance_over_average' is the normalized distance (paths with values < 1 are shorter than the average path length).\n\nOverly long paths and infinite-length paths (i.e. no path exists), indicate a network topology in which activation or inhibition of the given signaling pathway cannot easily control the given target. For example, unsurprisingly, Sox17 (an endoderm marker) is not reachable from any Wnt effector in this mesodermal network:\n\n```R\nbcat_to_meso[tcf7l2_to_meso$to==\"Sox17\",]\n# [1] from                  to                    path                  distance             \n# [5] action                distance_over_average action_by_corr       \n# <0 rows> (or 0-length row.names)\n\ntcf7_to_meso[tcf7l2_to_meso$to==\"Sox17\",]\n# [1] from                  to                    path                  distance             \n# [5] action                distance_over_average action_by_corr       \n# <0 rows> (or 0-length row.names)\n\ntcf7l2_to_meso[tcf7l2_to_meso$to==\"Sox17\",]\n# [1] from                  to                    path                  distance             \n# [5] action                distance_over_average action_by_corr       \n# <0 rows> (or 0-length row.names)\n\n\n```\n\nBy applying this method to dynamic networks reconstructed from different datasets, it's possible to elucidate topologies unsuitable or restrictive to specific cell fates. By apply this method more broadly via exhaustive search of paths from all major signaling effectors to specific sets of targets, it's possible to predict the necessary signaling activity required for directing specific cell fates. \n\n(For more info on how we used this method to elucidate network topologies favoring mesodermal fate, to compare how activation and suppression of different signaling pathways impacts network topology, and a more in depth analysis on tracing paths from signaling effectors to target genes, see our [manuscript](https://www.biorxiv.org/content/10.1101/2021.05.06.443021v2)).\n\n\n\n\n\n\n\n\n"
      },
      "source": "https://raw.githubusercontent.com/pcahan1/epoch/master/README.md",
      "technique": "header_analysis"
    }
  ]
}
{
  "acknowledgement": [
    {
      "confidence": 1,
      "result": {
        "original_header": "<a name=\"wfa2.ack\"></a> 7. ACKNOWLEDGEMENTS",
        "parent_header": [
          "WFA2-lib"
        ],
        "type": "Text_excerpt",
        "value": "- Baoxing Song and Buckler's lab for their interest and help promoting the WFA and pushing for the inclusion of new features.\n\n- Juan Carlos Moure and Antonio Espinosa for their collaboration and support of this project.\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "header_analysis"
    }
  ],
  "application_domain": [
    {
      "confidence": 33.14,
      "result": {
        "type": "String",
        "value": "Natural Language Processing"
      },
      "technique": "supervised_classification"
    }
  ],
  "citation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "<a name=\"wfa2.cite\"></a> 8. CITATION",
        "parent_header": [
          "WFA2-lib"
        ],
        "type": "Text_excerpt",
        "value": "**Santiago Marco-Sola, Juan Carlos Moure, Miquel Moreto, Antonio Espinosa**. [\"Fast gap-affine pairwise alignment using the wavefront algorithm.\"](https://doi.org/10.1093/bioinformatics/btaa777). Bioinformatics, 2020.\n\n**Santiago Marco-Sola, Jordan M Eizenga, Andrea Guarracino, Benedict Paten, Erik Garrison, Miquel Moreto**. [\"Optimal gap-affine alignment in O(s) space\"](https://doi.org/10.1093/bioinformatics/btad074). Bioinformatics, 2023.\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "header_analysis"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/smarco/WFA2-lib"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2021-06-13T13:32:11Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-09-07T20:44:53Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "WFA-lib: Wavefront alignment algorithm library v2"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "1.1 What is WFA?",
        "parent_header": [
          "WFA2-lib",
          "1. INTRODUCTION"
        ],
        "type": "Text_excerpt",
        "value": "The wavefront alignment (WFA) algorithm is an **exact** gap-affine algorithm that takes advantage of homologous regions between the sequences to accelerate the alignment process. Unlike traditional dynamic programming algorithms that run in quadratic time complexity, the WFA runs in time `O(ns+s^2)`, proportional to the sequence length `n` and the alignment score `s`, using `O(s^2)` memory (or `O(s)` using the ultralow/BiWFA mode). Moreover, the WFA algorithm exhibits simple computational patterns that the modern compilers can automatically vectorize for different architectures without adapting the code. To intuitively illustrate why the WFA algorithm is so interesting, look at the following figure. The left panel shows the cells computed by a classical dynamic programming based algorithm (like Smith-Waterman or Needleman Wunsch). In contrast, the right panel shows the cells computed by the WFA algorithm to obtain the same result (i.e., the optimal alignment).\n\n<p align = \"center\">\n<img src = \"img/wfa.vs.swg.png\" width=\"750px\">\n</p>\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "1.2 What is WFA2-lib?",
        "parent_header": [
          "WFA2-lib",
          "1. INTRODUCTION"
        ],
        "type": "Text_excerpt",
        "value": "The WFA2 library implements the WFA algorithm for different distance metrics and alignment modes. It supports various [distance functions](#wfa2.distances) (e.g., indel, edit, gap-linear, gap-affine, and dual-gap gap-affine). The library allows computing only the score or the complete alignment (i.e., CIGAR) (see [Alignment Scope](#wfa2.scope)). Also, the WFA2 library supports computing end-to-end alignments (a.k.a. global-alignment) and ends-free alignments (including semi-global, glocal, and extension alignment) (see [Alignment Span](#wfa2.span)). In the case of long and noisy alignments, the library provides different [low-memory modes](#wfa2.mem) that significantly reduce the memory usage of the naive WFA algorithm implementation. Beyond the exact-alignment modes, the WFA2 library implements [heuristic modes](#wfa2.heuristics) that dramatically accelerate the alignment computation. Additionally, the library provides many other support functions to display and verify alignment results, control the overall memory usage, and more.\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "1.5 Important notes and clarifications",
        "parent_header": [
          "WFA2-lib",
          "1. INTRODUCTION"
        ],
        "type": "Text_excerpt",
        "value": "- The WFA algorithm is an **exact algorithm**. If no heuristic is applied (e.g., band or adaptive pruning), the core algorithm guarantees to always find the optimal solution (i.e., best alignment score). Since its first release, some authors have incorrectly referred to the WFA as approximated or heuristic; this is not the case.\n\n\n- Given two sequences of length `n`, traditional dynamic-programming (DP) based methods (like Smith-Waterman or Needleman-Wunsch) compute the optimal alignment in `O(n^2)` time, using `O(n^2)` memory. In contrast, the WFA algorithm requires `O(ns+s^2)` time and `O(s^2)` memory (with `s` the optimal alignment score). Therefore, **the memory consumption of the WFA algorithm is not intrinsically higher than that of other methods**. Most DP-based methods can use heuristics (like banded, X-drop, or Z-drop) to reduce the execution time and the memory usage at the expense of losing accuracy. Likewise, **the WFA algorithm can also use heuristics to reduce the execution time and memory usage**. Moreover, the memory mode `ultralow` uses the BiWFA algorithm to execute in `O(ns+s^2)` time and linear `O(s)` memory.\n\n\n- **A note for the fierce competitors.** I can understand that science and publishing have become a fierce competition these days. Many researchers want their methods to be successful and popular, seeking funding, tenure, or even fame. If you are going to benchmark the WFA using the least favourable configuration, careless programming, and a disadvantageous setup, please, go ahead. But remember, researchers like you have put a lot of effort into developing the WFA. We all sought to find better methods that could truly help other researchers. So, try to be nice, tone down the marketing, and produce fair evaluations and honest publications.\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.911359289164412,
      "result": {
        "original_header": "<a name=\"wfa2.programming.rust\"></a> 2.3 Rust bindings",
        "type": "Text_excerpt",
        "value": "Rust bindings can be generated automatically using `bindgen`, see [bindings/rust/build.rs](bindings/rust/build.rs).\nAn example of how to use them is [here](./bindings/rust/example.rs).\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9970501032008031,
      "result": {
        "original_header": "<a name=\"wfa2.features\"></a> 3. WFA2-LIB FEATURES",
        "type": "Text_excerpt",
        "value": "* **Exact alignment** method that computes the optimal **alignment score** and/or **alignment CIGAR**.\n* Supports **multiple distance metrics** (i.e., indel, edit, gap-linear, gap-affine, and dual-gap gap-affine).\n* Allows performing **end-to-end** (a.k.a. global) and **ends-free** (e.g., semi-global, extension, overlap) alignment.\n* Implements **low-memory modes** to reduce and control memory consumption (down to `O(s)` using the `ultralow` mode).\n* Supports various **heuristic strategies** to use on top of the core WFA algorithm.\n* WFA2-lib **operates with plain ASCII strings**. Although we mainly focus on aligning DNA/RNA sequences, the WFA algorithm and the WFA2-lib implementation work with any pair of strings. Moreover, these sequences do not have to be pre-processed (e.g., packed or profiled), nor any table must be precomputed (like the query profile, used within some Smith-Waterman implementations).\n* Due to its simplicity, the WFA algorithm can be automatically vectorized for any SIMD-compliant CPU supported by the compiler. For this reason, **the WFA2-lib implementation is independent of any specific ISA or processor model**. Unlike other hardware-dependent libraries, we aim to offer a multiplatform pairwise-alignment library that can be executed on different processors and models (e.g., SSE, AVX2, AVX512, POWER-ISA, ARM, NEON, SVE, SVE2, RISCV-RVV, ...).\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9612779462546408,
      "result": {
        "original_header": "<a name=\"wfa2.distances\"></a> 3.1 Distance Metrics",
        "type": "Text_excerpt",
        "value": "- **Indel (or LCS).** Produces alignments allowing matches, insertions, and deletions with unitary cost (i.e., {M,I,D} = {0,1,1}) but not mismatches. Also known as the longest common subsequence (LCS) problem. The LCS is defined as the longest subsequence common to both sequences, provided that the characters of the subsequence are not required to occupy consecutive positions within the original sequences.\n```\n    PATTERN    A-GCTA-GTGTC--AATGGCTACT-T-T-TCAGGTCCT\n               |  ||| |||||    |||||||| | | |||||||||\n    TEXT       AA-CTAAGTGTCGG--TGGCTACTATATATCAGGTCCT\n    ALIGNMENT  1M1I1D3M1I5M2I2D8M1I1M1I1M1I9M\n```\n \n- **Edit (a.k.a. Levenshtein).** Produces alignments allowing matches, mismatches, insertions, and deletions with unitary cost (i.e., {M,X,I,D} = {0,1,1,1}). Edit or Levenshtein distance between two sequences is the minimum number of single-character edits (i.e., insertions, deletions, or mismatches) required to transform one sequence into the other.\n```\n    PATTERN    AGCTA-GTGTCAATGGCTACT-T-T-TCAGGTCCT\n               | ||| |||||  |||||||| | | |||||||||\n    TEXT       AACTAAGTGTCGGTGGCTACTATATATCAGGTCCT\n    ALIGNMENT  1M1X3M1I5M2X8M1I1M1I1M1I9M\n```\n \n- **Gap-linear (as in Needleman-Wunsch).** Produces alignments allowing matches, mismatches, insertions, and deletions. Allows assigning a penalty (a.k.a. cost or weight) to each alignment operation. It computes the optimal alignment, minimizing the overall cost to transform one sequence into the other. Under the gap-linear model, the alignment score is computed based on {X,I}\u2060, where X corresponds to the mismatch penalty and the gap penalty is expressed as the function l(N)=N\u00b7I (given the length of the gap N and the gap penalty I).\n```\n    PATTERN    A-GCTA-GTGTC--AATGGCTACT-T-T-TCAGGTCCT\n               |  ||| |||||    |||||||| | | |||||||||\n    TEXT       AA-CTAAGTGTCGG--TGGCTACTATATATCAGGTCCT\n    ALIGNMENT  1M1I1D3M1I5M2I2D8M1I1M1I1M1I9M\n```\n \n- **Gap-affine (as in Smith-Waterman-Gotoh).** Linear gap cost functions can lead to alignments populated with small gaps. Long gaps are preferred in certain scenarios, like genomics or evolutionary studies (understood as a single event). Under the gap-affine model, the alignment score is computed based on {X,O,E}\u2060, where X corresponds to the mismatch penalty and the gap penalty is expressed as the function g(N)=O+N\u00b7E (given the length of the gap N, the gap opening penalty O, and the gap extension penalty E).\n```\n    PATTERN    AGCTA-GTGTCAATGGCTACT---TTTCAGGTCCT\n               | ||| |||||  ||||||||   | |||||||||\n    TEXT       AACTAAGTGTCGGTGGCTACTATATATCAGGTCCT\n    ALIGNMENT  1M1X3M1I5M2X8M3I1M1X9M\n```\n \n- **Dual-cost gap-affine distances.** Also known as piece-wise gap-affine cost, this distance metric addresses some issues that the regular gap-affine distance has with long gaps. In a nutshell, the regular gap-affine distance can occasionally split long gaps by sporadic mismatches (often when aligning long and noisy sequences). Instead, many users would prefer to increase the open gap cost to produce a single long gap. For that, the dual-cost gap-affine distance (p=2) defines two affine cost functions (i.e., for short and long gaps). Then, the alignment score is computed based on {X,O1,E1,O2,E2}\u2060, where X corresponds to the mismatch penalty and the gap penalty is expressed as the function g(N)=min{O1+N\u00b7E1,O2+N\u00b7E2} (given the length of the gap N, the gap opening penalties O1 and O2, and the gap extension penalties E1 and E2).\n```C\n    wavefront_aligner_attr_t attributes = wavefront_aligner_attr_default;\n    attributes.distance_metric = gap_affine_2p;\n    attributes.affine2p_penalties.mismatch = 6;       // X > 0\n    attributes.affine2p_penalties.gap_opening1 = 4;   // O1 >= 0\n    attributes.affine2p_penalties.gap_extension1 = 2; // E1 > 0\n    attributes.affine2p_penalties.gap_opening2 = 12;  // O2 >= 0\n    attributes.affine2p_penalties.gap_extension2 = 1; // E2 > 0\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9299849382236182,
      "result": {
        "original_header": "<a name=\"wfa2.scope\"></a> 3.2 Alignment Scope",
        "type": "Text_excerpt",
        "value": "Depending on the use case, it is often the case that an application is only required to compute the alignment score, not the complete alignment (i.e., CIGAR). As it happens with traditional dynamic programming algorithms, the WFA algorithm requires less memory (i.e., `O(s)`) to compute the alignment score. In turn, this results in slighter faster alignment executions. For this reason, the WFA2 library implements two different modes depending on the alignment scope: score-only and full-CIGAR alignment. \nThe ** score-only alignment ** mode computes only the alignment score. This mode utilizes only the front-wavefronts of the WFA algorithm to keep track of the optimal alignment score. As a result, it requires `O(s)` memory and, in practice, performs slighter faster than the standard full-CIGAR mode.\n```C\n    wavefront_aligner_attr_t attributes = wavefront_aligner_attr_default;\n    attributes.alignment_scope = compute_score;\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9614473177063767,
      "result": {
        "original_header": "<a name=\"wfa2.span\"></a> 3.3 Alignment Span",
        "type": "Text_excerpt",
        "value": "The WFA2 library allows computing alignments with different spans or shapes. Although there is certain ambiguity and confusion in the terminology, we have tried to generalize the different options available to offer flexible parameters that can capture multiple alignment scenarios. During the development of the WFA we decided to adhere to the classical approximate string matching terminology where we align a **pattern (a.k.a. query or sequence)** against a **text (a.k.a. target, database, or reference)**. \n- **End-to-end alignment.** Also known as global alignment, this alignment mode forces aligning the two sequences from the beginning to end of both.\n```\n    PATTERN    AATTAATTTAAGTCTAGGCTACTTTCGGTACTTTGTTCTT\n               ||||    ||||||||||||||||||||||||||   |||\n    TEXT       AATT----TAAGTCTAGGCTACTTTCGGTACTTT---CTT\n```\n \n- **Ends-free alignment.** This alignment mode allows leading and trailing insertions or deletions for \"free\" (i.e., no penalty/cost on the overall alignment score). Moreover, this alignment mode allows determining the maximum gap length allowed for free at the beginning and end of the sequences. Note that this mode does not implement local alignment as it does not allow free insertions and deletions at the beginning/end of the sequences at the same time. However, it allows many different configurations used across different analyses, methods, and tools.\n```\n    PATTERN    AATTAATTTAAGTCTAGGCTACTTTCGGTACTTTGTTCTT\n                   |||||||||||||||||||||||||||||| ||\n    TEXT       ----AATTTAAGTCTAGGCTACTTTCGGTACTTTCTT---\n```\n \n- **Glocal alignment (a.k.a. semi-global or fitting).** Alignment mode where the pattern is globally aligned and the text is locally aligned. Often due to the large size of one of the sequences (e.g., the text sequence being a genomic reference), this alignment mode forces one sequence (i.e., pattern) to align globally to a substring of the other (i.e., text).\n```\n    PATTERN    -------------AATTTAAGTCTAGGCTACTTTC---------------\n                            ||||||||| ||||||||||||\n    TEXT       ACGACTACTACGAAATTTAAGTATAGGCTACTTTCCGTACGTACGTACGT\n```\n \n- **Extension alignment.** Alignment mode where the start of both pattern and text sequences are forced to be aligned. However, the ends of both are free. This alignment mode is typically used within seed-and-extend algorithms.\n```C\n    // Right extension\n    wavefront_aligner_attr_t attributes = wavefront_aligner_attr_default;\n    attributes.alignment_form.span = alignment_endsfree;\n    attributes.alignment_form.pattern_begin_free = 0;\n    attributes.alignment_form.pattern_end_free = pattern_end_free;\n    attributes.alignment_form.text_begin_free = 0;\n    attributes.alignment_form.text_end_free = text_end_free;\n\n    PATTERN    AATTTAAGTCTG-CTACTTTCACGCA-GCT----------\n               ||||| |||||| ||||||||||| | | |\n    TEXT       AATTTCAGTCTGGCTACTTTCACGTACGATGACAGACTCT\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8743094469368904,
      "result": {
        "original_header": "<a name=\"wfa2.mem\"></a> 3.4 Memory modes",
        "type": "Text_excerpt",
        "value": "The WFA2 library implements various memory modes: `wavefront_memory_high`, `wavefront_memory_med`, `wavefront_memory_low`, and `wavefront_memory_ultralow`. These modes allow regulating the overall memory consumption. The standard WFA algorithm, which stores explicitly all wavefronts in memory, correspond to the mode `wavefront_memory_high`. Memory modes `wavefront_memory_med` and `wavefront_memory_low` progressively reduce memory usage at the expense of slightly larger alignment times. Memory mode `wavefront_memory_ultralow` utilizes the BiWFA algorithm using a minimal memory footprint of `O(s)` and the same `O(ns+s^2)` time complexity as the original WFA. In practice, `wavefront_memory_ultralow` can outperform `wavefront_memory_high` because the latter experiences memory slowdowns when aligning long and noisy sequences. \nMemory modes can be used transparently with other alignment options and generate identical results. Note that this option does not affect the score-only alignment mode, which always uses a minimal memory footprint of `O(s)`).\n```C\n  wavefront_aligner_attr_t attributes = wavefront_aligner_attr_default;\n  attributes.memory_mode = wavefront_memory_ultralow;\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9221957298237095,
      "result": {
        "original_header": "<a name=\"wfa2.heuristics\"></a> 3.5 Heuristic modes",
        "type": "Text_excerpt",
        "value": "The WFA algorithm can be used combined with many heuristics to reduce the alignment time and memory used. As it happens to other alignment methods, heuristics can result in suboptimal solutions and loss of accuracy. Moreover, some heuristics may drop the alignment if the sequences exceed certain divergence thresholds (i.e., x-drop/z-drop). Due to the popularity and efficiency of these methods, the WFA2 library implements many of these heuristics. Note, **it is not about how little DP-matrix you compute, but about how good/accurate the resulting alignments are.** \nWFA2's heuristics are classified into the following categories: ['wf-adaptive'](#wfa2.wfadaptive), ['drops'](#wfa2.drops), and ['bands'](#wfa2.bands). It is possible to combine a maximum of one heuristic from each category (OR-ing the strategy values or using the API). In the case of using multiple heuristics, these will be applied in cascade, starting with 'wf-adaptive', then 'drops', and finally 'bands'. \n- **None (for comparison)**. If no heuristic is used, the WFA behaves exploring cells of the DP-matrix in increasing score order (increasing scores correspond to colours from blue to red). \n- <a name=\"wfa2.wfadaptive\"></a> **Heuristic wf-adaptive.** This WFA heuristic removes outer diagonals that are extremely far behind compared to other ones in the same wavefront. Unlike other methods, the adaptive-wavefront reduction heuristic prunes based on the potential of the diagonal to lead to the optimal solution without previous knowledge of the error between the sequences.\n```C\n  wavefront_aligner_attr_t attributes = wavefront_aligner_attr_default;\n  attributes.heuristic.strategy = wf_heuristic_wfadaptive;\n  attributes.heuristic.min_wavefront_length = 10;\n  attributes.heuristic.max_distance_threshold = 50;\n  attributes.heuristic.steps_between_cutoffs = 1;\n```\n \n- <a name=\"wfa2.drops\"></a> **Heuristic drops.** This heuristic compares the maximum score computed so far with the score of the last computed cells. Depending on the score difference, these heuristic strategies can reduce the size of the wavefront computed or even abandon the alignment process. In the case of zero-match alignment, $M=1$ will be assumed just for computation of the score drop. Also note that this heuristic is not compatible with distances 'edit' or 'indel'. In this category, WFA2 implements 'X-drop' and 'Z-drop'. \n\n- <a name=\"wfa2.bands\"></a> **Heuristic bands.** These heuristics set a band in the diagonals preventing the wavefront from growing beyond those limits. It allows setting the minimum diagonal (i.e., min_k) and maximum diagonal (i.e., max_k). These heuristics are the most restrictive but the fastest and simplest to compute. In this category, WFA2 implements 'static-band' and 'adaptive-band'. \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Static-band** sets a fixed band in the diagonals preventing the wavefront from growing beyond those limits. It allows setting the minimum diagonal (i.e., min_k) and maximum diagonal (i.e., max_k).\n```C\n  wavefront_aligner_attr_t attributes = wavefront_aligner_attr_default;\n  attributes.heuristic.strategy = wf_heuristic_banded_static;\n  attributes.heuristic.min_k = -10;\n  attributes.heuristic.max_k = +10;\n```\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Adaptive-band** is similar to the static-band heuristic; however, it allows the band to move towards the diagonals closer to the end of the alignment. Unlike the static-band that is performed on each step, the adaptive-band heuristics allows configuring the number of steps between heuristic band cut-offs.\n```C\n  wavefront_aligner_attr_t attributes = wavefront_aligner_attr_default;\n  attributes.heuristic.strategy = wf_heuristic_banded_adaptive;\n  attributes.heuristic.min_k = -10;\n  attributes.heuristic.max_k = +10;\n  attributes.heuristic.steps_between_cutoffs = 1;\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9327713319583308,
      "result": {
        "original_header": "<a name=\"wfa2.other.notes\"></a> 3.6 Some technical notes",
        "type": "Text_excerpt",
        "value": "- Thanks to Eizenga's formulation, WFA2-lib can operate with any match score. In practice, M=0 is often the most efficient choice. \n\n- Note that edit and LCS are distance metrics and, thus, the score computed is always positive. However, using weighted distances (e.g., gap-linear and gap-affine) the alignment score is computed using the selected penalties (i.e., the alignment score can be positive or negative). For instance, if WFA2-lib is executed using $M=0$, the final score is expected to be negative. \n\n- WFA2lib follows the convention that describes how to transform the (1) Pattern/Query into the (2) Text/Database/Reference used in classic pattern matching papers. However, the SAM CIGAR specification describes the transformation from (2) Reference to (1) Query. If you want CIGAR-compliant alignments, swap the pattern and text sequences argument when calling the WFA2lib's align functions (to convert all the Ds into Is and vice-versa).\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9334532239508765,
      "result": {
        "original_header": "<a name=\"wfa2.bugs\"></a> 4. REPORTING BUGS AND FEATURE REQUEST",
        "type": "Text_excerpt",
        "value": "Feedback and bug reporting is highly appreciated. Please report any issue or suggestion on github or email to the main developer (santiagomsola@gmail.com). Don't hesitate to contact us\nif:\n  - You experience any bug or crash.\n  - You want to request a feature or have any suggestion.\n  - Your application using the library is running slower than it should or you expected.\n  - Need help integrating the library into your tool.\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9513806750789074,
      "result": {
        "original_header": "<a name=\"wfa2.authors\"></a> 6. AUTHORS",
        "type": "Text_excerpt",
        "value": "[Santiago Marco-Sola](https://github.com/smarco) (santiagomsola@gmail.com) is the main developer and the person you should address your complaints. \n[Andrea Guarracino](https://github.com/AndreaGuarracino) and [Erik Garrison](https://github.com/ekg) have contributed to the design of new features and intensive testing of the library. \n[Pjotr Prins](https://thebird.nl/) contributed the CMake build system, preventing of leaking variables in include headers and other tweaks. \nMiquel Moret\u00f3 has contributed with fruitful technical discussions and tireless efforts seeking funding, so we could keep working on this project.\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/smarco/WFA/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 35
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/smarco/WFA2-lib/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "smarco/WFA2-lib"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "WFA2-lib"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    }
  ],
  "has_script_file": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/scripts/fasta2seq.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/scripts/seq2fasta.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/scripts/wfa.alg.cmp.score.sh"
      },
      "technique": "file_exploration"
    }
  ],
  "images": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.none.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.none.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.wfadap.10.50.1.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.wfadap.10.50.10.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.drop.none.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.xdrop.200.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.zdrop.200.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.band.10.10.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.band.10.150.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.aband.10.10.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/img/heuristics.aband.50.50.png"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "regular_expression"
    }
  ],
  "installation": [
    {
      "confidence": 0.9999998340533831,
      "result": {
        "original_header": "<a name=\"wfa2.bugs\"></a> 4. REPORTING BUGS AND FEATURE REQUEST",
        "type": "Text_excerpt",
        "value": "Feedback and bug reporting is highly appreciated. Please report any issue or suggestion on github or email to the main developer (santiagomsola@gmail.com). Don't hesitate to contact us\nif:\n  - You experience any bug or crash.\n  - You want to request a feature or have any suggestion.\n  - Your application using the library is running slower than it should or you expected.\n  - Need help integrating the library into your tool.\n \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8405001833343417,
      "result": {
        "original_header": "<a name=\"wfa2.authors\"></a> 6. AUTHORS",
        "type": "Text_excerpt",
        "value": "[Pjotr Prins](https://thebird.nl/) contributed the CMake build system, preventing of leaking variables in include headers and other tweaks. \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    }
  ],
  "invocation": [
    {
      "confidence": 0.8565317517320893,
      "result": {
        "original_header": "<a name=\"wfa2.heuristics\"></a> 3.5 Heuristic modes",
        "type": "Text_excerpt",
        "value": "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Graphical examples:** \n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/smarco/WFA2-lib/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "Other",
        "spdx_id": "NOASSERTION",
        "type": "License",
        "url": null,
        "value": null
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "MIT License\n\nCopyright (c) 2017 Santiago Marco-Sola\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nAUTHOR/CONTACT: Santiago Marco-Sola <santiagomsola@gmail.com>\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/LICENSE",
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "<a name=\"wfa2.licence\"></a> 5. LICENSE",
        "parent_header": [
          "WFA2-lib"
        ],
        "type": "Text_excerpt",
        "value": "WFA2-lib is distributed under MIT licence.\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "header_analysis"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "WFA2-lib"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "User",
        "value": "smarco"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "C",
        "size": 819756,
        "type": "Programming_language",
        "value": "C"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Python",
        "size": 28314,
        "type": "Programming_language",
        "value": "Python"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "C++",
        "size": 26540,
        "type": "Programming_language",
        "value": "C++"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Makefile",
        "size": 14412,
        "type": "Programming_language",
        "value": "Makefile"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Shell",
        "size": 14133,
        "type": "Programming_language",
        "value": "Shell"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "CMake",
        "size": 7972,
        "type": "Programming_language",
        "value": "CMake"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Rust",
        "size": 3974,
        "type": "Programming_language",
        "value": "Rust"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Scheme",
        "size": 2242,
        "type": "Programming_language",
        "value": "Scheme"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/smarco/WFA/main/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "releases": [
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "smarco",
          "type": "User"
        },
        "date_created": "2024-04-20T10:22:00Z",
        "date_published": "2024-04-20T10:46:36Z",
        "description": "A stable release of the WFA library v2, solving a few bugs and improving the cmake build system (thanks to Pjotr Prins).",
        "html_url": "https://github.com/smarco/WFA2-lib/releases/tag/v2.3.5",
        "name": "WFAlib v2.3.5",
        "release_id": 152040653,
        "tag": "v2.3.5",
        "tarball_url": "https://api.github.com/repos/smarco/WFA2-lib/tarball/v2.3.5",
        "type": "Release",
        "url": "https://api.github.com/repos/smarco/WFA2-lib/releases/152040653",
        "value": "https://api.github.com/repos/smarco/WFA2-lib/releases/152040653",
        "zipball_url": "https://api.github.com/repos/smarco/WFA2-lib/zipball/v2.3.5"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "smarco",
          "type": "User"
        },
        "date_created": "2023-09-25T12:16:12Z",
        "date_published": "2023-09-25T12:18:26Z",
        "description": "A stable release of the WFA library v2, solving a few bugs.",
        "html_url": "https://github.com/smarco/WFA2-lib/releases/tag/v2.3.4",
        "name": "WFAlib v2.3.4",
        "release_id": 122437403,
        "tag": "v2.3.4",
        "tarball_url": "https://api.github.com/repos/smarco/WFA2-lib/tarball/v2.3.4",
        "type": "Release",
        "url": "https://api.github.com/repos/smarco/WFA2-lib/releases/122437403",
        "value": "https://api.github.com/repos/smarco/WFA2-lib/releases/122437403",
        "zipball_url": "https://api.github.com/repos/smarco/WFA2-lib/zipball/v2.3.4"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "smarco",
          "type": "User"
        },
        "date_created": "2023-02-15T08:14:39Z",
        "date_published": "2023-02-15T08:27:52Z",
        "description": "This is the first stable release of the WFA library v2.",
        "html_url": "https://github.com/smarco/WFA2-lib/releases/tag/v2.3.3",
        "name": "WFAlib 2.3.3",
        "release_id": 92516339,
        "tag": "v2.3.3",
        "tarball_url": "https://api.github.com/repos/smarco/WFA2-lib/tarball/v2.3.3",
        "type": "Release",
        "url": "https://api.github.com/repos/smarco/WFA2-lib/releases/92516339",
        "value": "https://api.github.com/repos/smarco/WFA2-lib/releases/92516339",
        "zipball_url": "https://api.github.com/repos/smarco/WFA2-lib/zipball/v2.3.3"
      },
      "technique": "GitHub_API"
    }
  ],
  "somef_missing_categories": [
    "run",
    "download",
    "requirements",
    "contact",
    "contributors",
    "documentation",
    "faq",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-10-06 10:15:30",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 157
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "1.3 Getting started",
        "parent_header": [
          "WFA2-lib",
          "1. INTRODUCTION"
        ],
        "type": "Text_excerpt",
        "value": "Git clone and compile the library, tools, and examples (by default, use `cmake` for the library and benchmark build).\n\n```\ngit clone https://github.com/smarco/WFA2-lib\ncd WFA2-lib\nmkdir build && cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\ncmake --build . --verbose\nctest . --verbose\n```\n\nThere are some flags that can be used. For instance:\n\n```\ncmake .. -DOPENMP=TRUE\ncmake .. -DCMAKE_BUILD_TYPE=Release -DEXTRA_FLAGS=\"-ftree-vectorizer-verbose=5\"\n```\n\nAlternatively, the simple Makefile build system can be used.\n\n```\ngit clone https://github.com/smarco/WFA2-lib\ncd WFA2-lib\nmake clean all\n```\n\nAlso, it is possible to build WFA2-lib in a GNU Guix container, for more information, see [guix.scm](./guix.scm).\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "1.4 Contents (where to go from here)",
        "parent_header": [
          "WFA2-lib",
          "1. INTRODUCTION"
        ],
        "type": "Text_excerpt",
        "value": "Section [WFA2-lib features](#wfa2.features) explores the most relevant options and features of the library. Then, the folder [tools/](tools/README.md) contains tools for executing and understanding the WFA2 library capabilities. Additionally, the folder [examples/](examples/README.md) contains simple examples illustrating how to integrate the WFA2 code into any tool.\n\n* [Using WFA2-lib in your project](#wfa2.programming)\n    * [Simple C example](#wfa2.programming.c)\n    * [Simple C++ example](#wfa2.programming.cpp)\n* [WFA2-lib Features](#wfa2.features)\n    * [Distance Metrics](#wfa2.distances)\n    * [Alignment Scope](#wfa2.scope)\n    * [Alignment Span](#wfa2.span)\n    * [Memory modes](#wfa2.mem)\n    * [Heuristic modes](#wfa2.heuristics)\n    * [Technical notes](#wfa2.other.notes)\n* [Reporting Bugs and Feature Request](#wfa2.complains)\n* [License](#wfa2.licence)\n* [Citation](#wfa2.cite)\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "<a name=\"wfa2.programming.c\"></a> 2.1 Simple C example",
        "parent_header": [
          "WFA2-lib",
          "<a name=\"wfa2.programming\"></a> 2. USING WFA2-LIB IN YOUR PROJECT"
        ],
        "type": "Text_excerpt",
        "value": "This simple example illustrates how to align two sequences using the WFA2 library. First, include the WFA2 alignment headers.\n\n```C\n#include \"wavefront/wavefront_align.h\"\n```\n\nNext, create and configure the WFA alignment object. The following example uses the defaults configuration and sets custom `gap_affine` penalties. Note that mismatch, gap-opening, and gap-extension must be positive values.\n\n```C\n// Configure alignment attributes\nwavefront_aligner_attr_t attributes = wavefront_aligner_attr_default;\nattributes.distance_metric = gap_affine;\nattributes.affine_penalties.mismatch = 4;\nattributes.affine_penalties.gap_opening = 6;\nattributes.affine_penalties.gap_extension = 2;\n// Initialize Wavefront Aligner\nwavefront_aligner_t* const wf_aligner = wavefront_aligner_new(&attributes);\n```\n\nFinally, call the `wavefront_align` function.\n\n```C\nchar* pattern = \"TCTTTACTCGCGCGTTGGAGAAATACAATAGT\";\nchar* text    = \"TCTATACTGCGCGTTTGGAGAAATAAAATAGT\";\nwavefront_align(wf_aligner,pattern,strlen(pattern),text,strlen(text)); // Align\n```\n\nAfterwards, we can use the library to display the alignment result (e.g., the alignment score and CIGAR).\n\n```C\n// Display CIGAR & score\ncigar_print_pretty(stderr,pattern,strlen(pattern),text,strlen(text),\n                   &wf_aligner->cigar,wf_aligner->mm_allocator);\nfprintf(stderr,\"Alignment Score %d\\n\",wf_aligner->cigar.score);\n```\n\nAt the end of the program, it is polite to release the memory used.\n\n```C\nwavefront_aligner_delete(wf_aligner); // Free\n```\n\nTo compile and run this example, you need to link against the WFA library (-lwfa).\n\n```\n$> gcc -O3 wfa_example.c -o wfa_example -lwfa\n$> ./wfa_example\n```\n\n**IMPORTANT.** Once an alignment object is created, **it is strongly recommended to reuse it to compute multiple alignments**. Creating and destroying the alignment object for every alignment computed can have a significant overhead. Reusing the alignment object allows repurposing internal data structures, minimising the cost of memory allocations, and avoiding multiple alignment setups and precomputations.\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "<a name=\"wfa2.programming.cpp\"></a> 2.2 Simple C++ example",
        "parent_header": [
          "WFA2-lib",
          "<a name=\"wfa2.programming\"></a> 2. USING WFA2-LIB IN YOUR PROJECT"
        ],
        "type": "Text_excerpt",
        "value": "The WFA2 library can be used from C++ code using the C++ bindings. This example is similar to the previous one but uses C++ bindings. First, include the C++ bindings and remember to use the WFA namespace.\n\n```C\n#include \"bindings/cpp/WFAligner.hpp\"\nusing namespace wfa;\n```\n\nConfigure and create the WFA alignment object. In this case, gap-affine distance using custom penalties and the standard memory-usage algorithm (i.e., standard WFA algorithm).\n\n```C++\n// Create a WFAligner\nWFAlignerGapAffine aligner(4,6,2,WFAligner::Alignment,WFAligner::MemoryHigh);\n```\n\nAlign two sequences (in this case, given as strings).\n\n```C++\nstring pattern = \"TCTTTACTCGCGCGTTGGAGAAATACAATAGT\";\nstring text    = \"TCTATACTGCGCGTTTGGAGAAATAAAATAGT\";\naligner.alignEnd2End(pattern,text); // Align\n```\n\nDisplay the result of the alignment.\n\n```C++\n// Display CIGAR & score\nstring cigar = aligner.getAlignmentCigar();\ncout << \"CIGAR: \" << cigar  << endl;\ncout << \"Alignment score \" << aligner.getAlignmentScore() << endl;\n```\n\n**IMPORTANT.** Once an alignment object is created, **it is strongly recommended to reuse it to compute multiple alignments**. Creating and destroying the alignment object for every alignment computed can have a significant overhead. Reusing the alignment object allows repurposing internal data structures, minimising the cost of memory allocations, and avoiding multiple alignment setups and precomputations.\n"
      },
      "source": "https://raw.githubusercontent.com/smarco/WFA/main/README.md",
      "technique": "header_analysis"
    }
  ]
}
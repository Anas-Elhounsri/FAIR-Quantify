{
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/arun96/sketching"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2020-08-17T18:14:02Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-06-10T06:18:10Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "Analyzing sketching and sampling approaches for fast and accurate read classification"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 0.9854732517059183,
      "result": {
        "original_header": "Overview",
        "type": "Text_excerpt",
        "value": "All the code used for \"Analyzing sketching and sampling approaches for fast and accurate long read classification\". \nThis README contains the unoptimized reference implementations we built, details about the code and how to use it, scripts for running and extracting results from existing tools, and details about how to generate simulated reads and access the data we used. Final updates, including any bug fixes and detailed analysis scripts and notebooks, are coming soon!\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9552662839088674,
      "result": {
        "original_header": "Pre-prints, Posters and Presentations",
        "type": "Text_excerpt",
        "value": "- [The pre-print is out! You can find here, on bioRxiv!](https://www.biorxiv.org/content/10.1101/2021.11.04.467374v2). We will be further updating this in May 2022, with the poster for RECOMB 2022 and RECOMB-Seq 2022 being added as well. \n- [The poster of this work at Genome Informatics 2021](https://drive.google.com/file/d/1CUPuw4Wv_yJiZ4jZkDbVVVF8dx3MMoC6/view?usp=sharing), and [the lightning talk for this poster from Genome Informatics 2021](https://www.youtube.com/watch?v=ihtHIgk_ARY) \n- [The poster of this work at RECOMB 2021](https://drive.google.com/file/d/1rNIQLJqiZzNdNJfhrTTExDxzFXM7-LLD/view?usp=sharing) (where it won the award for \"Best Poster\"!), and [my poster presentation](https://drive.google.com/file/d/1bjxqqSY75X8wEqR6_EUYMB_PbVK78IAL/view?usp=sharing).\n- [The lightning talk for this poster from RECOMB 2021](https://youtu.be/MMX2kbkRmYI). \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9613568083028942,
      "result": {
        "original_header": "Implementation Details",
        "type": "Text_excerpt",
        "value": "The tool is built in Java, and provides a way to generate a \"screen\" (sketched representation) of an input set of genomes, and either save the screen or classify input reads against this screen. For read classification, these may be reads drawn from the same set of genomes in the screen (either simulated using the approach above, or from another source), or a totally different set of reads. \nThere are three distinct approaches for screen-generation: a MinHash-based approach (with a few variants), a Minimizer-based approach, and a Uniform sampling approach. For each of these approaches, the size of the screen can either be calculated based on user-specified input parameters (the expected read length, the expected read error, the sizes of the genomes, and the number of shared samples each read should aim to have with its correct genome), or can be specified ahead of time by the user. \nTo see details of how to do any of the experiments outlined above, or how to adjust certain options/settings, please read the later sections of the README. \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9733047797901552,
      "result": {
        "original_header": "Brief overview of the approach",
        "type": "Text_excerpt",
        "value": "For an input set of genomes, using the specified screen generation approach, a reduced representation of the genomes is generated. This may then be saved to a file. \nIf there are reads to be classified against the selected screen, the reads are loaded in (either one file at a time, or a specified number of reads at a time), and each read is compared against the reduced representations of the genome. The genome with which a given read shares the most hashed k-mers is the predicted source for the read. \nIf the reads and the genomes are \"matched\" (i.e. if there is one read set for each genome, and thus the ground truth is known), we are able to give a summary of the classification accuracy on each read set (we can also save a simple log file for each read, with the true source and the predicted source, and the number of matches with each). If the source of the reads is not known (i.e. they are \"unmatched\"), then a log file is generated for each read, showing the number of matches it had with each genome in the screen. \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8590061745909009,
      "result": {
        "original_header": "Hash Function Options",
        "type": "Text_excerpt",
        "value": "At this point, the default hash function is Java's built in `hashCode()`. For the following section, if no hash function is specified, then this will be used. However, to specify a particular function, please use the following parameters: \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9115768189782669,
      "result": {
        "original_header": "Threads",
        "type": "Text_excerpt",
        "value": "The number of threads parameter determines the number of reads processed at once. Going forward, I hope to parallelize the process of screen generation too.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9859502793002893,
      "result": {
        "original_header": "Specifying Input Files",
        "type": "Text_excerpt",
        "value": "Instead of passing in a folder containing the genomes or reads, you may instead pass in a file containing a list of files to be used. To generate such a file you can navigate to the folder you want, and use the command `ls -d \"$PWD\"/* > genomes.txt` to generate a list of files in the folder, listed with absolute path. This option allows you to pick and choose which files in a folder you want to include, instead of just using the entire folder.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9899917886013855,
      "result": {
        "original_header": "Read Loading",
        "type": "Text_excerpt",
        "value": "As specified above, if `-c` is used, then reads will be loaded in chunks of the size specified by `-cs`. This is recommended for large read files, so that too much memory is not used.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9638521856085531,
      "result": {
        "original_header": "Screen/Sketch Generation Only",
        "type": "Text_excerpt",
        "value": "You can generate and save a screen for a later experiment, or load an existing screen. To do these, please use the `-so` or `-ls` parameters respectively, with `-sl` specifying which location the screens are to be saved to/loaded from.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9782857622225161,
      "result": {
        "original_header": "Matched Mode",
        "type": "Text_excerpt",
        "value": "When running in matched mode (and the `-rlg` option is used), read logs will be saved to the location specified by `-rlc`. The format of the log files varies depending on whether or not clustering is used. If clustering is not used, the logs will be a two lines:\n- An array of integers, with each number corresponding the number of matches between the current read and each element of the screen,\n-  The true source of the read, noted as an integer value (e.g. if it is `5`, then the 6th input genome is the source). \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9180992606910959,
      "result": {
        "original_header": "Unmatched Mode",
        "type": "Text_excerpt",
        "value": "When running in unmatched mode (`-um`),read logs are generated by default, and saved to the location specified by `-rlc`. As in the matched situation, the format of the log files will vary depending on whether or not clustering was used. Without clustering, the logs will be a single line, with each number corresponding the number of matches between the current read and each element of the screen. With clustering, the format is almost identical to that specified in the matched section above, with the only change being that there is no fifth line (as the true source is not known). \nPython helper scripts for aggregating these log files and summarizing results are included, and are described below.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9893792352647196,
      "result": {
        "original_header": "Using External JARs",
        "type": "Text_excerpt",
        "value": "As I am not using Maven, I have manually included the JARs this project will use. The foremost of these is Google's `Guava`, which gives me access to hash function implementations, optimized data structures, and other nifty features. Other include JARs are:\n- `commons.cli`: This is the library used for command line argument parsing.\n- `hierarchical-clustering`: This is the package used for clustering genome sketches to construct the sketch tree.\n- `clust4j`: An alternate option for clustering - currently not in use. \nAs I add more to this folder, I will update the README to include descriptions of each of them!\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9945620058423441,
      "result": {
        "original_header": "Analyzing Results",
        "type": "Text_excerpt",
        "value": "This is still unpolished, but will be wrapped up and updated soon! I am planning on updating all these files, as well as adding a simple notebook to walkthrough the analysis of output from these experiments. \nIn the `analysis` folder, you can find some scripts that are useful for analyzing the results of the screening process.\n- `extract_results.py`: Use `python3 extract_results.py <Path to output file>` to generate a summary of the experiment. This will give you the total number of correctly and incorrectly classified reads, as well as a few other metrics. It will also generate a histogram with the classification accuracy of reads from each organism.\n- `aggregate_read_logs.py`: This is for analyzing results at the end of a matched run. Use `python3 aggregate_read_logs.py <Path to folder with read logs>` to get read set-by-read set breakdown of the classification accuracy, as well as a matrix showing how many reads were correctly or incorrectly classified to each member of the community. The matrix is interpreted as follows - the value at` Matrix[x][y]` is the number of reads from organism `x` that were classified as being from organism `y`. Note that this can only be used in matched mode, if read logging was enabled. This file will also generate a number of plots and visualizations, such as the breakdown of how each readset was classified, a visualization of the classification matrix, and a distribution of how many matches reads had with their source genome.\n- `aggregate_classification_logs.py`: This is for analyzing results at the end of an unmatched run. Use `python3 aggregate_classification_logs.py <Path to folder with read logs>` to generate a series of histograms showing the breakdown of how many reads were classified to each genome in the screen for each readset that was classified. The folder containing these log files will be the location stored in the `READ_LOCATION` parameter in `Settings.java`. As with the previous file, there will also be a number of plots and visualizations generated.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9589657399136011,
      "result": {
        "original_header": "Generating Reads",
        "type": "Text_excerpt",
        "value": "The read simulator used here is very simple. For a target read length, this simulator will generate reads with lengths that are normally distributed around the input read length, with standard deviation equal to the square root of this mean length. Once the read length is decided, a sequence of that length from anywhere within the selected genome is extracted, and each base in the selected read is mutated according to the desired error rate. Mutations can be base changes, insertions of a random base, or a deletion. \nThe read simulator is a modified version of [Melanie Kirsche's read simulator](https://github.com/schatzlab/centroTools/tree/master/java). To generate reads for a set of genomes, run `generate_reads.sh` using the following syntax:\n```\n./generate_reads.sh <path to directory containing read simulator> <directory containing genomes> <directory where reads will be saved> <SNP rate> <Insertion rate> <Deletion rate> <Mean Read Length> <Coverage>\n``` \nFor example, `./generate_reads.sh readsim MBARC_ZYMO reads_MBARC_ZYMO 0.0034 0.0033 0.0033 10000 10` will simulate reads from all .fasta/.fna/.fa genome files in `MBARC_ZYMO`, and save a readset for each genome in `reads_MBARC_ZYMO`. The reads will have a mean length of 10K, a SNP rate of 0.34%, insertion and deletion rates of 0.33% each, and enough reads will be generated to have a coverage of 10x on each genome.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9156351862193475,
      "result": {
        "original_header": "Read Length Options (Not recommended)",
        "type": "Text_excerpt",
        "value": "By default, this script will generate reads with read lengths that are normally distributed around the input read length (with standard deviation equal to the square root of this mean length). However, you can generate reads with the following read length distributions: \n- Exact [`XL`]: All reads will be the same length.\n- Exponentially Distribution [`E`]: Read lengths will be drawn from an exponential distribution around the provided read length.\n- Exponentially Distribution with Minimum Length [`EM`]: Read lengths will be drawn from an exponential distribution around the provided read length, with a minimum length of half the input length - if a read length is sampled that is lower than this minimum, that read's length will be the minimum value. This will result in many reads having read length exactly half the input length, so the next option is preferred for more realistic read lengths.\n- Exponentially Distribution with Minimum Length v2 [`EL`]: Read lengths will be drawn from an exponential distribution around the provided read length, with a minimum length of half the input length. However, if a read length is below the minimum value, the length is sampled again. This creates more realistic read lengths. \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9370209570743946,
      "result": {
        "original_header": "Data and Code Availability",
        "type": "Text_excerpt",
        "value": "- PacBio HiFi Microbiome reads: https://www.pacb.com/blog/data-release-human-microbiome-samples-demonstrate-advances-in-hifi-enabled-metagenomic-sequencing/ \nAll code used is in this repository, and all external tools are cited in the publication.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/arun96/sketching/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "faq": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 1: MinHash-based Screen with corresponding read sets (of reads with average length 10k, error rate 1%)",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "To generate a MinHash-based screen for a set of genomes, and then run a corresponding set of reads (i.e. one read set for each genome) against the screen, all while using the default hash function, please run the following:\n\n```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -rl <Expected Read Length = 10000> -re <Expected Read Error = 0.01> -tm <Number of target matches per read>\n```\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 0
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/arun96/sketching/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "arun96/sketching"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "Overview"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "has_script_file": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/generate_reads.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/mash_2dir.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/mash_all.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/kraken2/benchmark_kraken2.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/winnowmap/analyze_winnowmap.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/winnowmap/extract_results_winnowmap.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/winnowmap/extract_contigs.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/winnowmap/benchmark_winnowmap.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/mashmap/benchmark_mashmap.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/minimap2/benchmark_minimap2.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/minimap2/analyze_minimap2.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/minimap2/extract_results_minimap2.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/minimap2/extract_contigs.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/scripts/centrifuge/benchmark_centrifuge.sh"
      },
      "technique": "file_exploration"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 1: MinHash-based Screen with corresponding read sets (of reads with average length 10k, error rate 1%)",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "To generate a MinHash-based screen for a set of genomes, and then run a corresponding set of reads (i.e. one read set for each genome) against the screen, all while using the default hash function, please run the following:\n\n```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -rl <Expected Read Length = 10000> -re <Expected Read Error = 0.01> -tm <Number of target matches per read>\n```\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 2: Minimizer-based Screen with corresponding read sets, with a specified number of reads loaded at a time, and the mmh3 hash function",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -s m -rl <Expected Read Length> -re <Expected Read Error> -tm <Number of target matches per read> -s M -c -cs <Number of reads to be loaded at a time> -hf mmh3\n```\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 3: Uniform-sampling Screen of a fixed size with corresponding read sets, with a specified number of reads loaded at a time, the default hash function, with read logging active",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -s u -f <Screen Size> -c -cs <Number of reads to be loaded at a time> -rlg -rlc <Location to save the read logs>\n```\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 4: MinHash-based Screen with novel/unmatched read sets, with a specified number of reads loaded at a time, the default hash function, using 4 threads",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -rl <Expected Read Length> -re <Expected Read Error> -tm <Number of target matches per read> -um  -c -cs <Number of reads to be loaded at a time> -rlc <Location to save the read logs> -nt 4\n```\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 6: Use a clustered uniform-sampling approach with corresponding read sets, with clustering done using a sketch size of 250, with a specified number of reads  loaded at a time, the default hash function, and read logging active",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -s u -f <Screen Size> -c -cs <Number of reads to be loaded at a time> -rlg -rlc <Location to save the read logs> -ct -css 250\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.9989260434378304,
      "result": {
        "original_header": "Implementation Details",
        "type": "Text_excerpt",
        "value": "As always, make sure to compile: `javac -cp jars/\\* screen_java/*.java`.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9999951313742769,
      "result": {
        "original_header": "Specifying Input Files",
        "type": "Text_excerpt",
        "value": "Instead of passing in a folder containing the genomes or reads, you may instead pass in a file containing a list of files to be used. To generate such a file you can navigate to the folder you want, and use the command `ls -d \"$PWD\"/* > genomes.txt` to generate a list of files in the folder, listed with absolute path. This option allows you to pick and choose which files in a folder you want to include, instead of just using the entire folder.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.8575902383648306,
      "result": {
        "original_header": "Screen/Sketch Generation Only",
        "type": "Text_excerpt",
        "value": "You can generate and save a screen for a later experiment, or load an existing screen. To do these, please use the `-so` or `-ls` parameters respectively, with `-sl` specifying which location the screens are to be saved to/loaded from.\n \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.977568496165118,
      "result": {
        "original_header": "Data and Code Availability",
        "type": "Text_excerpt",
        "value": "- ZYMO: https://www.zymoresearch.com/collections/zymobiomics-microbial-community-standards \n- MBARC-26: https://www.nature.com/articles/sdata201681 \n- CGR: https://www.nature.com/articles/s41587-018-0008-8 \n- PacBio HiFi Microbiome reads: https://www.pacb.com/blog/data-release-human-microbiome-samples-demonstrate-advances-in-hifi-enabled-metagenomic-sequencing/ \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "invocation": [
    {
      "confidence": 0.8505905130398584,
      "result": {
        "original_header": "Generating Reads",
        "type": "Text_excerpt",
        "value": "The read simulator is a modified version of [Melanie Kirsche's read simulator](https://github.com/schatzlab/centroTools/tree/master/java). To generate reads for a set of genomes, run `generate_reads.sh` using the following syntax:\n```\n./generate_reads.sh <path to directory containing read simulator> <directory containing genomes> <directory where reads will be saved> <SNP rate> <Insertion rate> <Deletion rate> <Mean Read Length> <Coverage>\n``` \n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/arun96/sketching/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "genomics, read-classification, sampling, sketching"
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "MIT License",
        "spdx_id": "MIT",
        "type": "License",
        "url": "https://api.github.com/licenses/mit",
        "value": "https://api.github.com/licenses/mit"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "MIT License\n\nCopyright (c) 2020 Arun Das\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/LICENSE",
      "technique": "file_exploration"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "sketching"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "User",
        "value": "arun96"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "Java",
        "size": 151815,
        "type": "Programming_language",
        "value": "Java"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Python",
        "size": 24586,
        "type": "Programming_language",
        "value": "Python"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Shell",
        "size": 3388,
        "type": "Programming_language",
        "value": "Shell"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/arun96/sketching/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "run": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Running the code and explanation of parameters",
        "parent_header": [
          "Implementation Details"
        ],
        "type": "Text_excerpt",
        "value": "To run the code, please run:\n```\njava -cp screen_java:jars/\\* Main <options>\n```\n\nThis code uses the `commons.cli` argument parser, so the order of arguments does not matter. Below is a breakdown of the parameters/arguments that can be used.\n\nKey Parameters:\n- `-g/--genome <Directory>`: The directory containing the genomes that are to be sketched into a screen. Only not necessary if we are using pre-generated screens (`-ls/--load-screens`). In this situation, the pre-generated screens stored at `-sl` will be used. You can also pass in a file containing a list of files (with absolute paths) instead of specifying a folder - for more information on this, see [this section](#specifying-input-files).\n- `-r/--reads <Directory>`: The directory containing the reads that are to be classified against the screen. Only not necessary if we are in \"screen-only\" mode (`-so/--screen-only`). You can also pass in a file containing a list of files (with absolute paths) instead of specifying a folder - for more information on this, see [this section](#specifying-input-files).\n- `-rl/--read-length <Integer>`: The expected read length of reads that will be classified against this screen. Not necessary if a fixed size screen (`-f`) is being generated.\n- `-re/--read-error <Double>`: The expected error rate of reads that will be classified against this screen. Not necessary if a fixed size screen (`-f`) is being generated.\n- `-tm/--target-matches <Integer>`: The target number of matches between a read and its correct source in the screen. Not necessary if a fixed size screen (`-f`) is being generated.\n- `-s/--screen-type`: The method of screen-generation to be used for this screen. Choose between MinHash-based (default), [m]inimizer based, [u]niform sampling or [e]xhaustive.\n- `-hf/--hash <Hash Type>`: The hash function to use throughout the process. Choose between Java's built in hashcode (default), mmh3 (MurmurHash3) or mmh3_128 (the 128-bit variant of MurmurHash3).\n- `-th/--threshold <Integer>`: This is the number of matches a read must have with a source genome to be classified. By default, it is 5 - however, this should be adjusted based on the level of confidence we want in classification calls. Reads below this threshold will be flagged as insufficient. This value should always be below the number of target matches, and usually just a fraction of the target matches (so that reads are classified as often as possible).\n\nMatched Reads/Genomes vs Classification without a ground truth:\n- `-um/--unmatched`: Use this parameter if the reads and the genomes do not correspond - by default, the code will assume that there is a matching read set for each genome (generated using the simulator above), and will proceed with classification assuming there is some ground truth. If this option is selected, detailed classification logs will be saved for each read, and no accuracy metrics will be printed. NOTE: Over time, this will become the default, and a parameter will be needed to indicate the genomes and reads are matched. In this mode, read logging is enabled by default.\n\nAdditional Options for MinHash:\nNOTE: These sections are still under development.\n- `-wmh/--weighted-minhash`: Use this flag to enable weighted minhash. By default, it is false.\n- `-wmhw/--weighted-minhash`: If `wmh` is used, this can be used to specify the multiplier given to unique k-mers (i.e. k-mers that only occur in one genome in the screen). By default it is one (as all k-mer weights are the total number of genomes - the number of genomes they occur in), but with this option unique k-mers can be weighted higher, helping to break ties.\n- `-omh/--order-minhash`: Use this flag to enable order minhash. By default, it is false.\n- `-omhl/--order-minhash-len`: If `-omh` is used, then this will specify the number of k-mers whose order should be retained relative to each other. By default, this is 3.\n\nFixed Size Screens:\n- `-f/--fixed <Integer>`: Use if the screen size should not be calculated, but instead the specified size/window size should be used for all screens. For uniform and MinHash screens, this will be the sketch size. For Minimizer-based screens, this will be the window size. This is not available for exhaustive screens, which just use all hashes in a given genome.\n\nRead Loading:\n- `-c/--chunks`: Use if a specified number of reads should loaded at a time (i.e. in \"chunks\"), instead of one file at a time.\n- `-cs/--chunk-size <Integer>`: If `-c` is used, then `-cs` will specify the \"chunk\" size.\n- `-cu/--chunk-updates`: If `-c` is used, then enabling `-cu` will print an update after each chunk is processed.\n\nRead Logging:\n- `-rlg/--read-logging`: Use if read-logging should be enabled. This is enabled by default in unmatched mode (`-um`).\n- `rlc/--read-location <Directory>`: The directory that read logs should be saved to. They will be named with the naming convention `<Readset Number>_<Read_Number>.log` - for example, `3_23.log` is the log for the 24th read from the 3rd read set.\n\nGenerating Screens without doing classification:\n- `-so/--screen-only`: Use if you only want to generate the screen, but not classify any reads.\n- `-sl/--screen-location <Directory>`: Used for both screen-generation and loading pre-generated screens. Specifies the location where the generated screens will be saved. Screens will be saved in `.bin` files with names matching the input genome files. If weighted minhash or order minhash are being used, then an additional `.bin` file will be saved with the weights/order, and will be loaded when used. Finally, a `params.txt` file with the details of the experiment will be generated - you will need to use the information in this file when loading the saved screen.\n\nLoad Pre-Generated Screen:\n- `-ls/--load-screen`: Use this if you want to use a pre-generated screen, and supply the input reads to classify against it. Please remember to set matched/unmatched (`-um`) depending on the type of classification you want to do, and please specify the error rate, read length and target matches used when generating this screen, as well as the weighted or order minhash parameters if either was used. The details for the screens that are loaded can be found in the same directory in the `params.txt` file, so refer to that to get the correct values.\n- `-sl/--screen-location <Directory>`: Used for both screen-generation and loading pre-generated screens. Specifies the location where the pre-generated screens will be loaded from. Pre-generated screens will be loaded from `.bin` files with names matching the input genome files.\n\nSave Screen while doing regular classification:\n- `-ss/--save-screen`: Use this to save screens after generation, but before the classification stage. Use the `-sl` parameter to specify the location it is saved to.\n\nExperiment Parameters\n- `-k/--kmer <Integer>`: The k-mer size to use. By default, it is 21.\n- `-nt/--num-threads <Integer>`: The number of threads to use during read classification. By default, it is 4.\n- `-rlns/--read-lines`: The number of lines in the read fasta/fastq file that are dedicated to a single read. By default, it is 2 (read name + the read itself), but this could be 4 in some cases.\n\nClustering-based Approach:\nNOTE: This section is still under development.\n- `-ct/--cluster`: Use this flag to enable the clustering approach, where the generated screens will be clustered and arranged into a tree. By default, this is false, and regular classification will occur.\n- `-css/--cluster-sketch-size`: Used to specify the size of the sketches used to cluster the genomes. By default is set to 100, but can be set to any value as long as clustering is enabled.\n- `dt/--downsample-type`: Used to specify the downsampling format we want to use in cluster generation. By default, sketches are `[n]`ot downsampled, but other options include downsampling by a `[c]`onstant factor or scaled for `[h]`eight.\n- `df/--downsample-factor`: If a downsampling format is specified, you can specify the factor used when downsampling. By default this is one, but any integer may be provided.\n\nRead Filtering:\n- `-fr/--filter-reads`: Use this flag to filter out low quality reads. For simulated reads, this will remove reads that have a large number of N's. In the future, this will filter out low quality reads.\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "somef_missing_categories": [
    "citation",
    "acknowledgement",
    "download",
    "requirements",
    "contact",
    "contributors",
    "documentation",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-10-06 02:29:08",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 10
      },
      "technique": "GitHub_API"
    }
  ],
  "type": [
    {
      "confidence": 0.82,
      "result": {
        "type": "String",
        "value": "commandline-application"
      },
      "technique": "software_type_heuristics"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 1: MinHash-based Screen with corresponding read sets (of reads with average length 10k, error rate 1%)",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "To generate a MinHash-based screen for a set of genomes, and then run a corresponding set of reads (i.e. one read set for each genome) against the screen, all while using the default hash function, please run the following:\n\n```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -rl <Expected Read Length = 10000> -re <Expected Read Error = 0.01> -tm <Number of target matches per read>\n```\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 2: Minimizer-based Screen with corresponding read sets, with a specified number of reads loaded at a time, and the mmh3 hash function",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -s m -rl <Expected Read Length> -re <Expected Read Error> -tm <Number of target matches per read> -s M -c -cs <Number of reads to be loaded at a time> -hf mmh3\n```\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 3: Uniform-sampling Screen of a fixed size with corresponding read sets, with a specified number of reads loaded at a time, the default hash function, with read logging active",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -s u -f <Screen Size> -c -cs <Number of reads to be loaded at a time> -rlg -rlc <Location to save the read logs>\n```\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 4: MinHash-based Screen with novel/unmatched read sets, with a specified number of reads loaded at a time, the default hash function, using 4 threads",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -rl <Expected Read Length> -re <Expected Read Error> -tm <Number of target matches per read> -um  -c -cs <Number of reads to be loaded at a time> -rlc <Location to save the read logs> -nt 4\n```\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 5: Minimizer-based Screen, without any reads to be classified, using the 128-bit mmh3 hash function",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -s m -rl <Expected Read Length> -re <Expected Read Error> -tm <Number of target matches per read> -hf mmh3_128 -so -sl <Location to save the generated screens>\n```\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example 6: Use a clustered uniform-sampling approach with corresponding read sets, with clustering done using a sketch size of 250, with a specified number of reads  loaded at a time, the default hash function, and read logging active",
        "parent_header": [
          "Implementation Details",
          "Syntax Examples"
        ],
        "type": "Text_excerpt",
        "value": "```\njava -cp screen_java:jars/\\* Main -g <Genomes Directory> -r <Reads Directory> -o <Log File location> -s u -f <Screen Size> -c -cs <Number of reads to be loaded at a time> -rlg -rlc <Location to save the read logs> -ct -css 250\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/arun96/sketching/master/README.md",
      "technique": "header_analysis"
    }
  ]
}
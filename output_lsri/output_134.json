{
  "application_domain": [
    {
      "confidence": 20.12,
      "result": {
        "type": "String",
        "value": "Natural Language Processing"
      },
      "technique": "supervised_classification"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/YanyZeng/mbDenoise"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2021-06-27T15:42:27Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2023-11-15T03:42:51Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "Marker gene and metagenomic sequencing studies have illustrated the importance of microbial communities for human and environmental health. However, the analysis of microbiome data has several caveats and technical challenges. One of the major issues is that count matrices contain a large proportion of zeros, some of which are biological zeros, whereas others are technical zeros. In addition, the measurements suffer from unequal sequencing depth, overdispersion, and data redundancy. These nuisance factors introduce substantial noise, which distorts the biological signal and hinders downstream analyses. To address these challenges, we propose mbDenoise, an accurate and robust method for denoising microbiome data. mbDenoise assumes a zero-inflated probabilistic PCA (ZIPPCA) model consisting of a point mass at zero and a negative binomial component. It uses variational approximation to learn the latent structure, borrowing information across samples and taxa, and then recovers the true underlying abundance levels using the posterior mean. We evaluate the performance of mbDenoise and compare it to state-of-the-art methods, using both simulated and real datasets, in terms of unconstrained ordination, alpha and beta diversity analysis, and differential abundance testing. mbDenoise outperforms existing methods to extract the signal for high-level analyses. "
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Description",
        "type": "Text_excerpt",
        "value": "Marker gene and metagenomic sequencing studies have illustrated the importance of microbial communities for human and environmental health. However, the analysis of microbiome data has several caveats and technical challenges. One of the major issues is that count matrices contain a large proportion of zeros, some of which are biological zeros, whereas others are technical zeros. In addition, the measurements suffer from unequal sequencing depth, overdispersion, and data redundancy. These nuisance factors introduce substantial noise, which distorts the biological signal and hinders downstream analyses. To address these challenges, we propose mbDenoise, an accurate and robust method for denoising microbiome data. mbDenoise assumes a zero-inflated probabilistic PCA (ZIPPCA) model consisting of a point mass at zero and a negative binomial component. It uses variational approximation to learn the latent structure, borrowing information across samples and taxa, and then recovers the true underlying abundance levels using the posterior mean. We evaluate the performance of mbDenoise and compare it to state-of-the-art methods, using both simulated and real datasets, in terms of unconstrained ordination, alpha and beta diversity analysis, and differential abundance testing. mbDenoise outperforms existing methods to extract the signal for high-level analyses. \n"
      },
      "source": "https://raw.githubusercontent.com/YanyZeng/mbDenoise/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.9689721346825565,
      "result": {
        "original_header": "mbDenoise",
        "type": "Text_excerpt",
        "value": "Microbiome data denoising framework (mbDenoise) with zero-inflated probabilistic PCA, which can be used for downstream high-level statistical analysis, including ordination, compositional normalization, differential abundance analysis, etc.\n \n"
      },
      "source": "https://raw.githubusercontent.com/YanyZeng/mbDenoise/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/YanyZeng/mbDenoise/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 0
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/YanyZeng/mbDenoise/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "YanyZeng/mbDenoise"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "mbDenoise"
      },
      "source": "https://raw.githubusercontent.com/YanyZeng/mbDenoise/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Installation",
        "type": "Text_excerpt",
        "value": "You can also install the released version of mbDenoise from github with:\n\n``` r\ninstall.packages(\"devtools\")  \ndevtools::install_github(\"YanyZeng/mbDenoise\")  \nlibrary(mbDenoise)\n```"
      },
      "source": "https://raw.githubusercontent.com/YanyZeng/mbDenoise/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/YanyZeng/mbDenoise/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "mbDenoise"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "User",
        "value": "YanyZeng"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "R",
        "size": 81937,
        "type": "Programming_language",
        "value": "R"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YanyZeng/mbDenoise/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "somef_missing_categories": [
    "citation",
    "acknowledgement",
    "run",
    "download",
    "requirements",
    "contact",
    "contributors",
    "documentation",
    "license",
    "faq",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-10-05 23:53:15",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 5
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Usage",
        "type": "Text_excerpt",
        "value": "mbDenoise is based on zero-inflated probabilistic PCA with logistical normal multinomial (ZIPPCA-LNM),\nPoisson (ZIPPCA-Poi) and negative-binomial model (ZIPPCA-NB). And mbDenoise with ZIPPCA-NB model is recommended for empirical data analysis.\n\n```r\nZIPPCApn(X,V = NULL,family = \"negative.binomial\",n.factors = 2,rank = FALSE,trace = FALSE,\n          maxit = 100,parallel = TRUE)\n\nZIPPCAlnm(X,V = NULL,n.factors = 2,rank = FALSE,trace = FALSE,maxit = 100,parallel = TRUE)\n```\n* X: matrix of observations.\n* V: vector of the sample covariate.\n* family: distribution of models. Two options are \"poisson\" and \"negative.binomial\". Defaults to \"negative.binomial\".\n* n.factors: the rank or number of factors, after dimensional reduction. Defaults to 2.\n* rank: logical, if TRUE, the rank or number of factors, is chosen from 1 to 5 by HIC (hybrid information criterion) in ZIPPCApn function and BIC (Bayesian information criterion) in ZIPPCAlnm function. Defaults to FALSE.\n* trace: logical, defaults to FALSE. if TRUE each current iteration step information will be printed.\n* maxit: maximum number of iterations within optim and constrOptim function, defaults to 100.\n* parallel: logical, if TRUE, use parallel toolbox to accelerate.\n"
      },
      "source": "https://raw.githubusercontent.com/YanyZeng/mbDenoise/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example",
        "type": "Text_excerpt",
        "value": "We use a microbiome dataset of Dhakan et al (2019) as a basic example which shows you how to solve a common problem and demonstrates the use of mbDenoise.\n\n``` r\n## Data preparing\n  DhakanDB <- curatedMetagenomicData::curatedMetagenomicData(\"DhakanDB_2019.metaphlan_bugs_list.stool\",\n                                                 counts=TRUE, dryrun=FALSE, bugs.as.phyloseq=TRUE)\n  DhakanDB_species <- phyloseq::tax_glom(DhakanDB$DhakanDB_2019.metaphlan_bugs_list.stool, taxrank=\"Species\")\n  DhakanDB_species_tax <- tax_table(DhakanDB_species )\n  DhakanDB_species_otu <- as.data.frame(t(otu_table(DhakanDB_species)))\n  DhakanDB_species_sample <- as.data.frame( sample_data(DhakanDB_species))\n  DhakanDB_species_sample <- DhakanDB_species_sample[18.49<DhakanDB_species_sample$BMI &DhakanDB_species_sample$BMI<25,]\n  DhakanDB_species_sample <- DhakanDB_species_sample[complete.cases(DhakanDB_species_sample$BMI),]\n  DhakanDB_species_sample <- DhakanDB_species_sample[order(DhakanDB_species_sample$location),]\n  DhakanDB_species_otu <- DhakanDB_species_otu[rownames(DhakanDB_species_sample),]\n  \n  zerocol <- which(colSums(DhakanDB_species_otu)==0)\n  if(length(zerocol) >0 ){\n    DhakanDB_species_otu <- DhakanDB_species_otu[,-zerocol];\n  }\n  dim(DhakanDB_species_otu)\n  \n  X1 <- DhakanDB_species_otu\n  group1 <-   DhakanDB_species_sample$location\n  Z1 <- ifelse(group1==\"Bhopal\",1,0)\n  \n  DhakanDB_species_sample2 <- DhakanDB_species_sample[DhakanDB_species_sample$location==\"Bhopal\",]\n  DhakanDB_species_otu2 <- DhakanDB_species_otu[rownames(DhakanDB_species_sample2),]\n  \n  zerocol <- which(colSums(DhakanDB_species_otu2)==0)\n  if(length(zerocol) >0 ){\n    DhakanDB_species_otu2 <- DhakanDB_species_otu2[,-zerocol];\n  }\n  dim(DhakanDB_species_otu2)\n\n  X2 <- DhakanDB_species_otu2\n  Z2 <- c(rep(0,round(length(DhakanDB_species_sample2$location)/2)),rep(1,length(DhakanDB_species_sample2$location)-round(length(DhakanDB_species_sample2$location)/2)))\n  group2 <- ifelse(Z2==0,\"Bhopal\",\"Kerala\")\n  \n  group <- list(group1,group2);\n  X <- list(as.matrix(X1),as.matrix(X2))\n  Z <- list(Z1,Z2)\n  n <- length(X)\n  \n## Fitting models  \n  ZINB <- list(data1=NULL,data2=NULL); ZINB_cov <- list(data1=NULL,data2=NULL)\n  for(i in 1:n){\n  ZINB[[i]] <- tryCatch({ZIPPCApn(X[[i]],rank = T)},\n                        error=function(e){ NULL})\n  ZINB_cov[[i]] <- tryCatch({ZIPPCApn(X[[i]],Z[[i]],rank = T)},\n                            error=function(e){ NULL})\n}\n\n## Ordination analysis (beta diversity)\n#mbDenoise-zinb\n   adonis_result_dis = adonis2(dist(ZINB[[i]]$lvs$factor_scores2)~group[[i]],method = \"euclidean\")\n    p1 <- ggplot(data.frame(ZINB[[i]]$lvs$factor_scores2),aes(x=ZINB[[i]]$lvs$factor_scores2[,1], y=ZINB[[i]]$lvs$factor_scores2[,2],colour=as.factor(group[[i]]))) +\n      geom_point( size = 2) + scale_colour_brewer(palette = \"Set1\")+\n      xlab(\"mbDenoise-zinb F1\")+ylab(\"mbDenoise-zinb F2\")+ labs(colour=\"Location\") +\n      theme_bw()+\n      stat_ellipse(aes(fill=factor(group[[i]],level=c(\"Bhopal\",\"Kerala\"))),type = \"norm\", geom = \"polygon\",alpha= 0.1,show.legend = F,linetype=2)+\n      annotate(\"text_npc\", npcx = \"left\", npcy = \"top\", parse=T,label= paste0('atop(p ==', adonis_result_dis$`Pr(>F)`[1], ', R^2 ==', round(adonis_result_dis$R2[1],2), ')'))\n    \n    X_new <- log2(ZINB[[i]]$muz+1)\n    ZINB_pca[[i]] <- prcomp(X_new)\n    dist_bray <- vegan::vegdist(X_new, method=\"bray\")\n    ZINB_pcoa[[i]] <- ape::pcoa(dist_bray)\n    set.seed(4)\n    ZINB_tsne[[i]] <- Rtsne::Rtsne(X_new,initial_dims = ncol(X_new),perplexity=round((nrow(X_new)-2)/3))\n    \n#mbDenoise-zinb_pca   \n    adonis_result_dis = adonis2(dist(ZINB_pca[[i]]$x[,1:2])~group[[i]],method = \"euclidean\")\n    p2 <- ggplot(data.frame(ZINB_pca[[i]]$x[,1:2]),aes(ZINB_pca[[i]]$x[,1], y=ZINB_pca[[i]]$x[,2],colour=as.factor(group[[i]]))) +\n      geom_point( size = 2) + scale_colour_brewer(palette = \"Set1\")+\n      xlab(\"mbDenoise-zinb_pca F1\")+ylab(\"mbDenoise-zinb_pca F2\")+ labs(colour=\"Location\") +\n      theme_bw()+\n      stat_ellipse(aes(fill=factor(group[[i]],level=c(\"Bhopal\",\"Kerala\"))),type = \"norm\", geom = \"polygon\",alpha= 0.1,show.legend = F,linetype=2)+\n      annotate(\"text_npc\", npcx = \"left\", npcy = \"top\", parse=T,label= paste0('atop(p ==', adonis_result_dis$`Pr(>F)`[1], ', R^2 ==', round(adonis_result_dis$R2[1],2), ')'))\n    \n#mbDenoise-zinb_pcoa\n    adonis_result_dis = adonis2(dist(ZINB_pcoa[[i]]$vectors[,1:2])~group[[i]],method = \"euclidean\")\n    p3 <- ggplot(data.frame(ZINB_pcoa[[i]]$vectors[,1:2]),aes(ZINB_pcoa[[i]]$vectors[,1], y=ZINB_pcoa[[i]]$vectors[,2],colour=as.factor(group[[i]]))) +\n      geom_point( size = 2) + scale_colour_brewer(palette = \"Set1\")+\n      xlab(\"mbDenoise-zinb_pcoa F1\")+ylab(\"mbDenoise-zinb_pcoa F2\")+ labs(colour=\"Location\") +\n      theme_bw()+\n      stat_ellipse(aes(fill=factor(group[[i]],level=c(\"Bhopal\",\"Kerala\"))),type = \"norm\", geom = \"polygon\",alpha= 0.1,show.legend = F,linetype=2)+\n      annotate(\"text_npc\", npcx = \"left\", npcy = \"top\", parse=T,label= paste0('atop(p ==', adonis_result_dis$`Pr(>F)`[1], ', R^2 ==', round(adonis_result_dis$R2[1],2), ')'))\n    \n#mbDenoise-zinb_tsne\n    adonis_result_dis = adonis2(dist(ZINB_tsne[[i]]$Y)~group[[i]],method = \"euclidean\")\n    p4 <- ggplot(data.frame(ZINB_tsne[[i]]$Y),aes(ZINB_tsne[[i]]$Y[,1], y=ZINB_tsne[[i]]$Y[,2],colour=as.factor(group[[i]]))) +\n      geom_point(size = 2) + scale_colour_brewer(palette = \"Set1\")+\n      xlab(\"mbDenoise-zinb_tsne F1\")+ylab(\"mbDenoise-zinb_tsne F2\")+ labs(colour=\"Location\") +\n      theme_bw()+\n      stat_ellipse(aes(fill=factor(group[[i]],level=c(\"Bhopal\",\"Kerala\"))),type = \"norm\", geom = \"polygon\",alpha= 0.1,show.legend = F,linetype=2)+\n      annotate(\"text_npc\", npcx = \"left\", npcy = \"top\", parse=T,label= paste0('atop(p ==', adonis_result_dis$`Pr(>F)`[1], ', R^2 ==', round(adonis_result_dis$R2[1],2), ')'))\n\n## Compositional normalization analysis (alpha diversity)\n\n   diversity <- function(X){\n    # shannon index\n    sh_ele <- -X * log(X)\n    #sh_ele[is.nan(sh_ele)] <- 0\n    sh <- rowSums(sh_ele)\n    \n    # simpson index\n    sp  <- 1-rowSums(X * X)\n    \n    return(list(Shannon  = sh, Simpson  = sp))\n  }\n\n  zinb_div <-  list()\n  \n  for(i in 1:n){\n    #mbDenoise-zinb\n    zinb_div[[i]] <- diversity(ZINB[[i]]$Q)\n  }  \n\n## Differential abundance analysis\n  zinb <- zinb_p <- zinb_p_adj <- list()\n  for(i in 1:n){ \n  if(is.null(ZINB_cov[[i]])){\n    zinb_p[[i]] <- NaN;\n  }else{\n    X_new <- log2(ZINB_cov[[i]]$muz+1)\n\n    for(l in 1:ncol(X[[i]])){\n      zinb_p[[i]][l] <- tryCatch({t.test(X_new[,l]~Z[[i]])$p.value},error=function(e){ NaN})\n    }}\n  \n  zinb_p_adj[[i]] <- p.adjust(zinb_p[[i]],method = \"BH\")\n  zinb[[i]] <- na.omit(colnames(X[[i]])[(zinb_p_adj[[i]]) <0.05])\n\n}\n\n```\nReference:\n\nDhakan, D. et al. The unique composition of indian gut microbiome, gene catalogue, and\nassociated fecal metabolome deciphered using multi-omics approaches. Gigascience 8, giz004\n(2019).\n"
      },
      "source": "https://raw.githubusercontent.com/YanyZeng/mbDenoise/master/README.md",
      "technique": "header_analysis"
    }
  ]
}
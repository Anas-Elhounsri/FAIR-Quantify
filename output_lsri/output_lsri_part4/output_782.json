{
  "citation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "References",
        "parent_header": [
          "PDEparams"
        ],
        "type": "Text_excerpt",
        "value": "R. Storn, and K. Price. \u201cDifferential evolution\u2013a simple and efficient\nheuristic for global optimization over continuous spaces\u201d, *Journal of\nGlobal Optimization* **11(4)**, pp.\u00a0341-359 (1997).\n\nA. Raue, C. Kreutz, T. Maiwald, J. Bachmann, M. Schilling, U.\nKlingm\u00fcller, and J. Timmer. \u201cStructural and practical identifiability\nanalysis of partially observed dynamical models by exploiting the\nprofile likelihood\u201d, *Bioinformatics* **25(15)**, pp.\u00a01923-1929 (2009).\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/systemsmedicine/PDE_params"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2019-05-07T09:46:58Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-04-15T14:46:22Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "Parameter estimation for PDEs"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 0.9236095578250689,
      "result": {
        "original_header": "PDEparams",
        "type": "Text_excerpt",
        "value": "A module for parameter estimation in partial differential equations\n(PDEs) using the Differential Evolution (DE) algorithm.\n \n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/systemsmedicine/PDE_params/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "executable_example": [
    {
      "confidence": 1,
      "result": {
        "format": "jupyter_notebook",
        "type": "Url",
        "value": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/examples/TumourGrowth.ipynb"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/examples/TumourGrowth.ipynb",
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "format": "jupyter_notebook",
        "type": "Url",
        "value": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/examples/Fisher.ipynb"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/examples/Fisher.ipynb",
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "format": "jupyter_notebook",
        "type": "Url",
        "value": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/examples/LotkaVolterra.ipynb"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/examples/LotkaVolterra.ipynb",
      "technique": "file_exploration"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 3
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/systemsmedicine/PDE_params/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "systemsmedicine/PDE_params"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "PDEparams"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "images": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://latex.codecogs.com/png.latex?%28x%2C%20y%29"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://latex.codecogs.com/png.latex?f"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://latex.codecogs.com/png.latex?g"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "http://raw.githubusercontent.com/systemsmedicine/PDE_params/master/./img/data.png"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://latex.codecogs.com/png.latex?%28x_0%2C%20y_0%2C%20z_0%29"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://latex.codecogs.com/png.latex?%28x_0%2C%20y_0%2C%20z_1%29"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "http://raw.githubusercontent.com/systemsmedicine/PDE_params/master/./img/replicates.png"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://latex.codecogs.com/png.latex?t%3D0"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "http://raw.githubusercontent.com/systemsmedicine/PDE_params/master/./img/result_profiles.png"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "http://raw.githubusercontent.com/systemsmedicine/PDE_params/master/./img/plot_profiles.png"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "http://raw.githubusercontent.com/systemsmedicine/PDE_params/master/./img/summary_bootstrap.png"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "http://raw.githubusercontent.com/systemsmedicine/PDE_params/master/./img/raw_bootstrap.png"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "http://raw.githubusercontent.com/systemsmedicine/PDE_params/master/./img/plot_bootstrap.png"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/systemsmedicine/PDE_params/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "MIT License",
        "spdx_id": "MIT",
        "type": "License",
        "url": "https://api.github.com/licenses/mit",
        "value": "https://api.github.com/licenses/mit"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "MIT License\n\nCopyright (c) 2019 C\u00e9sar Parra Rojas\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/LICENSE",
      "technique": "file_exploration"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "PDE_params"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "Organization",
        "value": "systemsmedicine"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "Python",
        "size": 13968,
        "type": "Programming_language",
        "value": "Python"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "requirements": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Requirements",
        "parent_header": [
          "PDEparams"
        ],
        "type": "Text_excerpt",
        "value": "-   `python 3.x`\n-   `numpy`\n-   `pandas`\n-   `scipy`\n-   `scikit-learn`\n-   `tqdm>=4.29.0`\n-   `matplotlib` (plots only)\n-   `seaborn` (plots only)\n-   LaTeX (plots only)\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "somef_missing_categories": [
    "installation",
    "acknowledgement",
    "run",
    "download",
    "contact",
    "contributors",
    "documentation",
    "faq",
    "support",
    "identifier",
    "has_build_file"
  ],
  "somef_provenance": {
    "date": "2024-11-04 04:45:47",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 9
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Usage",
        "parent_header": [
          "PDEparams"
        ],
        "type": "Text_excerpt",
        "value": "The module consists of a constructor that prepares the data and the\nmodel to be fit, along with a series of routines to find the best fit\nparameters, compute likelihood profiles and perform bootstrapping, as\nwell as visualising the results.\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "The `PDEmodel` object",
        "parent_header": [
          "PDEparams",
          "Usage"
        ],
        "type": "Text_excerpt",
        "value": "The main component of the module, it is initialised as\n\n``` python\nimport PDEparams as pde\n\nmy_object = pde.PDEmodel(data, model, initfunc, bounds, param_names=None, nvars=1,\n                         ndims=1, nreplicates=1, obsidx=None, outfunc=None)\n```\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "1. `data`",
        "parent_header": [
          "PDEparams",
          "Usage",
          "The `PDEmodel` object",
          "Required arguments"
        ],
        "type": "Text_excerpt",
        "value": "The data is assumed to be in the form of a pandas `DataFrame`. You can\nconstruct a `DataFrame` directly from file as, *e.g.*,\n\n``` python\nimport pandas as pd\n\ndata = pd.read_csv('data_file.csv')\n\n# or\ndata = pd.read_excel('data_file.xlsx')\n```\n\nRefer to the [pandas\ndocumentation](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html)\nfor details. Another, not recommended, way of constructing the\n`DataFrame` is to manually input the values:\n\n``` python\ndata_values = [[t0, x0, f(t0,x0)], [t0, x1, f(t0,x1)], ..., [t1, x0, f(t1,x0)], [t1, x1, f(t1,x1)], ...]\n\ndata = pd.DataFrame(data_values)\n```\n\nThe data should be structured so that the first column corresponds to\nthe timepoints, followed by the spatial coordinates and the outputs. For\ninstance, the data for a two-dimensional system with coordinates\n![(x, y)](https://latex.codecogs.com/png.latex?%28x%2C%20y%29 \"(x, y)\")\nand two variables, ![f](https://latex.codecogs.com/png.latex?f \"f\") and\n![g](https://latex.codecogs.com/png.latex?g \"g\"), will have the form\n\n<img src=\"./img/data.png\" width=\"400\" alt=\"data\">\n\n**\\* Note the order in which the spatial coordinates are entered in the\ndata. The index of the right-most coordinate runs first; *e.g.*, for a\n3D system, after\n![(x\\_0, y\\_0, z\\_0)](https://latex.codecogs.com/png.latex?%28x_0%2C%20y_0%2C%20z_0%29 \"(x_0, y_0, z_0)\"),\n![(x\\_0, y\\_0, z\\_1)](https://latex.codecogs.com/png.latex?%28x_0%2C%20y_0%2C%20z_1%29 \"(x_0, y_0, z_1)\")\nshould follow.**<br> **\\*\\* The name of the columns is not important,\nthe dimensionality of the system is defined by the user with the\narguments `noutputs` and `ndims` (see below).**\n\nIf more than one measurement per space-time coordinate exists, they\nshould be entered consecutively, as in\n\n<img src=\"./img/replicates.png\" width=\"400\" alt=\"replicates\">\n\nWe refer to these as \u2018replicates\u2019. The number of replicates is\ncontrolled by the parameter `nreplicates` (see below). If you have one\ndata file per replicate\u2014let us say 3 different `.csv` files\u2014you can\nmerge them with\n\n``` python\ndata_1 = pd.read_csv('data_1.csv')\ndata_2 = pd.read_csv('data_2.csv')\ndata_3 = pd.read_csv('data_3.csv')\n\ndata = data_1.append([data_2, data_3], ignore_index=False).sort_index().reset_index(drop=True)\n```\n\nThis will result in a `DataFrame` where the first 3 rows correspond to\nthe first row of each of the data files, and so on, as in the picture\nabove.\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "2. `model`",
        "parent_header": [
          "PDEparams",
          "Usage",
          "The `PDEmodel` object",
          "Required arguments"
        ],
        "type": "Text_excerpt",
        "value": "This is the PDE or system of PDEs that fits the data. It should be\ndefined as a function of the initial condition, the time domain, the\nspatial grid, and the parameters to be estimated, and it should return\nthe *time derivative* of the variables in the system. It would look like\nthis:\n\n``` python\ndef my_pde(initial_condition, time_domain, spatial_grid, parameter_1, parameter_2, ...):\n\n  variables = ... # preprocessing of initial condition\n\n  dobs_dt = ... # the equation for the time derivative\n\n  dobs_dt[boundaries] = ... # boundary conditions\n\n  output = ... # postprocessing of dobs_dt\n\n  return output\n```\n\nThe preprocessing step mentioned above corresponds to retrieving the\nactual shape of the system given the input: the integration is handled\nusing `scipy`\u2019s `odeint`, which only accepts one-dimensional inputs. If\nwe imagine a system of 2 equations in 1 spatial dimension, we need to\nfeed the initial condition for both variables as one long array, instead\nof two arrays. The preprocessing step then retrieves these two original\narrays; after the time derivative is calculated for both variables, the\npostprocessing converts the two derivatives into one long derivative.\nWhile more convoluted, the idea is the same for a larger number of\nspatial dimensions.\n\nThe module takes care of feeding the model the correct one-dimensional\ninput regardless of the actual dimensionality of the problem. The\npreprocessing inside the model needs to be hardcoded, but full\nillustrations appear in the [examples directory](./examples/).\n\n**Note that the module also works for ODEs\u2014see details below and in the\n[examples directory](./examples/). In this case, the definition of the\nsystem should not include the `spatial_grid` argument.**\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "3. `initfunc`",
        "parent_header": [
          "PDEparams",
          "Usage",
          "The `PDEmodel` object",
          "Required arguments"
        ],
        "type": "Text_excerpt",
        "value": "This is the initial condition generator. Each of the variables in the\nsystem will have an initial condition that is a function of the spatial\ngrid, as in\n\n``` python\ndef initial_f(grid_point):\n  ...\n\ndef initial_g(grid_point):\n  ...\n```\n\n`initfunc` should be a list comprising those functions:\n\n``` python\ninitfunc = [initial_f, initial_g]\n```\n\nSee more details in the [examples directory](./examples/).\n\n**For ODEs, the initial condition should still be defined as a function\nfor each of the variables in the system.**\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "4. `bounds`",
        "parent_header": [
          "PDEparams",
          "Usage",
          "The `PDEmodel` object",
          "Required arguments"
        ],
        "type": "Text_excerpt",
        "value": "The optimisation performed by DE is constrained and, therefore, bounds\nfor the parameter values must be provided. These should be in the form\nof a tuple of tuples or list of tuples.\n\n``` python\nbounds = ((lower_1, upper_1), (lower_2, upper_2) ...)\n\n# or\nbounds = [(lower_1, upper_1), (lower_2, upper_2) ...]\n```\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "1. `param_names`",
        "parent_header": [
          "PDEparams",
          "Usage",
          "The `PDEmodel` object",
          "Optional arguments"
        ],
        "type": "Text_excerpt",
        "value": "List of parameter names, for use in plots and output tables. If not\nspecified, they will be called `'parameter_1'`, `'parameter_2'`, etc.\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "2. `nvars`",
        "parent_header": [
          "PDEparams",
          "Usage",
          "The `PDEmodel` object",
          "Optional arguments"
        ],
        "type": "Text_excerpt",
        "value": "The number of variables in the system of equations. If not specified, it\nis assumed to be 1.\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "3. `ndims`",
        "parent_header": [
          "PDEparams",
          "Usage",
          "The `PDEmodel` object",
          "Optional arguments"
        ],
        "type": "Text_excerpt",
        "value": "The number of spatial coordinates in the data\u2014`ndims=0` for ODEs. If not\nspecified, it is assumed to be 1.\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "4. `nreplicates`",
        "parent_header": [
          "PDEparams",
          "Usage",
          "The `PDEmodel` object",
          "Optional arguments"
        ],
        "type": "Text_excerpt",
        "value": "The number of measurements per space-time coordinate in the data. If not\nspecified, it is assumed to be 1.\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "5. `obsidx`",
        "parent_header": [
          "PDEparams",
          "Usage",
          "The `PDEmodel` object",
          "Optional arguments"
        ],
        "type": "Text_excerpt",
        "value": "In the case when not all variables in the system are actually observed,\nwe need to specify for which of them we have data. `obsidx` is a list of\nindices, starting from zero, corresponding to the position of the\nobserved variables in the model we have defined. For instance, if we\nhave a three-dimensional state vector with data for the second and third\nvariables, we should pass\n\n``` python\nobsidx=[1,2]\n```\n\nIf only one variable is observed, `obsidx` can be either an integer or a\nlist of one integer. In the case above, if we now have data only for the\nthird variable:\n\n``` python\nobsidx=2\n\n# or\nobsidx=[2]\n```\n\n`obsidx` defaults to `None`, meaning that all variables are measured.\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "6. `outfunc`",
        "parent_header": [
          "PDEparams",
          "Usage",
          "The `PDEmodel` object"
        ],
        "type": "Text_excerpt",
        "value": "Sometimes we do not have data for the raw variables in the system but\nrather a function of them. This is specified by `outfunc`, which\ndefaults to `None`, meaning we have data for the raw outputs. For\ninstance, if we can only measure the square of the third variable in a\nthree-dimensional system, we should define\n\n``` python\ndef outfunc(state_vector):\n  x, y, z = state_vector\n\n  return z**2\n```\n\nand pass this argument to the `PDEmodel` constructor.\n\n**Note that, if `outfunc` is specified, the argument `obsidx` is\noverridden. The function is always a function of the full state vector,\neven if the actual measured quantity only involves a few of the\nvariables, as shown above.**\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Functions and attributes",
        "parent_header": [
          "PDEparams",
          "Usage"
        ],
        "type": "Text_excerpt",
        "value": "Upon construction, the initial condition functions are applied to the\nspatial grid and stored in the attribute `initial_condition`\u2014for the\nexample above, this can be retrieved by calling\n`my_object.initial_condition`. As a sanity check, it may be helpful to\nplot this initial condition; this is not part of the module, but the\n[examples directory](./examples/) contains some visualisation code.\n\nAdditionally, the time-step between the first and second datapoints is\nobtained, and an array of timepoints is constructed starting from\n![t=0](https://latex.codecogs.com/png.latex?t%3D0 \"t=0\") and ending at\nthe first datapoint, using this time-step. This is prepended to the\ntimepoints in the data and stored as the attribute `time`.\n\nOther attributes include: - `model` - `data` - `nvars` - `spacedims`:\nthe value of `ndims` in the input - `nparams`: the number of parameters\n- `space`: the spatial grid\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Finding the best fit",
        "parent_header": [
          "PDEparams",
          "Usage",
          "Functions and attributes"
        ],
        "type": "Text_excerpt",
        "value": "The optimisation is carried out by calling\n\n``` python\nmy_object.fit()\n```\n\nIf no argument is given, the cost function to minimise will be the mean\nsquared error. For other cost functions, you need to provide the `error`\nargument; for instance, for the root mean squared error:\n\n``` python\nmy_object.fit(error='rmse')\n```\n\nPossible choices for `error` are: \n- `'mse'`: mean squared error\n- `'rmse'`: root mean squared error\n- `'msle'`: mean squared logarithmic error\n- `'rmsle'`: root mean squared logarithmic error\n- `'mae'`: mean absolute error\n- `'medae'`: median absolute error\n\nThe results are displayed on screen and stored in the attribute\n`best_params`, while the optimum value of the cost function is stored in\nthe attribute `best_error`.\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Computing likelihood profiles",
        "parent_header": [
          "PDEparams",
          "Usage",
          "Functions and attributes"
        ],
        "type": "Text_excerpt",
        "value": "Likelihood profiles are computed for each parameter by fixing its value\nand refitting the rest of the parameters. This is done using\n\n``` python\nmy_object.likelihood_profiles()\n```\n\nA list of parameter values to try can be explicitly given for each parameter in the model, using the optional argument `param_values`&mdash;this should be a list of lists or a list of arrays, and its size must coincide with the number of parameters. For instance, in oder to use the values `[1,2,3]` for the first and `[4,5,6]` for the second parameter in a model with two parameters, use\n\n``` python\nmy_object.likelihood_profiles(param_values=[[1,2,3], [4,5,6]])\n```\n\nIf no explicit values are provided, the likelihood profiles will be computed using a regular grid within the parameter bounds for each parameter. There is a second optional argument, `npoints`, that controls the number of points to use in the grid. If no argument is given, a regular grid of 100 points will be used per parameter. For, *e.g.*, 250 points per parameter, use\n\n``` python\nmy_object.likelihood_profiles(npoints=250)\n```\n\nThe full results are stored as a `DataFrame` in the form\n\n![result\\_profiles](./img/result_profiles.png)\n\nand can be retrieved with `my_object.likelihood_profiles`\n\nFor a quick look at the profiles, use\n\n``` python\nmy_object.plot_profiles()\n```\n\nYou should see something like this:\n\n![plot\\_profiles](./img/plot_profiles.png)\n\nIf the best fit parameters have already been obtained via the `fit()`\nfunction, the cost function to be used for the likelihood profiles will\nmatch the original cost function\u2014additionally, the best fit parameters\nwill be highlighted in the plots. If not, the likelihood profiles will\nbe computed with the default mean squared error.\n\n#### Bootstrapping (only for `nreplicates>1`)\n\nBootstrapping is carried out by randomly choosing one replicate per\nspatio-temporal coordinate and refitting all parameters in multiple\nrounds. Done using\n\n``` python\nmy_object.bootstrap()\n```\n\nIf no argument is given, the process is repeated 100 times. For other\nconfigurations, use the optional `nruns` argument; *e.g.*,\n\n``` python\nmy_object.bootstrap(nruns=250)\n```\n\nA summary of the results is displayed on screen and stored as a\n`DataFrame` in the attribute `bootstrap_summary`, while the full results\nare stored as a `DataFrame` in the attribute `bootstrap_raw`.\nRespectively,\n\n**Summary:**\n\n![summary\\_bootstrap](./img/summary_bootstrap.png)\n\n**Full:**\n\n![raw\\_bootstrap](./img/raw_bootstrap.png)\n\nFor a quick look at the results, use\n\n``` python\nmy_object.plot_bootstrap()\n```\n\nYou should see something like this:\n\n![plot\\_bootstrap](./img/plot_bootstrap.png)\n\nIf the best fit parameters have already been obtained via the `fit()`\nfunction, the cost function to be used for bootstrapping will match the\noriginal cost function\u2014additionally, the best fit parameters will be\nhighlighted in the plots. If not, the default mean squared error will be\nused.\n\nReferences\n----------\n\nR. Storn, and K. Price. \u201cDifferential evolution\u2013a simple and efficient\nheuristic for global optimization over continuous spaces\u201d, *Journal of\nGlobal Optimization* **11(4)**, pp.\u00a0341-359 (1997).\n\nA. Raue, C. Kreutz, T. Maiwald, J. Bachmann, M. Schilling, U.\nKlingm\u00fcller, and J. Timmer. \u201cStructural and practical identifiability\nanalysis of partially observed dynamical models by exploiting the\nprofile likelihood\u201d, *Bioinformatics* **25(15)**, pp.\u00a01923-1929 (2009).\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Bootstrapping (only for `nreplicates&gt;1`)",
        "parent_header": [
          "PDEparams",
          "Usage",
          "Functions and attributes"
        ],
        "type": "Text_excerpt",
        "value": "=========\n\nA module for parameter estimation in partial differential equations\n(PDEs) using the Differential Evolution (DE) algorithm.\n\nRequirements\n------------\n\n-   `python 3.x`\n-   `numpy`\n-   `pandas`\n-   `scipy`\n-   `scikit-learn`\n-   `tqdm>=4.29.0`\n-   `matplotlib` (plots only)\n-   `seaborn` (plots only)\n-   LaTeX (plots only)\n\nUsage\n-----\n\nThe module consists of a constructor that prepares the data and the\nmodel to be fit, along with a series of routines to find the best fit\nparameters, compute likelihood profiles and perform bootstrapping, as\nwell as visualising the results.\n\n### The `PDEmodel` object\n\nThe main component of the module, it is initialised as\n\n``` python\nimport PDEparams as pde\n\nmy_object = pde.PDEmodel(data, model, initfunc, bounds, param_names=None, nvars=1,\n                         ndims=1, nreplicates=1, obsidx=None, outfunc=None)\n```\n\n#### Required arguments\n\n##### 1. `data`\n\nThe data is assumed to be in the form of a pandas `DataFrame`. You can\nconstruct a `DataFrame` directly from file as, *e.g.*,\n\n``` python\nimport pandas as pd\n\ndata = pd.read_csv('data_file.csv')\n\n# or\ndata = pd.read_excel('data_file.xlsx')\n```\n\nRefer to the [pandas\ndocumentation](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html)\nfor details. Another, not recommended, way of constructing the\n`DataFrame` is to manually input the values:\n\n``` python\ndata_values = [[t0, x0, f(t0,x0)], [t0, x1, f(t0,x1)], ..., [t1, x0, f(t1,x0)], [t1, x1, f(t1,x1)], ...]\n\ndata = pd.DataFrame(data_values)\n```\n\nThe data should be structured so that the first column corresponds to\nthe timepoints, followed by the spatial coordinates and the outputs. For\ninstance, the data for a two-dimensional system with coordinates\n![(x, y)](https://latex.codecogs.com/png.latex?%28x%2C%20y%29 \"(x, y)\")\nand two variables, ![f](https://latex.codecogs.com/png.latex?f \"f\") and\n![g](https://latex.codecogs.com/png.latex?g \"g\"), will have the form\n\n<img src=\"./img/data.png\" width=\"400\" alt=\"data\">\n\n**\\* Note the order in which the spatial coordinates are entered in the\ndata. The index of the right-most coordinate runs first; *e.g.*, for a\n3D system, after\n![(x\\_0, y\\_0, z\\_0)](https://latex.codecogs.com/png.latex?%28x_0%2C%20y_0%2C%20z_0%29 \"(x_0, y_0, z_0)\"),\n![(x\\_0, y\\_0, z\\_1)](https://latex.codecogs.com/png.latex?%28x_0%2C%20y_0%2C%20z_1%29 \"(x_0, y_0, z_1)\")\nshould follow.**<br> **\\*\\* The name of the columns is not important,\nthe dimensionality of the system is defined by the user with the\narguments `noutputs` and `ndims` (see below).**\n\nIf more than one measurement per space-time coordinate exists, they\nshould be entered consecutively, as in\n\n<img src=\"./img/replicates.png\" width=\"400\" alt=\"replicates\">\n\nWe refer to these as \u2018replicates\u2019. The number of replicates is\ncontrolled by the parameter `nreplicates` (see below). If you have one\ndata file per replicate\u2014let us say 3 different `.csv` files\u2014you can\nmerge them with\n\n``` python\ndata_1 = pd.read_csv('data_1.csv')\ndata_2 = pd.read_csv('data_2.csv')\ndata_3 = pd.read_csv('data_3.csv')\n\ndata = data_1.append([data_2, data_3], ignore_index=False).sort_index().reset_index(drop=True)\n```\n\nThis will result in a `DataFrame` where the first 3 rows correspond to\nthe first row of each of the data files, and so on, as in the picture\nabove.\n\n##### 2. `model`\n\nThis is the PDE or system of PDEs that fits the data. It should be\ndefined as a function of the initial condition, the time domain, the\nspatial grid, and the parameters to be estimated, and it should return\nthe *time derivative* of the variables in the system. It would look like\nthis:\n\n``` python\ndef my_pde(initial_condition, time_domain, spatial_grid, parameter_1, parameter_2, ...):\n\n  variables = ... # preprocessing of initial condition\n\n  dobs_dt = ... # the equation for the time derivative\n\n  dobs_dt[boundaries] = ... # boundary conditions\n\n  output = ... # postprocessing of dobs_dt\n\n  return output\n```\n\nThe preprocessing step mentioned above corresponds to retrieving the\nactual shape of the system given the input: the integration is handled\nusing `scipy`\u2019s `odeint`, which only accepts one-dimensional inputs. If\nwe imagine a system of 2 equations in 1 spatial dimension, we need to\nfeed the initial condition for both variables as one long array, instead\nof two arrays. The preprocessing step then retrieves these two original\narrays; after the time derivative is calculated for both variables, the\npostprocessing converts the two derivatives into one long derivative.\nWhile more convoluted, the idea is the same for a larger number of\nspatial dimensions.\n\nThe module takes care of feeding the model the correct one-dimensional\ninput regardless of the actual dimensionality of the problem. The\npreprocessing inside the model needs to be hardcoded, but full\nillustrations appear in the [examples directory](./examples/).\n\n**Note that the module also works for ODEs\u2014see details below and in the\n[examples directory](./examples/). In this case, the definition of the\nsystem should not include the `spatial_grid` argument.**\n\n##### 3. `initfunc`\n\nThis is the initial condition generator. Each of the variables in the\nsystem will have an initial condition that is a function of the spatial\ngrid, as in\n\n``` python\ndef initial_f(grid_point):\n  ...\n\ndef initial_g(grid_point):\n  ...\n```\n\n`initfunc` should be a list comprising those functions:\n\n``` python\ninitfunc = [initial_f, initial_g]\n```\n\nSee more details in the [examples directory](./examples/).\n\n**For ODEs, the initial condition should still be defined as a function\nfor each of the variables in the system.**\n\n##### 4. `bounds`\n\nThe optimisation performed by DE is constrained and, therefore, bounds\nfor the parameter values must be provided. These should be in the form\nof a tuple of tuples or list of tuples.\n\n``` python\nbounds = ((lower_1, upper_1), (lower_2, upper_2) ...)\n\n# or\nbounds = [(lower_1, upper_1), (lower_2, upper_2) ...]\n```\n\n#### Optional arguments\n\n##### 1. `param_names`\n\nList of parameter names, for use in plots and output tables. If not\nspecified, they will be called `'parameter_1'`, `'parameter_2'`, etc.\n\n##### 2. `nvars`\n\nThe number of variables in the system of equations. If not specified, it\nis assumed to be 1.\n\n##### 3. `ndims`\n\nThe number of spatial coordinates in the data\u2014`ndims=0` for ODEs. If not\nspecified, it is assumed to be 1.\n\n##### 4. `nreplicates`\n\nThe number of measurements per space-time coordinate in the data. If not\nspecified, it is assumed to be 1.\n\n##### 5. `obsidx`\n\nIn the case when not all variables in the system are actually observed,\nwe need to specify for which of them we have data. `obsidx` is a list of\nindices, starting from zero, corresponding to the position of the\nobserved variables in the model we have defined. For instance, if we\nhave a three-dimensional state vector with data for the second and third\nvariables, we should pass\n\n``` python\nobsidx=[1,2]\n```\n\nIf only one variable is observed, `obsidx` can be either an integer or a\nlist of one integer. In the case above, if we now have data only for the\nthird variable:\n\n``` python\nobsidx=2\n\n# or\nobsidx=[2]\n```\n\n`obsidx` defaults to `None`, meaning that all variables are measured.\n\n#### 6. `outfunc`\n\nSometimes we do not have data for the raw variables in the system but\nrather a function of them. This is specified by `outfunc`, which\ndefaults to `None`, meaning we have data for the raw outputs. For\ninstance, if we can only measure the square of the third variable in a\nthree-dimensional system, we should define\n\n``` python\ndef outfunc(state_vector):\n  x, y, z = state_vector\n\n  return z**2\n```\n\nand pass this argument to the `PDEmodel` constructor.\n\n**Note that, if `outfunc` is specified, the argument `obsidx` is\noverridden. The function is always a function of the full state vector,\neven if the actual measured quantity only involves a few of the\nvariables, as shown above.**\n\n### Functions and attributes\n\nUpon construction, the initial condition functions are applied to the\nspatial grid and stored in the attribute `initial_condition`\u2014for the\nexample above, this can be retrieved by calling\n`my_object.initial_condition`. As a sanity check, it may be helpful to\nplot this initial condition; this is not part of the module, but the\n[examples directory](./examples/) contains some visualisation code.\n\nAdditionally, the time-step between the first and second datapoints is\nobtained, and an array of timepoints is constructed starting from\n![t=0](https://latex.codecogs.com/png.latex?t%3D0 \"t=0\") and ending at\nthe first datapoint, using this time-step. This is prepended to the\ntimepoints in the data and stored as the attribute `time`.\n\nOther attributes include: - `model` - `data` - `nvars` - `spacedims`:\nthe value of `ndims` in the input - `nparams`: the number of parameters\n- `space`: the spatial grid\n\n#### Finding the best fit\n\nThe optimisation is carried out by calling\n\n``` python\nmy_object.fit()\n```\n\nIf no argument is given, the cost function to minimise will be the mean\nsquared error. For other cost functions, you need to provide the `error`\nargument; for instance, for the root mean squared error:\n\n``` python\nmy_object.fit(error='rmse')\n```\n\nPossible choices for `error` are: \n- `'mse'`: mean squared error\n- `'rmse'`: root mean squared error\n- `'msle'`: mean squared logarithmic error\n- `'rmsle'`: root mean squared logarithmic error\n- `'mae'`: mean absolute error\n- `'medae'`: median absolute error\n\nThe results are displayed on screen and stored in the attribute\n`best_params`, while the optimum value of the cost function is stored in\nthe attribute `best_error`.\n\n#### Computing likelihood profiles\n\nLikelihood profiles are computed for each parameter by fixing its value\nand refitting the rest of the parameters. This is done using\n\n``` python\nmy_object.likelihood_profiles()\n```\n\nA list of parameter values to try can be explicitly given for each parameter in the model, using the optional argument `param_values`&mdash;this should be a list of lists or a list of arrays, and its size must coincide with the number of parameters. For instance, in oder to use the values `[1,2,3]` for the first and `[4,5,6]` for the second parameter in a model with two parameters, use\n\n``` python\nmy_object.likelihood_profiles(param_values=[[1,2,3], [4,5,6]])\n```\n\nIf no explicit values are provided, the likelihood profiles will be computed using a regular grid within the parameter bounds for each parameter. There is a second optional argument, `npoints`, that controls the number of points to use in the grid. If no argument is given, a regular grid of 100 points will be used per parameter. For, *e.g.*, 250 points per parameter, use\n\n``` python\nmy_object.likelihood_profiles(npoints=250)\n```\n\nThe full results are stored as a `DataFrame` in the form\n\n![result\\_profiles](./img/result_profiles.png)\n\nand can be retrieved with `my_object.likelihood_profiles`\n\nFor a quick look at the profiles, use\n\n``` python\nmy_object.plot_profiles()\n```\n\nYou should see something like this:\n\n![plot\\_profiles](./img/plot_profiles.png)\n\nIf the best fit parameters have already been obtained via the `fit()`\nfunction, the cost function to be used for the likelihood profiles will\nmatch the original cost function\u2014additionally, the best fit parameters\nwill be highlighted in the plots. If not, the likelihood profiles will\nbe computed with the default mean squared error.\n\n#### Bootstrapping (only for `nreplicates>1`)\n\nBootstrapping is carried out by randomly choosing one replicate per\nspatio-temporal coordinate and refitting all parameters in multiple\nrounds. Done using\n\n``` python\nmy_object.bootstrap()\n```\n\nIf no argument is given, the process is repeated 100 times. For other\nconfigurations, use the optional `nruns` argument; *e.g.*,\n\n``` python\nmy_object.bootstrap(nruns=250)\n```\n\nA summary of the results is displayed on screen and stored as a\n`DataFrame` in the attribute `bootstrap_summary`, while the full results\nare stored as a `DataFrame` in the attribute `bootstrap_raw`.\nRespectively,\n\n**Summary:**\n\n![summary\\_bootstrap](./img/summary_bootstrap.png)\n\n**Full:**\n\n![raw\\_bootstrap](./img/raw_bootstrap.png)\n\nFor a quick look at the results, use\n\n``` python\nmy_object.plot_bootstrap()\n```\n\nYou should see something like this:\n\n![plot\\_bootstrap](./img/plot_bootstrap.png)\n\nIf the best fit parameters have already been obtained via the `fit()`\nfunction, the cost function to be used for bootstrapping will match the\noriginal cost function\u2014additionally, the best fit parameters will be\nhighlighted in the plots. If not, the default mean squared error will be\nused.\n"
      },
      "source": "https://raw.githubusercontent.com/systemsmedicine/PDE_params/master/README.md",
      "technique": "header_analysis"
    }
  ]
}
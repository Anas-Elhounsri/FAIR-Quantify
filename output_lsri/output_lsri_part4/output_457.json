{
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/raphael-group/scarlet"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2019-11-06T14:30:52Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-07-03T06:54:31Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "SCARLET (Single-cell Algorithm for Reconstructing Loss-supported Evolution of Tumors) is an algorithm that reconstructs tumor phylogenies from single-cell DNA sequencing data. SCARLET uses a loss-supported model that constrains mutation losses based on observed copy-number data."
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 0.9876980843038022,
      "result": {
        "original_header": "SCARLET",
        "type": "Text_excerpt",
        "value": "SCARLET is an algorithm that reconstructs tumor phylogenies from single-cell DNA sequencing data. SCARLET uses a loss-supported model that constrains mutation losses based on observed copy-number data.  \nSCARLET is implemented in Python and uses Gurobi for optimization. \n \n"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/raphael-group/scarlet/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 4
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/raphael-group/scarlet/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "raphael-group/scarlet"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "SCARLET"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "has_script_file": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/raphael-group/scarlet/master/code/scarlet.sh"
      },
      "technique": "file_exploration"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Setup",
        "parent_header": [
          "SCARLET"
        ],
        "type": "Text_excerpt",
        "value": "\n<a name=\"dependencies\"></a>"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "SCARLET Setup",
        "parent_header": [
          "SCARLET",
          "Setup"
        ],
        "type": "Text_excerpt",
        "value": "To use SCARLET, first clone the SCARLET repository locally. \n\n```git clone git@github.com:raphael-group/scarlet.git```\n\nSCARLET uses Python and doesn't require any compilation. SCARLET does however require an installation and a valid lincense for the Gurobi Optimizier. See the following section for details. \n\n<a name=\"usinggurobi\"></a>"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Using Gurobi",
        "parent_header": [
          "SCARLET",
          "Setup"
        ],
        "type": "Text_excerpt",
        "value": "SCARLET uses the Gurobi optimizer. To setup Gurobi, first download the [Gurobi Optimizer](https://www.gurobi.com/downloads/). \n\nEvery run of SCARLET uses Gurobi, which requires a valid license pointed to by the enviromental variable `GRB_LICENSE_FILE`. Gurobi licenses are freely available for academic users and can be acquired at [https://www.gurobi.com/academia/](https://www.gurobi.com/academia/). There are two types of academic licenses available:\n\n1. **Individual license**. This license can be obtained easily by any academic user with an institutional email. This license is user and machine-specific, meaning that the user needs to acquire a different license for every machine. Assuming the license is stored at `/path/to/gurobi.lic,` the user can easily use it by the following command:\n\n\t```export GRB_LICENSE_FILE=\"/path/to/gurobi.lic\"```\n\n\n2. **Multi-user license**. This license can be used by multiple users on any machine in a cluster. This license can be obtained freely but needs to be requested by the IT staff of the user's institution. This license is typically used in a machine cluster and requires the following command:\n\n\t```module load gurobi```\n\n<a name=\"runningscarlet\"></a>"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.984431031552145,
      "result": {
        "original_header": "Contents",
        "type": "Text_excerpt",
        "value": "<a name=\"setup\"></a> \n"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/raphael-group/scarlet/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "algorithm, cancer-genomics, phylogenetics, single-cell, tumor-evolution, tumor-phylogeny"
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "BSD 3-Clause \"New\" or \"Revised\" License",
        "spdx_id": "BSD-3-Clause",
        "type": "License",
        "url": "https://api.github.com/licenses/bsd-3-clause",
        "value": "https://api.github.com/licenses/bsd-3-clause"
      },
      "technique": "GitHub_API"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "scarlet"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "Organization",
        "value": "raphael-group"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "Limbo",
        "size": 605404,
        "type": "Programming_language",
        "value": "Limbo"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Brainfuck",
        "size": 200350,
        "type": "Programming_language",
        "value": "Brainfuck"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Perl",
        "size": 200350,
        "type": "Programming_language",
        "value": "Perl"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Python",
        "size": 29261,
        "type": "Programming_language",
        "value": "Python"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Assembly",
        "size": 2242,
        "type": "Programming_language",
        "value": "Assembly"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Shell",
        "size": 576,
        "type": "Programming_language",
        "value": "Shell"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "requirements": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Dependencies",
        "parent_header": [
          "SCARLET",
          "Setup"
        ],
        "type": "Text_excerpt",
        "value": "- ~~Python 2.7~~ Python 3 since last commit ([anaconda distribution](https://www.anaconda.com/distribution/) recommended)  \n- Gurobi \n- GraphViz (for tree visualization)\n"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "run": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Running SCARLET",
        "parent_header": [
          "SCARLET"
        ],
        "type": "Text_excerpt",
        "value": "<a name=\"input\"></a>"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Input Files",
        "parent_header": [
          "SCARLET",
          "Running SCARLET"
        ],
        "type": "Text_excerpt",
        "value": "SCARLET takes as input two files. The first describes the read counts and copy-number profile assignments for each cell. The second describes the copy-number tree and the set of supported losses for each edge in the copy-number tree. \n\n1. **Read count file**. For each cell, this file describes the copy-number profile assignment and variant and total read counts for *m* mutations. The input file is a comma-separated file, where the first line is the header and rows correspond to cells, with the following format.\n\t```\n\tcell_id, c, [mut1]_v, [mut1]_t, [mut2]_v, [mut2]_t, ... [mutm]_v, [mutm]_t\n\t\n\t```\n\t- `cell_id` --- unique identifier for each cell\n\t- `c` --- [*non-negative integer*] copy-number profile assignment\n\t- `[muti_v]` --- [*non-negative integer*] the variant read count for mutation *i* in a particular cell\n\t- `[muti_t]` --- [*non-negative integer*] the integer total read count for mutation *i* in a particular cell. By definition, the total read count must be greater than or equal to the variant read count. \n\n\tNote that in the header `[muti]` may be replaced with unique identifiers for mutations, but the rest of the format must remain as specified.\n\t\n\n2. **Copy-number tree file**. This file describes the copy-number tree that relates the copy-number profiles of the observed leaves, as well as the set of supported losses for each copy-number transition. This file takes the format of an comma-separated edge list, where the first two columns are integer copy-number profiles, followed by a list of supported losses on that transition. \n\n\t```\n\tc_1, c_2, [mut1], [mut3], ..., [muti]\n\tc_2, c_3, [mut2], [mut5], ..., [mutj]\n\t```\n\t\n\tCopy-number profile assignments and mutation names must be consistent with those found in the read count file. \n\nExamples of these files can be found in the `example/` directory.\n\n<a name=\"output\"></a>"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Output Files",
        "parent_header": [
          "SCARLET",
          "Running SCARLET"
        ],
        "type": "Text_excerpt",
        "value": "Scarlet produces several output files, as detailed below. In addition to these, Scarlet produces several auxiliary files (including [prefix].B_ancestor and [prefix].dot) that are used for graphing purposes and not detailed below. \n\n1. **Binary mutation matrix file** (`[prefix].B`). This file describes the binary presence (`1`) or absence (`0`) of each mutation in each cell. This is a comma-separated file where the first line is the header and rows correspond to cells, of the following format. \n\t```\n\tcell_id,[mut1], [mut2], ..., [mutm]\n\t\n\t```\n\n2. **Ternary mutation matrix file** (`[prefix].T`). This file is formated in the same way as the binary mutation matrix file but also indicates mutation losses (`2`). That is, if an ancestor of a cell contained a mutation but it was subsequently lost, the mutation matrix entry for that cell will be a `2` instead of a `0`. \n\n3. **Mutation matrix likelihood file** (`[prefix].LL`). This file contains a single line which gives the log-likelihood of the mutation matrix. \n<a name=\"usage\"></a>\n\n4. **Tree edgelist** (`[prefix].edgelist`). This file contains a list of edges in the tree inferred by SCARLET. In this file, there are three types of vertices. Observed cells are prefixed by \"CELL:\" and labeled by their id (as given in the read count file). Internal vertices that correspond to the roots of a copy-number state subtree are prefixed by \"ROOT:\", and labeled by the copy-number state.  Internal vertices are prefixed by \"MUT:\" and labeled by the mutation on the incoming edge to that vertex. All vertex names are followed by the assigned copy-number state in parenthesis.  \n"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "somef_missing_categories": [
    "citation",
    "acknowledgement",
    "download",
    "contact",
    "contributors",
    "documentation",
    "faq",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-11-04 03:21:16",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 8
      },
      "technique": "GitHub_API"
    }
  ],
  "type": [
    {
      "confidence": 0.82,
      "result": {
        "type": "String",
        "value": "commandline-application"
      },
      "technique": "software_type_heuristics"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Usage",
        "parent_header": [
          "SCARLET",
          "Running SCARLET"
        ],
        "type": "Text_excerpt",
        "value": "SCARLET can be run from the command line as follows.\n\n```\nbash code/scarlet.sh [read count file] [copy-number tree file] [output prefix] [(OPTIONAL) plotting_style]\n```\n\nPlotting style controls how the leaves will be displayed in the plot of the output tree. It has three options.\n\n- \"ALL\": Plot all observed cells as leaves\n\n- \"COUNT\": Plot the number of observed cells attached to each inner vertex\n\n- \"NONE\": Plot only the mutation tree, no leaves\n\n<a name=\"example\"></a>"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example",
        "parent_header": [
          "SCARLET"
        ],
        "type": "Text_excerpt",
        "value": "\nExample input is provided in the `example` directory. It can be run as \n\n```\nbash code/scarlet.sh example/read_counts.csv example/tree.csv example/output ALL\n```\n\n\n\n\n\n\n\n\n"
      },
      "source": "https://raw.githubusercontent.com/raphael-group/scarlet/master/README.md",
      "technique": "header_analysis"
    }
  ]
}
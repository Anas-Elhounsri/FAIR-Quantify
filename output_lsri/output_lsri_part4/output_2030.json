{
  "acknowledgement": [
    {
      "confidence": 1,
      "result": {
        "original_header": "9. Acknowledgements",
        "type": "Text_excerpt",
        "value": "Development  was performed at the University  of Toronto's Computational Biology\nlab in collaboration with the Stanford University Sidow Lab.\n\nThe   development of this   distribution was made possible  in  part by National\nEngineering and Research Council of Canada Undergraduate Student Research Awards\n(NSERC USRAs).\n\nWe'd like to thank Dr. Alessandro Guffanti (Bioinformatics, Genomnia srl, Milan,\nItaly),  Christine Voellenkle  and Jeroen  van Rooij  ( Policlinico  San Donato,\nMilan, Italy) for their feedback on using SHRiMP for mapping micro RNA data.\n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "header_analysis"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/compbio-UofT/shrimp"
      },
      "technique": "GitHub_API"
    }
  ],
  "contact": [
    {
      "confidence": 1,
      "result": {
        "original_header": "8. Contact",
        "type": "Text_excerpt",
        "value": "The program website is \n    \thttp://compbio.cs.toronto.edu/shrimp\n\nThe authors of this software may be contacted at the following e-mail address:\n\tshrimp at cs dot toronto dot edu\n\n\n--------------------------------------------------------------------------------"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "header_analysis"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2011-09-08T14:47:22Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2023-04-27T11:34:14Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "SHRiMP is a software package for aligning genomic reads against a target genome."
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 0.9392349361101653,
      "result": {
        "original_header": "4. Program Parameters",
        "type": "Text_excerpt",
        "value": "SHRiMP is a software package for aligning genomic reads against a target genome.\nIt was primarily developed with the multitudinous short reads of Next Generation\nSequencing (NGS)   machines  in mind. It   allows  for  rapid mapping,  accurate\nalignment,  and p-value   computation  for Illumina/Solexa   as well as  Applied\nBiosystems'  SOLiD colourspace   genomic representation. SHRiMP  is   a suite of\nseveral    programs, which,  employed   in   succession, search for  appropriate\nalignments, analyze alignment statistics, and  print  out visual alignments  for\nfurther study. \nSHRiMP uses two techniques to    rapidly match reads    to a genome: we use   an\neffective implementation  of  the q-gram filtering  technique  (utilizing spaced\nseeds)  to rapidly  identify potentially  homologous   regions, and  a  vectored\nSmith-Waterman  implementation  to speed up  the    accurate alignment of  these\nregions to  reads. We also  include in the SHRiMP  package  tools to analyze the\nresultant alignments, including programs that  compute  for every alignment  the\nprobability   that the match  would   occur by chance (in   a   genome with  iid\nnucleotides), a prettyprint tool that can help visualize the alignments for each\nread, and a  variation output tool  (shrimp_var) what will output the variations\ndetected for a specific hit in detail. For AB SOLiD colour  space reads we use a\nnovel  color-space to   letter-space   Smith  Waterman  algorithm   to  identify\nsequencing errors as well as SNPs and micro-indels. The details of the algorithm\nand the  methods we use to  compute p-values are laid out  in Sections  6 and 7,\nrespectively. \n  This section provides a very  brief and straightforward introduction to  using\n  SHRiMP. For more details, see Sections 3 and 4. \n    Use bin/rmapper-foo to  align reads, where  'foo' is  either 'ls',  'cs', or\n    'hs'  for letter-space (454,  Illumina/Solexa), colour-space (AB SOLiD), and\n    Helicos-space (Helicos HeliScope SMS 2-pass reads), respectively. \n    If  you want  full,  pretty-printed alignments,  use  the -P flag.  For more\n    details about parameters, see Sections 3 and 4. \n    If the -P flag is not specified to rmapper,  full alignments are omitted. To\n    print alignments  after the fact,  just run bin/prettyprint-foo (where 'foo'\n    is one of 'ls', 'cs', or 'hs'). \nThe distribution makes use of several programs. The  first and most important is\n'rmapper'. 'rmapper' performs Smith-Waterman alignments of multiple reads within\none fasta file  against one or more  reftigs in other  fasta files. rmapper  was\ndesigned to map a set of reads against the entire genome  (all contigs and their\nreverse-complements) in one invocation. Parallelism can be achieved by splitting\nthe set of reads into N chunks, where N is the desired level of parallelism. \nIt is important to note  that 'rmapper' is  always given  a reference genome  in\nletter-space, regardless of whether the reads  are in letter-space or AB SOLiD's\ncolour-space representation. For   letter-space  reads, use   'rmapper-ls',  for\ncolour-space reads, 'rmapper-cs', and for Helicos SMS reads, 'rmapper-hs'. Other\nSHRiMP  utilities that  make assumptions  about  the input  read format  come in\npairs, i.e. 'foo-ls' and 'foo-cs', for letters  and colours, respectively. Other\nutilities lacking any suffix are format-agnostic. \nOnce 'rmapper' has been run, the standard output format of all alignments may be\nparsed via the  'probcalc'  program. This code   analyzes all alignment  output,\nsaving the top 'n' matches per read, and calculates the probability of the match\nrandomly occurring in the genome and matching the  read, and the normalized odds\n(P(read match)/P(random)/normalization_factor).  Thresholds can be  set for each\nto remove undesirably high or low values. Sorting can also be done on any one of\nthe three aforementioned parameters. \nThe  output produced by  the 'probcalc' utility  is  essentially a subset of the\ninput, with added 'pgenome', 'pchance' and 'normodds'  fields. These matches may\nthen  have  their  full   alignments  printed  using the 'prettyprint'   utility\n(although one could also feed rmapper output to prettyprint directly). Also, the\nshrimp_var utility will print the variations for each hit in detail. \nWhat follows is a complete example of scanning a set of  reads against an entire\ngenome (and  its  reverse-complement) from the Ciona   Savignyi organism.  We'll\nthen calculate the associated probabilities and print out pretty alignments. \nWe  shall  assume  a large   set  of colourspace reads  exist  in  a single file\n'reads.csfasta' and the entire Ciona genome exists in 'ciona.fasta' (as a single\ncontig), both   in  the present working  directory.  $S  represents the  path to\nSHRiMP. \n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nPLEASE NOTE:\n    This example uses a lot of parameters to exhibit the configurability of\n    SHRiMP. Settings shown here are not necessarily appropriate for your reads.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! \nLines 1&2 set up the necessary directory  structure. reads/ contains one or more\nfasta files containing letterspace  or colourspace reads. results/  contains the\nresults of  the 'rmapper'  pass, which  are  fed to  'probcalc' to  generate the\nprobabilities of them being poor matches. \nLines 3&4   split the  reads.csfasta  file,  which  contains a  large  number of\ncolourspace reads into smaller chunks. This both saves memory, and permits us to\nparallelize the computation. \n  The options shown on the first line (-m ... -v) are used to set the scores and\n  the  score  thresholds  for  matches.   Even though  'rmapper'  includes  some\n  sensible default settings for these  scores, we suggest  that you provide your\n  own scores and score thresholds, because 'rmapper' has  no way of knowing what\n  is biologically relevant for the sequences being scanned. \n  The  options shown on  the second line  (-M or -s ... -w)  affect the tradeoff\n  between speed and sensitivity.  By  default, 'rmapper' uses  4 spaced seeds of\n  weight 12 and requires 4 matches between  a read and  a genome window in order\n  to further investigate that particular match.  These settings are targeted for\n  dealing with a  large (>100,000) number  of reads,  of  about 50bp  each. \n    ********** NEW in SHRiMP 1.3.0\n    * 'rmapper' comes with  several predefined sets of  parameters,  that can be\n    * loaded using the  option '-M' (explained  below).  We _strongly_ recommend\n    * using one of these sets until becomes familiar with the individual effects\n    * of the other options.\n    ********** \n    - Using as many  (4)   seeds of smaller  weight   (e.g.,  11 or  10)  mildly\n      increases sensitivity but greatly increases running time. \n    - Using  a single seed,  even of smaller weight (e.g., 9), is sometimes fast\n      when dealing with few (<10,000) reads. \n    - We recommend using the default 4 seeds of weight 12 in most cases. \n    - The default is 4, which is targeted towards dealing with 50bp reads. \n    - For smaller reads (e.g.,  35bp or 25bp), a setting of 3 or even 2 might be\n      more desirable in order to achieve good sensitivity. \n    - By default, reads are aligned against genome windows of 135% the length of\n      the read. \n    - For  smaller reads (e.g., 35bp  or 25bp), we  recommend increasing this to\n      150% or even 170%. \nThe output of 'rmapper' is piped into a file in the results/ directory for later\nevaluation.   This step could be   parallelized  across all *_to_*.csfasta files\ncreated by splitreads.  Note that the genomic  file  may contain one or  several\ncontigs,  that  multiple  genome  files  may  be  specified,  and  that  reverse\ncomplements are automatically scanned as well. \nLine 7 calculates the probability of each hit generated  by 'rmapper' being bad.\nIt takes two mandatory parameters: the total  concatenated genome length, and at\nleast  one shrimp results file or  directory of  results file(s) (multiple files\nand/or directories may be specified). The output is piped into a further results\nfile for later evaluation by the  'prettyprint-cs' program. Note that 'probcalc'\nshould be run  once  enough results  have been  gathered to generate  reasonable\nstatistics. Since  this phase  takes a  relatively  short amount of time,  it is\nprobably best done once sequentially for all output  generated. However, one may\nalso use the   -G and -g   flags to probcalc   to run  statistics generation  in\nparallel, sequentially merge the statistics (i.e. just concatenate outputs), and\ncalculate probabilities in parallel as well. See Section 4 for more details. \nAlso note that probcalc mandates that results for a single read do not appear in\nmultiple files. If rmapper has  been run against the  entire genome for some set\nof  reads this assumption    will hold. See    section 4 for   details regarding\nprobcalc's parameters. \nLine  8 prints pretty visual  alignments of our  resultant mappings. It requires\nknowing all genomic  and reads files in order  to locate each read referenced in\nthe  input file (generated  by either  'rmapper' or 'probcalc')  and aligns them\nagainst the appropriate contig in the genome.  Alternatively, one could have run\nrmapper with the -P flag to generate these  in the initial output (although that\ncould  consume a  considerable  amount of   disk  space). Note that  rmapper and\nprettyprint share the same default   parameters. Deviating from the defaults  in\nrmapper means having to provide the appropriate  S-W penalties to prettyprint as\nwell. \nLine  9  outputs the  variations   of the hits   computed  by rmapper in detail,\nspecifically SNPs, insertions and deletions.  The needed flag  is the input file\ntype, that is  -r for rmapper  and -p for probcalc. If   the -R flag is  used in\nrmapper, it should also be supplied to shrimp_var. \n'rmapper' takes a variety  of  parameters, which   differ sightly depending   on\nwhether colour-space or letter-space reads are being employed. What follows is a\nrun-down of these options (in some strange, non-alphabetical order). \n    rmapper-cs and rmapper-ls parameters (common parameters): \n\tSelects one of the default sets of parameters.   The possible values are\n\t{'fast'/'sensitive'}, {'35bp'/'50bp'/'70bp'} or simply 'mirna'.  Several\n\tmodes can be  given as '-M 35bp -M  sensitive' or comma-separated as '-M\n\tfast,70bp',  but  you should specify at  most   one value from  each set\n\tabove. By default,  'rmapper'  uses '50bp' and  'fast'.  Do not  mix the\n\t'mirna' mode with any of the others. \n\tThe values 'fast'/'sensitive' provide basic  tradeoffs between speed and\n\tsensitivity. The values '35bp'/'50bp'/'70bp' load settings suggested for\n\tdealing with reads of (around) that length. \n\tThe speed  and readlength  mode   specifiers currently set:  the  seeds,\n\t'seed_matches_per_window', 'seed_taboo_length' and  'seed_window_length'\n\t(see  their    individual descriptions below).   If   any   of these  is\n\texplicitly set with its  own flag, that  value overrides the value  that\n\twould have been selected by the mode. \n\tThe 'mirna' mode loads some settings that have  been suggested to us for\n\tthe   analysis of AB Solid (colour   space) micro  RNA  data. (Thank you\n\tAlessandro Guffanti.) Specifically, '-M mirna' is equivalent to: \n\tThe  spaced seed is  a  single contiguous  string of  0's  and 1's.  0's\n\trepresent wildcards,  or positions  which will  always  be considered as\n\tmatching, whereas 1's dictate positions that must match. A string of all\n\t1's will result in a simple kmer scan. \n\tMultiple -s arguments  may be provided,  in which case rmapper  will use\n\tall of the spaced   seeds.  Multiple seeds  can  also be specified as  a\n\tcomma-separated  list, e.g.,   '-s 1101,111011'.  'rmapper'   comes with\n\tseveral predefined sets of spaced  seeds for specific weights. These can\n\tbe selected by prefixing the weight with a 'w', e.g., '-s w10' loads the\n\tdefault (4) seeds of weight 10. \n\tNote that, by  default, our implementation  creates a lookup table based\n\ton the kmer size (spaced seed 'weight', or number of 1's).  Hence memory\n\tusage increases by a  factor of four for each  addition 1. At 16,  we're\n\tlooking at  a 32GB hash table allocation  for  32-bit architectures. See\n\tthe -H option for  an alternative method,   which creates a hash  table,\n\tpermitting much larger seeds. \n\tThe seed taboo length specifies how  many target genome bases or colours\n\tmust exist prior to a previous seed match in order to count another seed\n\tmatch as a hit. \n\tThis parameter specifies  the length in bases (or  colours) of a genomic\n\twindow against which a read  is aligned. It is  either an absolute value\n\t(e.g., '-w 67'), or a percentage  of the read  length (e.g., '-w 150%').\n\tIn  order for  a read  to  be given consideration by  the Smith-Waterman\n\talignment machinery, 'seed_matches_per_window'  must be  detected within\n\tsuch a genomic window. \n\tAfter a genomic  window A is found  to contain a  significant match to a\n\tgiven read, no genomic window B is investigated for matches against that\n\tsame read as long as B overlaps A by more than 'window_overlap_length'. \n\tThis parameter specifies how  many  hits to remember  for each  read. If\n\tmore hits are encountered,  ones with lower scores  are dropped  to make\n\troom. \n\tThis option permits pruning  read  kmers, which occur with   frequencies\n\tgreater    than 'kmer_std_dev_limit'   standard  deviations    above the\n\taverage. This can shorten running time at the cost of some sensitivity. \n\tNB: A negative value disables this option. \n\tNote  that for backward compatibility, if  -g is set  and -q is not set,\n\tthe  gap open penalty  for the query will  be  set to  the same value as\n\tspecified for the reference. \n\tNote that for  backward compatibility, if -e is  set and -f  is not set,\n\tthe gap  extend penalty for the  query will be  set to the same value as\n\tspecified for the reference. \n\tNB: This option  differs  slightly in meaning between  letter-space  and\n\tcolour-space. \n\tIn letter-space, this parameter determines the  threshold score for both\n\tvectored  and full Smith-Waterman alignments. Any  values less than this\n\tquantity will be thrown away. \n\tIn colour-space,  this parameter affects only   the full Smith- Waterman\n\talignment, which   is performed in   letter-space. The threshold  of the\n\tcolour-space  fast  vectored  alignment can  be    specified  by the  -v\n\toption. Generally, the -h parameter should be stricter (higher) than the\n\t-v   option, since    naive   colour-space   alignments  using   regular\n\tSmith-Waterman suffer additionally due  to artifacts such as single SNPs\n\tresulting in two colour mismatches. \n\tControls the  per-read cache size used   by the hash-and-cache mechanism\n\t(see Algorithms section for more  details). The  first time a  potential\n\tmatch is found for  a read, a cache  is initialized for that read,  with\n\tsize 'min_cache_size'. Subsequently, on  cache misses with a full cache,\n\tthe size of the cache is doubled until  it reaches 'max_cache_size'. The\n\tabsolute maximum is 128. \n\tFor every match of a read against  a genomic window, 'rmapper' saves the\n\tpositions  of the 'seed_matches_per_window'   kmers that triggered  that\n\tmatch.    Subsequently,  during  the  final    Smith-Waterman alignment,\n\t'rmapper'  restricts the computed region   of  the 2D matrix by   adding\n\t\"anchors\"  or  \"necks\" of    width 'anchor_width'  around    the matched\n\tkmers. The default value  is 8. Use of anchors  is disabled by providing\n\t-1 as width. \n\tPerform gapless  alignment. When this flag  is specified,  rmapper looks\n\tfor gapless alignment between  reads and the  database. In letter space,\n\tthis means only mismatches are tolerated.  In colour space, there can be\n\tboth mismatches  and crossovers. The  scoring  scheme still  applies. -G\n\talso implies -A 0 -g -255 -q -255. \n\tThis option simply  prints a  progress bar to  stderr during  the spaced\n\tseed scan   and  vectored Smith-Waterman phases.  It   exists to  give a\n\tgeneral feel for run-time when  testing parameters.  Since it will  slow\n\tdown execution speed noticeably (25% or so), it is not enabled by default\n\tand should only be used during manual, interactive execution. \n\tUse a hash table, rather than a direct lookup table for seeds.  A direct\n\tlookup  will  be more  efficient for  small  seeds,  but quickly becomes\n\tprohibitively large  for longer ones. For seeds  of  weight greater than\n\tabout 14, this option should be used. \n\tNote that rmapper will not automatically switch to using a hash table if\n\tthe  seed is too  large for a direct  lookup, the reason being that this\n\toption has simply not been as well-tested. \n\tNote also that this cannot be used in conjunction with the -d parameter. \n\t'rmapper' has two output formats. The first,  and default, prints a list\n\tof appropriately   scoring reads and  various  parameters, such as where\n\tthey occurred  in the genome (index),  how many matches, mismatches, and\n\tgaps there were, and so  forth.  The '-P' flag  enables a 'pretty print'\n\toutput, which displays similar parameters, but also a full alignment. \n\tInclude  the entire  read sequence  in the  output  generated. This will\n\tconsume huge  gobs of  disk space  for  large reads  and  is disabled by\n\tdefault. Saved reads are placed in the 'r_seq' key. \n\tReverse the  order in which tie-breaks are  resolved in the full aligner\n\twhen doing  the negative  strand.  This  should help line  up  gaps when\n\tnegative matches  are  reverse-complemented  and compared with  positive\n\tmatches. \n        `2147483647'  is the  number  of  lines after  the   matching context to\n        output. In the  case where we want them  all, 2147483647 is  the largest\n        acceptable value for GNU grep. \n\tThis specifies  the  penalty     applied when   transitioning    between\n\tSmith-Waterman matrices during the  full scan phase. While the vectored\n\tscan applies  to  colour-space,  the  final full  alignment is  done  in\n\tletter-space.   Since each next letter  in   letter-space depends on the\n\tprevious letter  and colour,  any error on   the colour space  read will\n\taffect  all following  letters when converting   to text space. For this\n\treason, we must perform our alignment of all  four possible letter space\n\ttranslations of the read  and permit jumping  between matrices (at  the\n\tcrossover_penalty) cost, when errors occur. \n\tUnlike in   letter-space, where  the  vectored Smith-Waterman   and full\n\tSmith-Waterman  alignments are done both    in letter-space and  present\n\tidentical   scores, in colour-space  the   vectored score represents the\n\toriginal colour-space  read aligned to   the colour-space translation of\n\tthe  genome. This will  differ from the  final  alignment, which is done\n\tpurely in letter-space.  Since the  function of the vectored pass exists\n\tmerely to prune insufficiently good  alignments and the vectored pass is\n\tnot a  true  textual alignment, scores  for  both passes are   likely to\n\tdiffer. Generally, since a single SNP in letter-space will result in two\n\tcolour  changes, the threshold  for the colour-space alignment should be\n\tless than that of letter-space. \n    prettyprint-cs and prettyprint-ls parameters (common parameters): \n\tInclude the entire read sequence in the output generated. This will only\n\thave an effect for input lines containing the 'r_seq' key. \n\tReverse the  order in which tie-breaks  are resolved in the full aligner\n\twhen doing the negative  strand.  This  should  help line up  gaps  when\n\tnegative  matches  are reverse-complemented and  compared  with positive\n\tmatches. \n\n'probcalc' takes a few optional parameters as well: \n\tRather  than calculating  rates  of alignment  events using the provided\n\toutput file, assume the ones provided in 'rates_file'.  This may be used\n\tto run probcalc in parallel by  first running all  instances with the -G\n\tflag, concatenating  those outputs into a  single 'rates_file', and then\n\trunning once more with the -g parameter to generate probabilities.- . \n\tRather than calculate rates  of various events, provide them  explicitly\n\tand use  those values   in the  calculations. Here,   'erate',  'srate',\n\t'irate' and 'mrate' mean errors (miscalls), substitutions (SNPs), indels\n\tand matches, respectively. \n\tOnly generate rates of various alignment events and send them to stdout.\n\tThis can be used to run probcalc in parallel. See also '-g'. \n\t[ -R ]\n \n\tInclude the entire read sequence in the output generated. This will only\n\thave an effect for input lines containing the 'r_seq' key. \n \t[ -S ]\n \n \tDo everything in  a single pass. Typically  probcalc  will run  over all\n \trmapper results files  twice in order to  save memory. This option  will\n \tuse one pass only  at the expense of  using far more memory than  usual,\n \thowever, a significant speed advantage   is gained. Additionally,  while\n \tprobcalc normally mandates that results from rmapper for a specific read\n \tappear  in at  most  one  file, this   option  does  not have the   same\n \trestriction. \n\t[-m mapping_filename] \n\t\t\n\tthe mapping file (normal text or binary)\n\t\t\n\t[-f forward_suffix]\n\t\t\n\tthe suffix for forward reads. For e.g.: \"_F3\"\n\t\t\n\t[-b reverse_suffix] \n\t\t\n\tthe suffix for backwards (reverse) reads. For e.g.: \"_R3\"\n\t\t\n\t[-g genome_length] \n\t\t\n\tthe genome length, for purposes of pchance computation\n\t\t\n\t[-M hard_distance_limit] \n\t\t\n\tfor computing the mean statistics, the hard M limit \n\t\t\n    Optional parameters:\n\t\n\t[-L nr_mate_pairs] \n\t\t\n\tthe  number  of  *good* mate    pairs  to include   in  the   statistics\n\tcalculations. do -L 0 to include *all* good mate pairs.  default: 50,000\n\t\t\n\t[-i file_type]\n\t\t\n\tthe type of file, file_type can be 'ascii' or 'binary'\n\t\t\n\t[-R] \n\t\t\n\tindicator  that the read  sequence is included in  the input, as used by\n\tprobcalc\n\t\t\n\t[-x max_reads_to_expect] \n\t\t\n\tthe maximum number of mappings one should expect for one read\n\t\t\n\t[-d]\n\t\t\n\tdiscordant analysis.\n\t\t\n\t[-u]\n\t\t\n\tin computing the mean, use unique mappings only\n\t\t\n\t[-T max_reads_to_output] \n\t\t\n\tthe maximum(ish) number of mappings to output per mate pair\n\t\t\n\t[-C PCHANCE_CUTOFF]\n\t\t\n\tpchance cutoff\n\t\t\n\t[-G PGENOME_CUTOFF]\n\t\t\n\tpgenome cutoff\n\t\t\n\t[-s nr_stdevs] \n\t\t\n\tafter computing  stats, M  (hard_distance_limit) is set   to the mean  +\n\tnr_stdev * stdev. Default: nr_stdevs = 2;\n\t\t\n\t[-c ] \n\t\t\n\tdo not print mate-pairs with hits on different chromosomes \n\t[-r | -p]\n\t\t\n\ttell shrimp_var weather the input files are rmapper or probcalc input.\n\t\t\n    Optional\n\t\n\t[-R ]\n\t\t\n\tindicator that the  read sequence is included  in the input, as  used by\n\tprobcalc \n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9185990670176359,
      "result": {
        "original_header": "5.0 Output Format",
        "type": "Text_excerpt",
        "value": "rmapper  probcalc, and prettyprint all  adhere to a  common output format: lines\ncorresponding  to individual hits  with tab-delimited fields.  Such lines always\nbegin with a '>' character in the first position. All utilities ignore any lines\nthat do not begin with '>', such as alignments, comments, etc. \nHere's an example ('\\'  indicates continuation of the same  logical line on  the\nnext line of this README file and does not appear in the actual output): \nAdditionally, the beginning  of each output file begins  with a specification of\nthe tab-delimited fields.  For example, the  following applies to the above read\nhit: \nDescriptions of the columns are as follows: \n\t'readname'\tRead tag name\n\t'contigname'\tGenome (Contig/Chromosome) name\n\t'strand'\tGenome strand ('+' or '-')\n\t'contigstart'\tStart of alignment in genome (beginning with 1, not 0).\n\t'contigend'\tEnd of alignment in genome (inclusive).\n\t'readstart'\tStart of alignment in read (beginning with 1, not 0).\n\t'readend'\tEnd of alignment in read (inclusive).\n\t'readlength'\tLength of the read in bases/colours.\n\t'score'\t\tAlignment score\n\t'editstring'\tEdit string: read to reference summary; see below. \n\t'pchance'\tProbability that a read will align with a genome with \n\t\t\tas good a score or better by chance.\n\t'pgenome'\tProbability that a hit was generated via common \n\t\t\tevolutionary events characteristic of the genome.\n\t'normodds'\tNormalized pgenome/pchance. \nThe  'editstring' column  contains  a short   description of the  alignment with\nreference  to the database    sequence.  This allows  at-a-glance   analysis  of\nalignments, including identification of miscalls, SNPs, indels, etc. \nThe edit  string consists of numbers,  characters  and the  following additional\nsymbols: '-', '(' and ')'. It is constructed as follows: \n    <number> = size of a matching substring\n    <letter> = mismatch, value is the tag letter\n    (<letters>) = gap in the reference, value shows the letters in the tag\n    - = one-base gap in the tag (i.e. insertion in the reference)\n    x = crossover (inserted between the appropriate two bases) \n    A perfect match for 25-bp tags is: \"25\"\n    A SNP at the 16th base of the tag is: \"15A9\"\n    A four-base insertion in the reference: \"3(TGCT)20\"\n    A four-base deletion in the reference: \"5----20\"\n    Two sequencing errors: \"4x15x6\"\t(i.e. 25 matches with 2 crossovers)\n \nThe 'probcalc_mp' program has the following output: \n\tDescriptions of these columns are as follows:\n\t'fwd_name'\t\tForward Read tag name\n\t'fwd_chr'\t\tForward Genome (Contig/Chromosome) name\n\t'fwd_editstring'\tForward Edit string: read to reference summary;\n\t\t\t\tsee above.\n\t'fwd_strand'\t\tForward Genome strand ('+' or '-')\n\t'fwd_start'\t\tForward Start of alignment in genome (beginning\n\t\t\t\twith 1, not 0).\n\t'fwd_end'\t\tForward End of alignment in genome (inclusive).\n\t'fwd_pg'\t\tForward pgenome.\t\n\t'rev_name'\t\tReverse Read tag name\n\t'rev_chr'\t\tReverse Genome (Contig/Chromosome) name\n\t'rev_editstring'\tReverse Edit string: read to reference summary;\n\t\t\t\tsee above.\n\t'rev_strand'\t\tReverse Genome strand ('+' or '-')\n\t'rev_start'\t\tReverse Start of alignment in genome (beginning\n\t\t\t\twith 1, not 0).\n\t'rev_end'\t\tReverse End of alignment in genome (inclusive).\n\t'rev_pg'\t\tReverse pgenome.\n\t'distance'\t\tDistance between the mate pairs\n\t'pgenome'\t\tProbability that the mate-pair hits were\n\t\t\t\tgenerated via common evolutionary events\n\t\t\t\tcharacteristic of the genome.\n\t'pchance'\t\tProbability that a mate pair will align with a\n\t\t\t\tgenome with as good a score or better by chance.\n\t'normodds'\t\tNormalized pgenome/pchance.\n\t\nThe shrimp_var tool has a significantly different output format:\n\t>read_name edit_string contig_start #SNPs #ins #dels var_id1 var_id2 ...\n\t\n\tfor example:\n\t>example_1 2G1---12(AC)2 101 1 1 1 s-G-103 d-3-105 i-AC-119\n\t\n\tDescription of these columns are as follows:\n\t'read_name' \tThe name of the read\n\t'edit_string'\tEdit string: read to reference summary; see above\n\t'contig_start'\tStart of alignment in genome (beginning with 1, not 0).\n\t'#SNPs'\t\tThe number of SNPs present in the hit alignment \n\t'#ins'\t\tThe number of insertions present in the hit alignment\n\t'#dels' \tThe number of deletions\tpresent in the hit alignment\n\t'var_idX'\tThe variation id, description, and position. Details: \n\t\tif  variation is a  SNP, the  var_idX is s-L-pos,  where s means\n\t\tSNP, L is a  letter that the residue  is changed to, and  pos is\n\t\tthe contig position of the SNP; if variation is a insertion, the\n\t\tvar_idX is i-INS-pos where i  signals an insertion, INS includes\n\t\tthe inserted   residues and pos  is  the contig position  of the\n\t\tinsertion; if variation  is a deletion, the  var_idX is of  form\n\t\td-len-pos,  with d signaling   a deletion, len representing  the\n\t\tlength of the  deletion, and pos is the  contig position  of the\n\t\tdeletion. More examples  and a   discussion on negative   strand\n\t\thandling is available in pdf via email. \n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9620077302607968,
      "result": {
        "original_header": "6. SHRiMP Algorithms",
        "type": "Text_excerpt",
        "value": "SHRiMP  uses  a fast k-mer   scan in order  to  locate the  regions of potential\nhomology. One  important feature is  that we  index the  reads,  rather than the\nreference genome.  This makes  our memory usage  independent of  the size of the\ngenome (but proportional to the  size of the  largest contig). All of the k-mers\nin all of the source reads are  generated and a lookup  table mapping the k-mers\nto the reads where they are present is built. We use spaced k-mers (also used in\nthe PatternHunter as well as many other tools) and allow the user to specify the\nparticular pattern of ones (positions that must match) and zeros (positions that\nmay differ). \nFor each read containing the kmer, a notation is added  that a kmer hit was just\nmade. If 'n' kmer hits can be fit in a genomic region of length 'm', the hit and\nthe  region are  fed into a   vectored  Smith-Waterman algorithm to generate  an\nalignment score.  If   the score is  sufficient,  the score and  genomic  offset\n(index) is remembered.  Once this process  has completed for the entire  genome,\ntop scoring saved read/index pairs are fed into a full Smith-Waterman algorithm,\nand a detailed output is generated. \nIn order to deal with reads that match  the genome many  times, 'rmapper' uses a\nhash-and-cache mechanism.  Every  time  a genomic region  is  investigated for a\nmatch  against a given read (by  the vectored SW algorithm),   we compute a hash\nvalue  for  that region, and  we  save it along  with its  resulting  score in a\nper-read cache.  Subsequently, before  feeding another  genomic region into  the\nvectored SW   algorithm, we compute its  hash  value and we look   it up  in the\ncache. In the case of a cache hit, we use the saved score, bypassing the call to\nthe vector SW algorithm.  Hash collisions are possible  and they might (or might\nnot) result in   missed  matches, but  we trade  those   for non-negligible time\nsavings. This mechanism can be entirely disabled by giving the '-Z' option.  The\ncache is implemented as a simple queue. \nIn order  to  reduce the cost of   the full, non-vectored,  final Smith-Waterman\nalignment,  'rmapper' uses \"anchors\" or \"necks\"  to limit the  region  of the 2D\nmatrix that is computed.  For   each match, the  locations  of the kmers   which\ntriggered that match  during the  genomic scan are   saved; later, if  the match\nmakes it to  the  final stage, we   compute the minimum  rectangular region that\nencloses all the kmer  matches, we add 'anchor_width'/2  space to its south-west\nand north-east, and we only  compute the DP  match scores  for that region.  The\n'anchor_width' is given  using '-A'. The  default is 8.  A  value of -1 disables\nthe use of anchors. \nThe speed  of execution depends largely on  the spaced seed employed, the number\nof desired matches within a window,  the window length, and Smith-Waterman score\nthresholds.   For example, aligning   22e6  25-colour  reads against  the  Ciona\nSavignyi genome (173.67 Mbases) takes approximately 4.5 hours on a cluster of 50\n4-way P4 Xeon  3.2GHz  Hyperthreaded CPUs  (200 cores) using   a spaced seed  of\nlength  8,  weight 7,  a   window length of  30,  2  matches per window,   and a\nSmith-Waterman threshold of 1875 (penalties: 100 for  matches, -70 mismatch, -75\ngap open, -25 gap extend, -200 crossover). \nThe closer   the expected matches are   to perfect, the   larger the spaced seed\nweight can be, and  the faster the k-mer scan  runs. By decreasing the weight by\none, execution time increases by approximately  a factor of  four. Due to memory\nlimitations of our implementation, weights quickly become impractical around 16.\nLonger weights are therefore handled is a  slightly different manner to overcome\nthis. Similarly, exceedingly small weights will offer  little or no benefit over\na full Smith-Waterman run. \nPlease  note that the  vectored Smith-Waterman algorithm is written specifically\nfor the SSE2 instruction set. Hence this  program will not run on non-x86/x86_64\nprocessors. Porting those algorithms  to   similar vector processors  should  be\nrelatively straightforward. \n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9567527045679154,
      "result": {
        "original_header": "7. SHRiMP Statistics",
        "type": "Text_excerpt",
        "value": "The 'probcalc' utility computes the probability that a hit would be generated by\nchance in a random genome, the probability that it is generated by the reference\ngenome, and the normalized odds. \nTo compute the probability that a hit happened  by chance (p_chance), we compute\nthe probability that a match  equally good or better would  occur in a genome of\nequal length where  at every position  each nucleotide can be randomly  selected\nwith  probability 0.25. To  compute this we  compute the number of k-mer strings\nthat have fewer then the observed number changes. In  the case of mismatches and\n(for colour-space) crossovers, the number of such  strings is: \\sum(i=0 -> subs)\n{ (length  choose  i) *  3^i   }. For indels,  the  number  of such strings  is:\n\\sum(k=len_ref  -> len_read)  {  (k-1    choose  len_read-1) *  1^(len_ref)    *\n3^(k-len_ref) * 4^(len_read-k)  }. Explanations of  these formulae will be  made\navailable in the  statistics section of  the SHRiMP paper. If  the hit does  not\nspan  the whole read,  we  further  multiply  by (read_length-hit_length  +1) to\naccount for the increased number of  matching strings. Now  let the total number\nof strings be Z; then we define  p_chance as 1-(1-(Z/(4^k)))^genome_length. This\nis the application of the Bayesian \"noisy or\"  to the probability that a certain\nposition matched one of the strings  as close or closer to  the read in question\nthan the real hit. \nThe second value  computed  by probcalc is the  probability  that each  hit  was\ngenerated by the genome (p_genome). For this we use  a bootstrapping approach to\nestimate the rates of matches, mismatches (SNPs), indels, and, for colour space,\ncrossovers, taking only the best hit  of every read  if it is below the p-chance\nthreshold. The probability that a certain region of the genome generated a given\nread is exactly the product of the frequencies of  all of the events observed in\nthe alignment. \nFinally   the    normalized  odds are   computed  by     summing   up  the  odds\n(p_genome/p_chance) for every  hit for every read,  and  dividing each value  by\ntheir sum.  This value represents how  much more likely is this  hit to be right\nthan all the other ones. For example  having two equally good  hits with lead to\nnormalized odd values of 0.5 for both, while having an almost  exact match and a\nmore distant one will lead to large discrepancies. \n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9812062934025277,
      "result": {
        "original_header": "8. Mate Pairs",
        "type": "Text_excerpt",
        "value": "The probcalc_mp project  takes  in a  sorted file (ascii  or binary  filled with\nmapping_t structures as defined in dbtypes.h). This is a file with read mappings\nas outputted by the 'probcalc' tool. Assuming the binary  file is sorted by read\nid,    probcalc_mp  will  find  all   the    mate  pair   mappings, assign  them\nprobability-based confidence values (see the SHRiMP paper), and output them. How\nand which computations are done, and which mate-pairs are  output depends on the\ngiven parameters. Due to the  fact that this software is  aimed at being used in\ncurrent NGS research, many parameters are provided. \n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9480778857735853,
      "result": {
        "type": "Text_excerpt",
        "value": "README for SHRiMP: SHort Read Mapping Package version 1.3.2\nhttp://compbio.cs.toronto.edu/shrimp \nThis  document describes the  programs of  which SHRiMP  is comprised, including\ntheir use,  output formats, and various  parameters. The algorithms employed are\nalso briefly described. For more details, see the following publication: \nSHRiMP is brought to you by:\n\tStephen M. Rumble\n\tMichael Brudno\n\tPhil Lacroute\n\tVladimir Yanovsky\n\tMarc Fiume\n\tAdrian Dalca\n\tMatei David \nWe would like to thank Dr. Lucian Ilie of the  University of Western Ontario for\nproviding  us  with sets  of spaced  seeds  especially designed  to achieve good\nsensitivity. \n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "supervised_classification"
    }
  ],
  "documentation": [
    {
      "confidence": 1,
      "result": {
        "format": "wiki",
        "type": "Url",
        "value": "https://github.com/compbio-UofT/shrimp/wiki"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "regular_expression"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/compbio-UofT/shrimp/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 5
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/compbio-UofT/shrimp/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "compbio-UofT/shrimp"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "regular_expression"
    }
  ],
  "has_script_file": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/not_in_dist/make_dist_osx.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/not_in_dist/make_dist_linux.sh"
      },
      "technique": "file_exploration"
    }
  ],
  "installation": [
    {
      "confidence": 0.8875367326395598,
      "result": {
        "original_header": "4. Program Parameters",
        "type": "Text_excerpt",
        "value": "    E.g.:\n        bin/rmapper-cs reads.csfasta /path/to/genomedir/chr*.fa > output.rmapper \n    E.g.:\n\tbin/probcalc 7000000 output.rmapper > output.probcalc \n    E.g.:\n        bin/prettyprint-cs output.probcalc /path/to/genomedir/ reads.csfasta \n\tNB: A negative value disables this option. \n\tAlternatively, one can use the following grep command:  \n\tNone for now. \n\tSave only top_matches best matches. \n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9910539316139159,
      "result": {
        "type": "Text_excerpt",
        "value": "README for SHRiMP: SHort Read Mapping Package version 1.3.2\nhttp://compbio.cs.toronto.edu/shrimp \n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "supervised_classification"
    }
  ],
  "invocation": [
    {
      "confidence": 0.8870780891296025,
      "result": {
        "original_header": "4. Program Parameters",
        "type": "Text_excerpt",
        "value": "\tTo extract the list of unmapped reads from  the output file, simply list\n\tevery line following \"#UNMAPPED READS:\".  This can be accomplished  with\n\tthe utils/extractunmapped.py script: \n\t\t    python utils/extractunmapped.py /path/to/results.out \n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/compbio-UofT/shrimp/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "Other",
        "spdx_id": "NOASSERTION",
        "type": "License",
        "url": null,
        "value": null
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "$Id: LICENSE,v 1.4 2007/12/31 17:08:51 rumble Exp $\n\nThe following very liberal license applies to this distribution:\n\n-----\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that neither the name of Stephen\nM. Rumble nor the names of any contributors are used to endorse or\npromote products derived from this software without specific prior\nwritten permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n------\n"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/LICENSE",
      "technique": "file_exploration"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "shrimp"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "Organization",
        "value": "compbio-UofT"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "C",
        "size": 855962,
        "type": "Programming_language",
        "value": "C"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "C++",
        "size": 41230,
        "type": "Programming_language",
        "value": "C++"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Python",
        "size": 37895,
        "type": "Programming_language",
        "value": "Python"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Shell",
        "size": 18409,
        "type": "Programming_language",
        "value": "Shell"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Objective-C",
        "size": 9816,
        "type": "Programming_language",
        "value": "Objective-C"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Awk",
        "size": 503,
        "type": "Programming_language",
        "value": "Awk"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README.SHRiMP132"
      },
      "technique": "file_exploration"
    }
  ],
  "somef_missing_categories": [
    "citation",
    "run",
    "download",
    "requirements",
    "contributors",
    "faq",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-11-04 09:06:11",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 8
      },
      "technique": "GitHub_API"
    }
  ],
  "type": [
    {
      "confidence": 0.82,
      "result": {
        "type": "String",
        "value": "commandline-application"
      },
      "technique": "software_type_heuristics"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "2. Quick Start",
        "type": "Text_excerpt",
        "value": "  4.   Program Parameters"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "3. Usage",
        "type": "Text_excerpt",
        "value": "  5.   Output Format"
      },
      "source": "https://raw.githubusercontent.com/compbio-UofT/shrimp/master/README",
      "technique": "header_analysis"
    }
  ]
}
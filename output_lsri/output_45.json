{
  "application_domain": [
    {
      "confidence": 14.34,
      "result": {
        "type": "String",
        "value": "Computer Vision"
      },
      "technique": "supervised_classification"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/sanger-tol/gda"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2021-09-28T15:20:20Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2023-12-30T12:59:55Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "Genome Decomposition Analysis pipeline"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 0.978964819571954,
      "result": {
        "original_header": "GDA",
        "type": "Text_excerpt",
        "value": "Genome Decomposition Analysis for the characterisation of genome architecture\n \n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9775599824625386,
      "result": {
        "original_header": "What is GDA?",
        "type": "Text_excerpt",
        "value": "GDA (Genome Decomposition Analysis) is a bioinformatic pipeline to analyse genome architecture. Using, as a minimum, a genome assembly (the more complete the better), it will determine features in non-overlapping windows across the sequence and identify windows with common features. The assembly will then be annotated based on these similarities, highlighting structurally similar genomic regions. \nGDA is developed by Eerik Aunin (ea10@sanger.ac.uk) and Adam Reid (ajr236@cam.ac.uk) \nBelow is a diagram for a quick overview of what GDA does. \n(A) Features sets are derived from the genome reference sequence (seq), repeat finding (rep), gene annotations (gene) and evolutionary relationships between genes (orth). Values for each feature are determined for each non-overlapping window of e.g. 5kb across the genome. (B) The resulting matrix of feature values per window is embedded in two dimensions and clustered to identify groups of windows with similar properties. (C) The data can be explored in a number of ways using a web-browser based app. The clustering labels are mapped back to the chromosomes to highlight architectural features and a heatmap displays the features which define the clusters.   \n\nA more technical diagram of the components of the pipeline in the form of a flowchart can be seen [here](images/gda_pipeline_flowchart.png).\nA [Nextflow](https://www.nextflow.io/)-based pipeline that includes various third party tools extracts the values of a set of genomic variables that describe a genome assembly. The values of genomic variables along chromosomes are stored as [bedgraph files](https://genome.ucsc.edu/goldenPath/help/bedgraph.html). The bedgraph files corresponding to one genome assembly are then merged into one tab separated values (TSV) file. In the following text, this file is referred to as \"merged TSV\" file. Scaling of values, dimensionality reduction with [UMAP](https://umap-learn.readthedocs.io/en/latest/) and clustering with [HDBSCAN](https://hdbscan.readthedocs.io/en/latest/how_hdbscan_works.html) are then applied to the numbers in this TSV file. The locations of clusters along chromosomes are stored in a BED file. \n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9692593614023568,
      "result": {
        "original_header": "Notes",
        "type": "Text_excerpt",
        "value": "We expect that the GDA feature extraction and analysis pipeline is run remotely on a compute cluster with Linux. Viewing the results of a GDA analysis is done in a Shiny app that runs in a web browser and thus we recommend that you copy your results onto your local machine to run the final step. Thus, some dependencies are required remotely and some locally (installation instructions below). \nThe quick start tutorial will show you how to run the GDA pipeline end-to-end with test data (*Plasmodium falciparum* genome assembly [obtained from PlasmoDB](https://plasmodb.org/common/downloads/release-49/Pfalciparum3D7/fasta/data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta)) and default parameters. In reality you will likely want to add additional, optional tracks such as gene annotations, repeat finding, transcriptome data and orthology information (these are also detailed below).\n \n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/eeaunin/gda/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 1
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/sanger-tol/gda/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "sanger-tol/gda"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "GDA"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    }
  ],
  "has_script_file": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/feature_extraction/cpp/compile_gda_cpp.sh"
      },
      "technique": "file_exploration"
    }
  ],
  "images": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/images/Figure_1.png"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/images/02_gda_shiny_raster_plot.png"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/images/03_gda_shiny_cluster_heatmaps.png"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/images/04_gda_shiny_feature_tables.png"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/images/05_gda_shiny_cluster_positions_across_chromosomes.png"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/images/06_gda_shiny_chromosome_cluster_composition.png"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/images/07_gda_shiny_cluster_junction_counts.png"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/images/gda_pfalciparum_igv_screensh.png"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    }
  ],
  "installation": [
    {
      "confidence": 0.9751322520393625,
      "result": {
        "original_header": "What is GDA?",
        "type": "Text_excerpt",
        "value": "Complete analyses presented in the manuscript are available here: https://drive.google.com/drive/folders/1XSNS_Jj0_UGxPXpzY-EwbzABGxaZgfRf?usp=sharing \n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9998425029773299,
      "result": {
        "original_header": "Notes",
        "type": "Text_excerpt",
        "value": "We expect that the GDA feature extraction and analysis pipeline is run remotely on a compute cluster with Linux. Viewing the results of a GDA analysis is done in a Shiny app that runs in a web browser and thus we recommend that you copy your results onto your local machine to run the final step. Thus, some dependencies are required remotely and some locally (installation instructions below). \n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/sanger-tol/gda/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "nextflow"
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "MIT License",
        "spdx_id": "MIT",
        "type": "License",
        "url": "https://api.github.com/licenses/mit",
        "value": "https://api.github.com/licenses/mit"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "MIT License\n\nCopyright (c) 2020-2021 Genome Research Ltd.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/LICENSE",
      "technique": "file_exploration"
    }
  ],
  "logo": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/images/01_gda_shiny_umap.png"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "gda"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "Organization",
        "value": "sanger-tol"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "Python",
        "size": 405730,
        "type": "Programming_language",
        "value": "Python"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "R",
        "size": 61445,
        "type": "Programming_language",
        "value": "R"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Nextflow",
        "size": 21788,
        "type": "Programming_language",
        "value": "Nextflow"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "C++",
        "size": 18345,
        "type": "Programming_language",
        "value": "C++"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Singularity",
        "size": 5510,
        "type": "Programming_language",
        "value": "Singularity"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Shell",
        "size": 1618,
        "type": "Programming_language",
        "value": "Shell"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Lua",
        "size": 522,
        "type": "Programming_language",
        "value": "Lua"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "related_documentation": [
    {
      "confidence": 1,
      "result": {
        "format": "readthedocs",
        "type": "Url",
        "value": "https://umap-learn.readthedocs.io/"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "format": "readthedocs",
        "type": "Url",
        "value": "https://hdbscan.readthedocs.io/"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "regular_expression"
    }
  ],
  "releases": [
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "eeaunin",
          "type": "User"
        },
        "date_created": "2021-12-03T09:55:37Z",
        "date_published": "2021-12-03T11:10:04Z",
        "description": "First release of GDA",
        "html_url": "https://github.com/sanger-tol/gda/releases/tag/v1.0",
        "name": "v1.0",
        "release_id": 54569151,
        "tag": "v1.0",
        "tarball_url": "https://api.github.com/repos/sanger-tol/gda/tarball/v1.0",
        "type": "Release",
        "url": "https://api.github.com/repos/sanger-tol/gda/releases/54569151",
        "value": "https://api.github.com/repos/sanger-tol/gda/releases/54569151",
        "zipball_url": "https://api.github.com/repos/sanger-tol/gda/zipball/v1.0"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "author": {
          "name": "eeaunin",
          "type": "User"
        },
        "date_created": "2021-12-01T02:50:29Z",
        "date_published": "2021-12-01T03:32:23Z",
        "description": "Test release for GDA v1.0.0",
        "html_url": "https://github.com/sanger-tol/gda/releases/tag/v1.0.0-alpha",
        "name": "v1.0.0-alpha",
        "release_id": 54377409,
        "tag": "v1.0.0-alpha",
        "tarball_url": "https://api.github.com/repos/sanger-tol/gda/tarball/v1.0.0-alpha",
        "type": "Release",
        "url": "https://api.github.com/repos/sanger-tol/gda/releases/54377409",
        "value": "https://api.github.com/repos/sanger-tol/gda/releases/54377409",
        "zipball_url": "https://api.github.com/repos/sanger-tol/gda/zipball/v1.0.0-alpha"
      },
      "technique": "GitHub_API"
    }
  ],
  "requirements": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Requirements",
        "parent_header": [
          "GDA"
        ],
        "type": "Text_excerpt",
        "value": "GDA software consists of three main parts: a genomic feature extraction pipeline, clustering scripts, and a [Shiny](https://shiny.rstudio.com/) app for viewing the results. The genomic feature extraction pipeline and the clustering scripts have been tested on a Linux server (Sanger farm) and have the following requirements:\n\n  * [Conda](https://docs.conda.io/en/latest/miniconda.html)\n  * [Nextflow](https://www.nextflow.io/)\n  * Python3 \n  * Java \u2013 with enough memory to initialise the Java virtual machine\n  * Git\n\nThe Shiny app for viewing clustering results requires R and a number of R libraries. It has been tested on MacOS and Kubuntu Linux.\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    }
  ],
  "somef_missing_categories": [
    "citation",
    "acknowledgement",
    "run",
    "download",
    "contact",
    "contributors",
    "documentation",
    "faq",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-10-05 23:30:28",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 4
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Contents",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "  * [Quick start with test data](#quick-start-with-test-data)\n  * [Understanding the results tabs](#understanding-the-results-tabs)\n  * [View clusters and significant tracks in IGV](#view-clusters-and-significant-tracks-in-igv)\n  * [Understanding the output files](#understanding-the-output-files)\n  * [Adding optional features](#adding-optional-feature)\n  * [Optimising clustering](#optimising-clustering)\n  * [Understanding the default features](#understanding-the-default-features)\n  * [Other output](#other-output)\n  * [Using GDA Singularity image](#using-gda-singularity-image)\n  * [Clustering the features of multiple genomes at once](#clustering-the-features-of-multiple-genomes-at-once)\n  * [Troubleshooting](#troubleshooting)\n  * [Ideas for analysis](#ideas-for-analysis)\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Quick start with test data",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "**1. Set up a GDA conda environment on the farm (need to install conda? \u2013 https://docs.conda.io/en/latest/miniconda.html)**\n\n  * Clone the GitHub repository\n\n`git clone https://github.com/eeaunin/gda.git`\n\n  * Run the conda installation script (this can take a little while)\n\n`python gda/create_gda_conda_env.py gda_env gda_downloads gda`\n\n  * Initiate the conda environment:\n\n`conda activate gda_env`\n\nIf the conda installation does not work for you, you can try using the GDA [Singularity](https://sylabs.io/guides/3.0/user-guide/quick_start.html) image instead, see [Using GDA Singularity image](#using-gda-singularity-image).\n\n**2. Run GDA**\n\n  * Run GDA\u2019s feature extraction pipeline with test data (we suggest that you submit this to your cluster as a job with 12 threads and 10Gb memory; expect it to take ~15 minutes with the test data):\n\n**Either** plain command\n```\ngda extract_genomic_features --threads 12 --pipeline_run_folder gda_pipeline_run gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta\n```\n\n**Or** by submission to Load Sharing Facility (LSF)\n```\nbsub -n12 -R\"span[hosts=1]\" -M10000 -R 'select[mem>10000] rusage[mem=10000]' -o gda_test.o -e gda_test.e \"gda extract_genomic_features --threads 12 --pipeline_run_folder gda_pipeline_run gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta\"\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The results will be in the folder: `gda_pipeline_run`. The output file required for clustering is:\n\n`gda_pipeline_run/merged_bedgraph_table/PlasmoDB-49_Pfalciparum3D7_Genome_merged_bedgraph.tsv`\n\n  * Cluster genome windows and analyse clusters (Use 1 thread and 10Gb memory; this should take ~1 minute; n.b. optimised clustering parameters are provided here)\n\n**Either** plain command\n\n```\ngda clustering -c 100 -n 5 gda_pipeline_run/merged_bedgraph_table/PlasmoDB-49_Pfalciparum3D7_Genome_merged_bedgraph.tsv\n```\n\n**Or** by submission to LSF\n```\nbsub -n1 -R\"span[hosts=1]\" -M10000 -R 'select[mem>10000] rusage[mem=10000]' -o gda_clustering_test.o -e gda_clustering_test.e \"gda clustering -c 100 -n 5 gda_pipeline_run/merged_bedgraph_table/PlasmoDB-49_Pfalciparum3D7_Genome_merged_bedgraph.tsv\"\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The clustering output will be in a folder called: `gda_out`\n\n**3. Install dependencies on your local machine**\n\nMOVE TO YOUR LOCAL MACHINE (e.g. your desktop/laptop)\n\n  * Set up environment\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;These are the required R libraries:\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shiny, ggplot2, devtools, svglite, gplots, rjson, reshape2, gridExtra, scales\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you have an R installation on your local machine that is not conda-based, the following R script should install the required libraries:\n\n```\ngit clone https://github.com/eeaunin/gda.git\n\ngda/gda_shiny/install_gda_shiny_dependencies_without_conda.R\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alternatively, the following commands can be used to install a custom conda R environment for the GDA Shiny app:\n```\ngit clone https://github.com/eeaunin/gda.git\n\n# update conda to v4.10.1\nconda update -n base conda\n\nconda create -n gda_env_local r-essentials r-base\n\nconda activate gda_env_local\n\nconda install --yes -c r -c conda-forge r-shiny=1.5.0 r-ggplot2=3.2.1 r-gplots=3.0.3 r-rjson=0.2.20 r-reshape2=1.4.3 r-gridextra=2.3 r-scales=1.0.0 r-svglite=1.2.3\n\n```\n\n  * Copy the data from the remote machine to your local machine (while on you local machine) e.g.\n`scp -r <user>@<remote_machine>:<path>/gda_out/ .`\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In order to use scp to copy the files, you will need to be able to see the remote machine (perhaps via VPN).\n\n**4. View results**\n\nThe required argument for the `gda_shiny.py` script is a path to a `gda_out` folder (that comes from the output of `gda_clustering.py` and which you just copied from the remote machine). \n\n```\npython3 gda/gda_shiny/gda_shiny.py gda_out\n```\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Understanding the results tabs",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "**UMAP plot**\n![](images/01_gda_shiny_umap.png)\n\nThis shows you how well the clustering worked.  Each point in the plot represents a genomic window. Windows are coloured by cluster. Cluster -1 (grey) is used for unclustered windows. Based on the nature of the genome, the features used, the window size and other parameters, there may, for example, be several very distinct, tight clusters, or perhaps a single diffuse cloud of points. Distinct, tight clusters suggest that GDA has identified regions of the genome which are clearly similar to each other and distinct from other regions. A single diffuse cloud means that there were not strong similarities or differences between subsets of the windows. There might be a lot of the genome which is unclassified (grey) or it might all be included in clusters. Sliders can be used to adjust plots for better viewing and PNG or SVG images can be saved.\n\n**Cluster locations**\n![](images/02_gda_shiny_raster_plot.png)\n\nEach chromosome/scaffold/contig is shown, with each window coloured based on the clustering. Therefore, this shows how the clusters pattern the chromosomes and, for example, whether a particular cluster tends to be found at the end of chromosomes. Do all chromosomes have a similar pattern? Do sex chromosomes, B chromosomes etc. look distinct from the autosomes?\n\n**Cluster heatmaps**\n![](images/03_gda_shiny_cluster_heatmaps.png)\n\nGDA determines features which have high or low values for windows in a particular cluster compared to other clusters. The heatmap in this tab shows the relative values across clusters for each significantly variable feature. Green means a feature has a relatively high value in a particular cluster, red a relatively low value. You can find the exact values and which were significantly different in the \u201cFeature tables\u201d tab. Adjusting the plot height and the label size can be particularly useful in this tab so that the heatmap is legible.\n\n**Feature tables**\n![](images/04_gda_shiny_feature_tables.png)\n\nThis tab has a table for each cluster (and unclustered windows), describing which features have significantly higher or lower values (by the Kolmogorov-Smirnov test). The default p-value cutoff for the Kolmogorov-Smirnov test is 1e-20.\n\n**Cluster positions across chromosomes**\n![](images/05_gda_shiny_cluster_positions_across_chromosomes.png)\n\nThis tab shows where each cluster tends to occur across the sequences. It helps you to see whether a cluster tends to occur at the ends or in the middles of chromosomes for instance.\n\n**Chromosome cluster composition**\n![](images/06_gda_shiny_chromosome_cluster_composition.png)\n\nThis tab contains a heatmap which clusters chromosomes by their cluster composition. Chromosomes which have similar proportions of each cluster will be closer together in the heatmap. This helps in identifying outliers which might represent interesting sequences such as sex chromosomes, B chromosomes etc.\n\n**Cluster junction counts**\n![](images/07_gda_shiny_cluster_junction_counts.png)\n\nThis tab shows the observed counts of junctions between windows belonging to each UMAP+HDBSCAN cluster. Junctions between windows belonging to the same type of cluster are included in the counts. The observed counts are compared with counts expected if windows were distributed randomly. Junctions with counts that are significantly different from what is expected by chance (based on Fisher test) are shown in **_bold+italics_**.\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "View clusters and significant tracks in IGV",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "The values of variables along chromosomes are stored as [bedgraph files](https://genome.ucsc.edu/goldenPath/help/bedgraph.html) and can be viewed in genome browsers such as [IGV](https://software.broadinstitute.org/software/igv). \n\n**1. Install IGV**\n\nhttps://software.broadinstitute.org/software/igv/download\n\n**2. Get bedgraph files from cluster**\n\n`scp -r <remote_machine>:<path>/gda_pipeline_run/bedgraph_output/ .`\n\n**3. Copy across clustering results (if you haven\u2019t already)**\n\n`scp -r <remote_machine>:<path>/gda_out/ .`\n\n**4. Make IGV session file**\nIGV allows saving and loading [session files](https://software.broadinstitute.org/software/igv/Sessions), which are XML files that keep track of the program state (what FASTA, BED and bedgraph files have been simultaneously loaded to IGV).\n```\ngda/gda_make_igv_session_file.py -g gda/test_data/PlasmoDB-49_Pfalciparum3D7.gff gda_out/cluster_heatmap.csv gda_out/PlasmoDB-49_Pfalciparum3D7_Genome/clusters.bed gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta bedgraph_output/\n```\n\n**5. Load session file into IGV**\n\nFile \u2192\u201cOpen Session\u201d\n\n![](images/gda_pfalciparum_igv_screensh.png)\nThe IGV screenshot above shows _Plasmodium falciparum_ chromosome 1, with some GDA bedgraph tracks and the 'clusters.bed' file loaded.\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Understanding the output files",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "**Bedgraph files**\n\nWith your results directory (`<YYYYMMDD>_gda_pipeline_run` by default; use `gda extract_genomic_features --pipeline_run_folder` to change), the folder `bedgraph_output` contains each bedgraph track produced by GDA. These can be loaded into a genome browser (e.g. IGV) for viewing and better understanding why GDA has clustered the genome as it has. We provide the script `gda_make_igv_session_file.py` to generate an IGV session file for your genome which will show the clusters and tracks for features which are significantly enriched in the clusters.\n\nOne of the files generated by the `gda_clustering.py` script is called `clusters.bed`. This file marks the locations of each UMAP+HDBSCAN cluster and can be loaded to IGV alongside the bedgraph tracks. The cluster numbers and the colour key are the same as in the UMAP plot of the Shiny app.\n\n**The feature table**\n\n| cluster | feature | cluster_data.size | other_data.size | stat_less | pvalue_less | stat_great | pvalue_great | cluster_median | other_median | cluster_mean | other_mean |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 0 | cpg_percentage | 185 | 4491 | 0.00 | 1.00e+00 | 0.47 | 1.86e-35 | 0.98000 | 0.66000 | 1.15760 | 0.69856 |\n| 0 | tandem_repeats_fraction | 185 | 4491 | 0.56 | 1.36e-49 | 0.01 | 9.86e-01 | 0.07840 | 0.15620 | 0.08711 | 0.15905 |\n| 0 | wgsim_depth_minimap2 | 185 | 4491 | 0.90 | 4.03e-127 | 0.00 | 1.00e+00 | 3.71320 | 9.94240 | 3.98305 | 9.90542 |\n| 1 | cpg_percentage | 4491 | 185 | 0.47 | 1.86e-35 | 0.00 | 1.00e+00 | 0.66000 | 0.98000 | 0.69856 | 1.15760 |\n| 1 | tandem_repeats_fraction | 4491 | 185 | 0.01 | 9.86e-01 | 0.56 | 1.36e-49 | 0.15620 | 0.07840 | 0.15905 | 0.08711 |\n| 1 | wgsim_depth_minimap2 | 4491 | 185 | 0.00 | 1.00e+00 | 0.90 | 4.03e-127 | 9.94240 | 3.71320 | 9.90542 | 3.98305 |\n\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Adding optional features",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "We recommend you add as many features as possible so that the clustering is able to identify those which are the strongest signals in the genome.\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Optional features which do not require additional data",
        "parent_header": [
          "GDA",
          "Tutorial",
          "Adding optional features"
        ],
        "type": "Text_excerpt",
        "value": "**1. Run repeat finding to get bedgraph tracks of individual complex repeat features as well as complex_repeat_sum (the sum of all these features)**\nThe GDA pipeline contains two mandatory components for repeat detection: [TandemRepeatsFinder](https://github.com/Benson-Genomics-Lab/TRF) for tandem repeats and [EMBOSS einverted](http://emboss.sourceforge.net/apps/cvs/emboss/apps/einverted.html) for inverted repeats. Besides these, the GDA pipeline has two optional repeat family detection modules from which the user can choose one to run. The first one of these modules uses [RepeatModeler+RepeatMasker](https://www.repeatmasker.org/RepeatModeler/) and the second one uses [Red+MeShClust2](https://github.com/BioinformaticsToolsmith/MeShClust2). RepeatModeler+RepeatMasker is relatively slow and may take ~1 week to run for large genomes (11 hours for the test dataset). On Sanger farm5, this will require using the basement queue. The Red+Meshclust2 module is much faster, but may produce more noisy repeat families, depending on the genome.\nWhen the GDA pipeline is run with repeat family detection enabled, the bedgraph files of each complex repeat family appear in the `complex_repeats` subdirectory of the `bedgraph_output` directory. If RepeatModeler is used, a `simple_repeats` directory that contains bedgraph files of simple repeat families is also produced. \nIn addition, a bedgraph file of the sum of complex repeat families (and if using RepeatModeler, of simple repeat families) is produced. The individual bedgraph tracks of each repeat family are not used as the input for UMAP clustering by default, but the tracks for the sums of simple or complex repeat families are used.\n\n```\n--run_repeat_family_detection\n--repeat_family_detection_engine <repeatmodeler/meshclust2>\n```\n\ne.g.\n \n**Either** plain command\n \n```\ngda extract_genomic_features --threads 12 --run_repeat_family_detection --repeat_family_detection_engine repeatmodeler gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta\n```\n \n**Or** by submission to LSF\n \n```\nbsub -n12 -R\"span[hosts=1]\" -M10000 -R 'select[mem>10000] rusage[mem=10000]' -o gda_repeatmodeler_test.o -e gda_repeatmodeler_test.e \"gda extract_genomic_features --threads 12 --run_repeat_family_detection --repeat_family_detection_engine repeatmodeler gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta\"\n```\n\n**2. _De novo_ gene annotation**\nThe GDA pipeline can take an existing gene annotations GFF3 file as input. For the cases where there is no existing gene annotations available for the genome, the pipeline contains an optional module that produces a _de novo_ annotation of protein coding genes, rRNA and tRNA genes (using [Augustus](https://bioinf.uni-greifswald.de/augustus/), [Barrnap](https://github.com/tseemann/barrnap) and [tRNAscan-SE](http://lowelab.ucsc.edu/tRNAscan-SE/)). The gene annotation module can optionally take an annotated related genome as the input and produce hints for Augustus based on annotation transfer with [Liftoff](https://github.com/agshumate/Liftoff). Several bedgraph feature tracks are derived from gene annotations: `mRNA_annotation`, `exon_count`, `gene_average_exon_length`, `gene_average_intron_length`, `gene_length`, `tRNA_annotations`, `rRNA_annotations`. Optionally, a `gene_dna_strand_bias` track is also produced. \nAlso, a GFF file of the annotations can be found in the `gene_annotation` folder. The GFF file also includes the tRNAscan and Barrnap results.\n\nMultiple options are required\n```\n--run_gene_annotation_pipeline\n--annotation_target_species_id <label_for_gene_ids>\n--augustus_species <pick_from_list>\n```\n\ne.g.\n\n**Either** plain command\n\n```\ngda extract_genomic_features --threads 12 --pipeline_run_folder aug_test_runfolder --run_gene_annotation_pipeline --annotation_target_species_id PFALTEST --augustus_species pfalciparum gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta\n```\n\n**Or** by submission to LSF\n \n```\nbsub -n12 -R\"span[hosts=1]\" -M10000 -R 'select[mem>10000] rusage[mem=10000]' -o gda_test_aug.o -e gda_test_aug.e \"gda extract_genomic_features --threads 12 --pipeline_run_folder aug_test_runfolder --run_gene_annotation_pipeline --annotation_target_species_id PFALTEST --augustus_species pfalciparum gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta\"\n\n```\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Optional features requiring additional data",
        "parent_header": [
          "GDA",
          "Tutorial",
          "Adding optional features"
        ],
        "type": "Text_excerpt",
        "value": "**1. Genome annotation**\n`--gff_path <GFF3 file with existing gene annotations>`\n\nFor handling user-provided GFF files, the pipeline expects the following things:\n- the input file is in GFF3 format (GTF or GFF2 are not accepted)\n- the tags for mRNA, pseudogene, tRNA and rRNA features are \"mRNA\", \"pseudogene\", \"tRNA\" and \"rRNA\". The user should check the GFF file to make sure that the tags are named according to this convention. If, for instance, the mRNA features in the GFF file are called \"transcript\" instead of \"mRNA\", the pipeline does not recognise them as the mRNA features.\n- the GFF file should pass the [GenomeTools GFF3 validator check](http://genometools.org/cgi-bin/gff3validator.cgi).\n\nThe user can specify non-standard GFF3 feature tags from the input GFF3 file to be turned into bedgraph tracks using the `--custom_gff_tags` option of the `gda` wrapper. For example, if the input GFF3 file has features named \"H3K9me3\" and \"H3K9ac\", it is possible to make bedgraph files out of them by specifying them as comma separated `custom_gff_tags` options:\n\n`\n--custom_gff_tags H3K9me3,H3K9ac\n`\n\n\n**2. Reference genome annotation (annotate your assembly using a reference annotation: hints for Augustus are derived from annotation transfer using Liftoff)**\n\n`--reference_assembly_path <reference assembly FASTA file>\n--reference_gff_path <reference assembly GFF3 file>\n`\n\n\n**3. RNA-Seq coverage**\nRNA-Seq coverage is determined using the mapping of reads to the assembly with [HISAT2](http://daehwankimlab.github.io/hisat2/manual/). The input is a pair of gzipped FASTQ reads.\n```\n--rna_seq_fastq_1_path\n--rna_seq_fastq_2_path\n```\n\ne.g. \n\n```\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR223/008/ERR2234508/ERR2234508_1.fastq.gz .\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR223/008/ERR2234508/ERR2234508_2.fastq.gz .\n```\n\n**Either** plain command\n```\ngda extract_genomic_features --threads 12 --rna_seq_fastq_1_path ERR2234508_1.fastq.gz --rna_seq_fastq_2_path ERR2234508_2.fastq.gz gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta\n``` \n \n**Or** by submission to LSF\n \n```\nbsub -n12 -R\"span[hosts=1]\" -M10000 -R 'select[mem>10000] rusage[mem=10000]' -o gda_test.o -e gda_test.e \"gda extract_genomic_features --threads 12 --rna_seq_fastq_1_path ERR2234508_1.fastq.gz --rna_seq_fastq_2_path ERR2234508_2.fastq.gz gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta\"\n```\n\nThe resulting feature track is called `hisat2_samtools_depth` and the raw mapping data is in the `rna_seq_mapping` folder.\n\n**4. Gene conservation (orthology)**\n\n`--orthomcl_references_folder`\n\nThis folder should contain subfolders, each for separate [OrthoMCL](https://orthomcl.org/orthomcl/app) runs, e.g. for closely related and more distantly related species (although a single folder is perfectly fine). The folder name is arbitrary. Within each folder there should be protein FASTA files for each reference proteome and a file called `table_for_gg_file.csv` with the names of these files and a simple name for the species. GG files (genome gene relation file) are used by OrthoMCL to relate genes to genomes. e.g.\n\n```\nPchabaudi,PlasmoDB-49_Pchabaudichabaudi_AnnotatedProteins.fasta\nTgondii,ToxoDB-51_TgondiiME49_AnnotatedProteins.fasta\n```\n\nProteins from the genome under consideration will be added behind the scenes (they are derived from the assembly FASTA file and annotations GFF3 file using [gffread](https://github.com/gpertea/gffread)). N.b. you need to provide annotation for your genome assembly or have it transferred/predicted in order to do the orthology analysis. \n\ne.g.\n\n**Either** plain command\n```\ngda extract_genomic_features --threads 12 --pipeline_run_folder orthomcl_test_runfolder --orthomcl_references_folder gda/test_data/orthomcl_refs/ --run_gene_annotation_pipeline --annotation_target_species_id PFALTEST --augustus_species pfalciparum gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta\n```\n\n**Or** by submission to LSF\n\n```\nbsub -n12 -R\"span[hosts=1]\" -M10000 -R 'select[mem>10000] rusage[mem=10000]' -o gda_test_orthomcl.o -e gda_test_orthomcl.e \"gda extract_genomic_features --threads 12 --pipeline_run_folder orthomcl_test_runfolder --orthomcl_references_folder gda/test_data/orthomcl_refs/ --run_gene_annotation_pipeline --annotation_target_species_id PFALTEST --augustus_species pfalciparum gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta\"\n```\n\nThe resulting bedgraph files are:\n\n`PFALTEST_apicomplexa_ortholog_count.bedgraph` - Number of orthologues per gene       \n\n`PFALTEST_apicomplexa_paralog_count.bedgraph` - Number of paralogues per gene\n\n`PFALTEST_apicomplexa_protein_conservation_ratio.bedgraph` - The average proportion of species in the OrthoMCL run that have orthologs for the target species proteins in the window. The value is 1 if all target species proteins in the window have OrthoMCL orthologs in all other species in the OrthoMCL run. The value is 0 if none of the target species proteins in the window have any OrthoMCL orthologs in any other species in the OrthoMCL run. \n\n           \n`PFALTEST_apicomplexa_species_specific_proteins_ratio.bedgraph` - The average proportion of species-specific proteins in the window. It is the number of target species proteins with no OrthoMCL orthologs in the window divided by the number of all target species proteins in the window. The value is 1 if none of the target species proteins in the window have OrthoMCL orthologs, and 0 if all of the target species proteins in the window have OrthoMCL orthologs.\n\n**5. Reference mitochondrial sequence for Nuclear Mitochondrial DNA (NUMT) identification**\nNUMT identification is done using BLAST of the genome against a user-provided reference mitochondrial sequence. The reference mitochondrial sequence can be a known mitochondrial sequence from the same species as the rest of the assembly. If a region of an assembly contig yields a strong BLAST hit (e-value <= 1e-30) to the reference mitochondrial sequence but the alignment length is less than 90% of the length of this contig, the BLAST hit region is labelled as a putative NUMT.\n\n`--ref_mitoch_fasta_path`\n\n**6. Reference plastid sequence for NUPT identification**\nThis is the same process as the detection of NUMTs but meant for plastid sequences.\n\n`--ref_apicoplast_fasta_path`\n\n**7. Other useful feature extraction options**\nThe pipeline tries to identify telomeric regions by searching the assembly sequences for exact matches to a telomeric motif. The `telomeric_seq_preset` option allows to select a query telomeric motif from a list of known telomeric motifs across different species (based on the Wikipedia article on telomeres, https://en.wikipedia.org/wiki/Telomere). It is also possible to specify a custom telomeric motif using the `custom_telomeric_seq` option.\n\n`--telomeric_seq_preset`\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Optimising clustering during feature extraction",
        "parent_header": [
          "GDA",
          "Tutorial",
          "Optimising clustering"
        ],
        "type": "Text_excerpt",
        "value": "Change the window size (5kb)\n\n`--chunk_size`\n\nThis is perhaps the most important option in GDA. From a purely computational point of view, GDA will struggle with clustering a very large number of windows. From a biological perspective, it determines the resolution at which you are analysing the genome assembly. We find that 5kb works very well for the relatively miniscule _Plasmodium_ genome (~20Mb). For the common toad (_Bufo bufo_) genome, which is 4.94 Gb we have used 1 Mb window size. Aiming for 5000 windows works very nicely computationally, but you should experiment with a few window sizes, to see what gives an interesting view of the genome. You needn't run feature extraction multiple times. Instead use:\n\n`gda downsample_merged_tsv <tsv> <factor>`\n\nIf you started with a 5kb window size, use 4 as the downsampling factor and you will get a merged TSV file with 20kb windows. Similarly, use a factor of 10 to get 50kb windows.\n\nIf the genomic feature extraction pipeline produces an output TSV file that has 10000 or more windows, a downsampled TSV file with approximately 5000 windows will be automatically generated alongside the main output TSV file.\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Optimising clustering during clustering step",
        "parent_header": [
          "GDA",
          "Tutorial",
          "Optimising clustering"
        ],
        "type": "Text_excerpt",
        "value": "Once the feature extraction pipeline is finished, you can determine good clustering parameters by looking at the UMAP plots from a range of different parameters:\n\n**Either** plain command\n```\ngda clustering_params 20210312_gda_pipeline_run/merged_bedgraph_table/PlasmoDB-49_Pfalciparum3D7_Genome_merged_bedgraph.tsv\n```\n\n**Or** by submission to LSF\n``` \nbsub -n1 -R\"span[hosts=1]\" -M10000 -R 'select[mem>10000] rusage[mem=10000]' -o gda_params_test.o -e gda_params_test.e \"gda clustering_params 20210312_gda_pipeline_run/merged_bedgraph_table/PlasmoDB-49_Pfalciparum3D7_Genome_merged_bedgraph.tsv\"\n```\nReplace the `20210312_gda_pipeline_run` in the above command with the name of your GDA pipeline run folder path. \n\n`n_neighbors` is a UMAP setting that determines the size of the local neigbourhood in terms of sample points (https://umap-learn.readthedocs.io/en/latest/parameters.html). Smaller `n_neigbors` values give more emphasis on local structure in the data and larger `n_neighbors` values give more weight to global structure. We have used `n_neighbors` values from 5 to 200.\nBy default the clustering will be run with `n_neighbors` set to 5, 10, 15, 20, 50, 100 and \u201cMinimum cluster size\u201d set to 50, 100, 200, 500. All parameter pairs will be explored (e.g. 24 combinations). The results of each clustering are output to STDOUT. You can also view an HTML file of UMAP plots in a web browser e.g.:\n\n`firefox gda_out/parameter_selection/parameters.html &`\n\n[warning this can run slowly when run remotely]\n\n[Here](images/pfalciparum_gda_parameters_example.pdf) is example output of the `gda clustering_params` run with the _Plasmodium falciparum_ assembly.\n\nWe recommend selecting parameters based on minimising the percentage of unclassified sequence, while getting at least two clusters. E.g.:\n\n```\nN neighbours: 5\nMin cluster size: 50\nCluster -1 is 2.14% of the genome\nCluster 0 is 2.99% of the genome\nCluster 1 is 3.70% of the genome\nCluster 2 is 91.17% of the genome\n```\n\nOnly 2.14% of windows were unclassified and there are multiple clusters meaning GDA has identified some partitioning of the genome.\n\nGiven that this pair of parameters involves the lowest values, it would be a good idea to try out even lower parameter values to see if there is an even better/more interesting clustering.\n\nYou should pick minimum cluster sizes based on the number of windows you have. E.g. If you have 5000 windows, and you have a minimum cluster size of 50, the smallest possible cluster will contain 1% of your genome assembly.\n\nWhen clustering a large number of genomic windows, you may need to set HDBSCAN's `min_samples` value to a value that is not `None` in order to prevent HDBSCAN from crashing (https://github.com/scikit-learn-contrib/hdbscan/issues/250).\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Understanding the default features",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "\n| Variable | Description |\n| ------------- | ------------- |\n| at_skew | AT skew |\n| cag_freq | CAG trinucleotide repeat frequency |\n| complex_repeats_bedgraph | complex repeats detected using [RepeatModeler+RepeatMasker](https://www.repeatmasker.org/RepeatModeler/) or [Red+MeShClust2](https://github.com/BioinformaticsToolsmith/MeShClust2) |\n| cpg_percentage | CpG dinucleotide frequency |\n| dustmasker_low_complexity_percentage | low complexity sequence frequency (detected using [Dustmasker](https://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/dustmasker/)) |\n| ectopic_apicoplast | putative ectopic apicoplast (detected using BLAST against user-provided apicoplast sequence) |\n| ectopic_mitochondrion | putative NUMTs (detected using BLAST against user-provided mitochondrial sequence) |\n| einverted | inverted repeats (detected using [EMBOSS einverted](http://emboss.sourceforge.net/apps/cvs/emboss/apps/einverted.html)) |\n| exon_count | average exon count per mRNA gene |\n| gaps | assembly gaps (Ns) |\n| gc_percentage | GC% |\n| gc_skew | GC skew |\n| gene_average_exon_length | average exon length of mRNA genes |\n| gene_average_intron_length | average intron length of mRNA genes |\n| gene_dna_strand_bias | tendency of genes to be all on the same strand in the window. The value is 1 if all genes in the window are on the same strand (it does not matter which one). The value is 0 if genes in the window are equally distributed between both strands |\n| gene_length | average mRNA gene length |\n| kmer_deviation_kmer_size_3* | kmer skew for a for a particular kmer length (how much the distribution of kmers in the window differs from what is expected by change, given the GC content of the sequence in the window) |\n| ltrdigest_protein_matches | [LTRdigest](https://github.com/genometools/genometools) protein matches |\n| ltrdigest_retrotransposons | putative retrotransposons (detected using [LTRharvest and LTRdigest](https://github.com/genometools/genometools)). Only the sequences containing LTRdigest protein matches are counted |\n| mRNA_annotations | mRNA gene density (either from user-provided gene annotations or detected using [Augustus](https://bioinf.uni-greifswald.de/augustus/)) |\n| ortholog_count | average number of orthologs ([OrthoMCL](https://orthomcl.org/orthomcl/) orthologs in other species) for proteins in the window |\n| paralog_count | average number of paralogs (OrthoMCL orthologs within the same species) for proteins in the window |\n| protein_conservation_ratio | reflects the average proportion of species in the OrthoMCL run that have orthologs for the target species proteins in the window. The value is 1 if all target species proteins in the window have OrthoMCL orthologs in all other species in the OrthoMCL run. The value is 0 if none of the target species proteins in the window have any OrthoMCL orthologs in any other species in the OrthoMCL run.  |\n| pseudogene_annotations | pseudogenes (read from user-provided GFF3 file if this feature is present there) |\n| rRNA_annotations | rRNA_annotations (either from user-provided gene annotations or detected using Barrnap) |\n| simple_repeats_bedgraph | simple repeats detected using RepeatModeler+RepeatMasker. The sequences have been collapsed to count repeats that are the reverse complement of one another as the same repeat. They have also been collapsed to count the repeats that are identical if the starting point is adjusted as the same repeat (e.g. TGGTT is the same as GGTTT) |\n| species_specific_proteins_ratio | reflects the average proportion of species specific proteins in the window. It is the number of target species proteins with no OrthoMCL orthologs in the window divided by the number of all target species proteins in the window. The value is 1 if none of the target species proteins in the window have OrthoMCL orthologs, and 0 if all of the target species proteins in the window have OrthoMCL orthologs. |\n| stop_codon_freq | stop codon frequency |\n| sum_of_complex_repeats | sum of values of RepeatModeler+RepeatMasker or Red+MeShClust2 tracks for complex repeat families |\n| sum_of_simple_repeats | sum of values of RepeatModeler tracks for simple repeat families |\n| tandem_repeat_density | tandem repeats (detected using [Tandem Repeats Finder](https://github.com/Benson-Genomics-Lab/TRF)) |\n| telomere_freq | telomeric sequence frequency |\n| tRNA_annotations | tRNAs (either from user-provided gene annotations or detected using [tRNAscan-SE](http://lowelab.ucsc.edu/tRNAscan-SE/)) |\n| wgsim_minimap2_coverage | coverage of [WGSIM](https://github.com/lh3/wgsim) simulated short reads, derived from the assembly itself, with a target coverage of 10x. The reads have been mapped back to the assembly using Minimap2 using the short read mapping mode. Multimapping simulated reads have been removed before calculating the coverage |\n\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Other output",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "`/work/` directory \u2013 Files automatically generated by Nextflow during the run. These files can be used for resuming the pipeline when crashed. Nextflow has a `-resume` option for restarting an interrupted run from the last cached checkpoint. In the GDA pipeline wrapper script, the `resume_genomic_feature_extraction` command is meant for restarting the pipeline using Nextflow's `-resume` flag. For this you will need to provide the path to the Nextflow config file (it is a file with the name `nextflow.config` in the `*_gda_pipeline_run folder`) and the name of the crashed run. The run names are autogenerated by Nextflow and can be seen in the STDOUT log of the GDA run, in square brackets below the line that says \"N E X T F L O W\". If the run was started using the GDA Singularity image, you will also need to provide the path to that image, otherwise this path is not needed.\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Clustering the features of multiple genomes at once",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "It is possible to cluster the features extracted from multiple genomes at the same time. To do this, the first step is to run the genomic feature extraction pipeline separately for each genome of interest. For each genome, this will produce a TSV table with the values of the genomic features. The tables can then be concatenated using the `gda_concatenate_tsv_tables.py` script. Each of the input tables needs to have the same window size. In the `species` and `chromosome` columns, each input TSV table needs to have unique values that do not occur in the other input TSV tables. After concatenating the tables, the resulting combined table can be processed with the `gda clustering_params` and `gda clustering` commands. When viewing the clustering results of a multi-genome TSV table in the Shiny app, an extra UMAP plot will appear, with dots coloured according to which input assembly each window belongs to ([example](images/clustering_two_genomes_umap_example.png)). \n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Using GDA Singularity image",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "As an alternative to using conda to install the dependencies for GDA, it is also possible to read the dependencies from a Singularity image. A Singularity image file with the dependencies for GDA has been deposited in Google Drive, at https://drive.google.com/file/d/1cKw1cXjUBUODzBbxw7txAE80Q8g5hl8_/view?usp=sharing.\n \nIf you have gdown (https://github.com/wkentaro/gdown, https://anaconda.org/conda-forge/gdown) installed on your system, you can download the Singularity image file from Google Drive with a terminal command:\n \n`gdown https://drive.google.com/uc?id=1cKw1cXjUBUODzBbxw7txAE80Q8g5hl8_`\n \n On the Sanger farm, Singularity can be started from the farm module:\n\n`module load ISG/singularity/3.6.4`\n\nYou will need to make sure Singularity and Nextflow are installed on your cluster.\nFor running GDA with the Singularity image, you should still clone this GitHub repository and add the `gda` wrapper script to `PATH`. To use the GDA Singularity image, you should provide the path to the image with the `--singularity_image_path` option of the `gda` wrapper script. The remaining software dependencies (RepeatModeler, HISAT2, LTRharvest, etc) will then be loaded from the Singularity image. This is an example command for extracting genomic features using Singularity:\n\n**Either** plain command\n``` \ngda extract_genomic_features --threads 12 --pipeline_run_folder gda_pipeline_run gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta --singularity_image_path <gda_singularity.simg>\n```\n \n**Or** by submission to LSF\n``` \nbsub -n12 -R\"span[hosts=1]\" -M10000 -R 'select[mem>10000] rusage[mem=10000]' -o gda_test.o -e gda_test.e \"gda extract_genomic_features --threads 12 --pipeline_run_folder gda_pipeline_run gda/test_data/PlasmoDB-49_Pfalciparum3D7_Genome.fasta --singularity_image_path <gda_singularity.simg>\"\n```\n\nYou can also run the `gda_clustering_params` and `gda_clustering` commands with the Singularity image by providing a path to the image with the `--singularity_image_path` option.\n\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Troubleshooting",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "\u2022\tThe best place to look for error messages initially is STDOUT, rather than STDERR, because the Nextflow error messages end up there. You may then be directed to the `error_stream_logs` directory in your run folder for error messages from a specific process\n \n\u2022\tYou may want to exclude the mitochondrial and other symbiont genomes as well as any shorter, non-chromosomal scaffolds\n \n\u2022\tIf your genome assembly is large and clustering is problematic you may want to increase window size. You can do this with an existing merged TSV file using `gda downsample_merged_tsv <path to the TSV file> <downsampling factor>`\n\nBugs, suggestions etc. can be sent to ea10@sanger.ac.uk and ajr236@cam.ac.uk, or submitted as issues on this GitHub page.\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Ideas for analysis",
        "parent_header": [
          "GDA",
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "  * Use a single feature from the merged TSV to make calls for where this feature is high across a genome \u2013 e.g. paralogous gene families or a particular complex repeat family of interest.\n\n"
      },
      "source": "https://raw.githubusercontent.com/eeaunin/gda/main/README.md",
      "technique": "header_analysis"
    }
  ]
}
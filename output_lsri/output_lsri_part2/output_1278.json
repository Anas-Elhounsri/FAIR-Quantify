{
  "application_domain": [
    {
      "confidence": 13.23,
      "result": {
        "type": "String",
        "value": "Computer Vision"
      },
      "technique": "supervised_classification"
    }
  ],
  "citation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Citations",
        "type": "Text_excerpt",
        "value": "**software** : *Yajing Hao, Changwei Shao, Guofeng Zhao, Xiang-Dong Fu (2021). ZetaSuite, A Computational Method for Analyzing Multi-dimensional High-throughput Data, Reveals Genes with Opposite Roles in Cancer Dependency. Forthcoming*\n\n**in-house dataset** : *Changwei Shao, Yajing Hao, Jinsong Qiu, Bing Zhou, Hairi Li, Yu Zhou, Fan Meng, Li Jiang, Lan-Tao Gou, Jun Xu, Yuanjun Li,Hui Wang, Gene W. Yeo, Dong Wang, Xiong Ji, Christopher K. Glass, Pedro Aza-Blanc, Xiang-Dong Fu (2021). HTS2 Screen for Global Splicing Regulators Reveals a Key Role of the Pol II Subunit RPB9 in Coupling between Transcription and Pre-mRNA Splicing. Cell.  Forthcoming.* \n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/YajingHao/ZetaSuite"
      },
      "technique": "GitHub_API"
    }
  ],
  "contributing_guidelines": [
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "# Contributing\n\nIf you\u2019re looking for ways to contribute, please [peruse open issues](https://github.com/mbostock/d3/issues?milestone=&page=1&state=open). The icebox is a good place to find ideas that are not currently in development. If you already have an idea, please check past issues to see whether your idea or a similar one was previously discussed.\n\nBefore submitting a pull request, consider implementing a live example first, say using [bl.ocks.org](http://bl.ocks.org). Real-world use cases go a long way to demonstrating the usefulness of a proposed feature. The more complex a feature\u2019s implementation, the more usefulness it should provide. Share your demo using the #d3js tag on Twitter or by sending it to the d3-js Google group.\n\nIf your proposed feature does not involve changing core functionality, consider submitting it instead as a [D3 plugin](https://github.com/d3/d3-plugins). New core features should be for general use, whereas plugins are suitable for more specialized use cases. When in doubt, it\u2019s easier to start with a plugin before \u201cgraduating\u201d to core.\n\nTo contribute new documentation or add examples to the gallery, just [edit the Wiki](https://github.com/mbostock/d3/wiki)!\n\n## How to Submit a Pull Request\n\n1. Click the \u201cFork\u201d button to create your personal fork of the D3 repository.\n\n2. After cloning your fork of the D3 repository in the terminal, run `npm install` to install D3\u2019s dependencies.\n\n3. Create a new branch for your new feature. For example: `git checkout -b my-awesome-feature`. A dedicated branch for your pull request means you can develop multiple features at the same time, and ensures that your pull request is stable even if you later decide to develop an unrelated feature.\n\n4. The `d3.js` and `d3.min.js` files are built from source files in the `src` directory. _Do not edit `d3.js` directly._ Instead, edit the source files, and then run `make` to build the generated files.\n\n5. Use `make test` to run tests and verify your changes. If you are adding a new feature, you should add new tests! If you are changing existing functionality, make sure the existing tests run, or update them as appropriate.\n\n6. Sign D3\u2019s [Individual Contributor License Agreement](https://docs.google.com/forms/d/1CzjdBKtDuA8WeuFJinadx956xLQ4Xriv7-oDvXnZMaI/viewform). Unless you are submitting a trivial patch (such as fixing a typo), this form is needed to verify that you are able to contribute.\n\n7. Submit your pull request, and good luck!\n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/tmp_files/d3-3.5.3/CONTRIBUTING.md",
      "technique": "file_exploration"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2020-05-25T23:27:15Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-03-21T07:09:12Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "Zeta score method to analysis multiple targets multiple hits screening"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 0.9160678006810862,
      "result": {
        "original_header": "The input of ZetaSuite can be three types:",
        "type": "Text_excerpt",
        "value": "      \n      - Raw read count matrix, in the example data: rows are the genes with targeting siRNAs, and columns are the AS events as readouts.\n      - Preprocess matrix, which means the low-quality rows and columns were already filtered by users.\n      - Normalized matrix, which means the value in the matrix can directly compare and do the accumulation.\n         \n    `sh Preprocess.sh -a <Input_dir> -b <output_dir> -i <Input_File> -o <Output_Name>`\n    \n    `Preprocess.sh` includes the following two steps: \n    \n     1. Filtering low quailty samples(rows) and low quality readouts(columns).\n     \n     2. Using KNN to estimate the value of missing data points in the input matrix. \n### Following steps were decided by the users, see example for detail.\n  1. Based on the screen strength curve, users can define their optimal threshold by considering both SS and balance points.\n  2. Based on the threshold to select hits.\n  3. Removing Off-targeting hits based on the regulation similarity and siRNA targeting.\n  4. Function interpretation of selected hits based on [ClusterProfiler](https://github.com/YuLab-SMU/clusterProfiler) and [CORUM complexes database](https://github.com/YuLab-SMU/clusterProfiler).The top 15 GO terms with lowest adjust p-values were presented and the top 15 complexes with highest hits\u2019 number were gave.If the complexes number were lower than 15, the complexes with hits\u2019 number larger than 3 would be outputted.\n  5. Constructing Network files for users' selected hits. Then directly used as input to [Gephi](https://gephi.org/) for visulization.\n \n ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n ## Testing ZetaSuite using one example (Large-scale RNAi screening)\nWe provided example data (our in-house HTS2 screening dataset) for using ZetaSuite to explore the hits and do futher functional interpretation. To save the testing time, we provided a subsampled dataset. While this test data may not yield reasonable results, it can be used to see how the workflow is configured and executed. \n#### step 1. we started with the preprecessed data set which was already removed the low qulity rows and columns.\nUsers can find the example data set in the [example](https://github.com/YajingHao/ZetaSuite/tree/master/example) directory.\nThe example input files include:\n   \n   1. input matrix file, [Example_matrix.txt](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_matrix.txt), Each row represents gene with specific knocking-down siRNA pool, each column is an AS event. The values in the matrix are the processed foldchange values between included exons and skipping exons read counts. \n   \n      (we randomly pick-up 2000 genes and 200 AS events as example matrix)\n   \n      <img width=\"390\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118161936-06e4dc80-b3d5-11eb-880b-259f46b00543.png\"> \nThe most time cosuming step is SVM in our pipeline. If you just want to test the pipeline, you can choose `-svm no`.\n  \n  `cd /output_example`\n  \n   1. QC figures : `cd QC`\n   \n   Example_tSNE_QC.pdf is the global evaluation based on all the readouts. This figure can evaluate whether the positive and negative samples are well separted based on current all readouts.\n   \n   The following 3 figures is the quality evaluation of the individual readouts.\n   \n![QC-01](https://user-images.githubusercontent.com/65927843/118415924-ef6e5380-b661-11eb-9a97-7354fca27158.png) \n   2. Normalized matrix:  `cd Zscore` **Example_Zscore.matrix** is the normalized matrix, each row represents each knocking-down condition and each column is a specific readout (AS event). The values in the matrix are the normalized values.\n   \n   3. EventCoverage figures for positive and negative samples: `cd EventCoverage`\n     \n   ![EC_figures-01](https://user-images.githubusercontent.com/65927843/118417118-8689da00-b667-11eb-86eb-8a3813385110.png) \n   \n   4. ZetaScore file: `cd Zeta` Example_Zeta.txt is the zeta values for all tested knockding-down genes including positive and negative controls. The first column is the direction which knockding-down gene will lead to exon inclusion, whereas the second column is the knock-down genes will lead to exon skipping.\n   \n   5. ZetaScore figure: `cd FDR_cutoff` Example_Zeta_type.pdf\n   <img width=\"990\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118415093-3148cb00-b65d-11eb-8e1c-448aaf00a173.png\"> \n ## Testing ZetaSuite using one example (single-cell transcriptomics)\n \n In this part, we provide an example using the example datasets in our Manuscript Figure7andS7.\n \n ###step1. Obtain the cell x gene matrix. If the output files is 10x, you can directly obtain the matrix from their output files.\n ```\n    library(seurat)\n    sce<-CreateSeuratObject(counts = Read10X(file_path), project = \"fileName\" )\n    matrix<-t(as.data.frame(sce[[\"RNA\"]]@counts)) \n    write.table(matrixfilter,\"Placenta_input.matrix\",sep=\"\\t\",row.names=T,col.names=T)\n ```\n \n ###step2. Using ZetaSuite to filter the empty or broken cells. Note, we recommend to remove the mitochondria genes. \n BASH9* \n###step4. The output file from step3 can be used as input for futher single-cell RNA-seq analysis. Following steps shows that how to used seurat for further analysis.\n```\n    stringsAsFactors = FALSE\n    set.seed(12345)\n    TableA <-read.table(\"Placenta_rmMT_filter.matrix\",sep=\"\\t\", header=T,row.names=1)\n    TableA<-t(TableA)\n    simple.merge.obj <- CreateSeuratObject(counts = TableA, project = \"placenta\")\n    #Log normalization\n    simple.merge.obj <- NormalizeData(simple.merge.obj)\n    #Find variable features\n    simple.merge.obj <- FindVariableFeatures(simple.merge.obj, nfeatures = 2000)\n    all.genes <- rownames(simple.merge.obj)\n    #scaling\n    simple.merge.obj <- ScaleData(simple.merge.obj, features = all.genes)\n    #run PCA analysis\n    simple.merge.obj <- RunPCA(simple.merge.obj)\n    simple.merge.obj <- FindNeighbors(simple.merge.obj, dims = 1:40)\n    #do cluster\n    simple.merge.obj <- FindClusters(simple.merge.obj, resolution = 0.5)\n    #run UMAP\n    simple.merge.obj <- RunUMAP(simple.merge.obj, dims = 1:40)\n\n```\n# Guide of generating non-expressors \nUsers could retrieve the non-expressors from many known databases, such as GEPIA(http://gepia.cancer-pku.cn/), Expression Atlas (https://www.ebi.ac.uk/gxa/home), Gene Expression Barcode database (http://barcode.luhs.org), etc. Moreover, we also provided non-expressor profiles in 38 cancer tissues (from TCGA), 54 normal tissues (from GTEx) as well as 1393 popular cancer/matched normal cell lines (from CCLE) in our website (https://github.com/YajingHao/ZetaSuite/tree/master/Non-expressors_profile). As for some new/rare cell types, users can either search the GEO database or directly generate RNA-seq data and then use classical RNA-seq processing pipelines provided in Homer(http://homer.ucsd.edu/homer/ngs/rnaseq/index.html) to generate the list of non-expressed genes. \n**software** : *Yajing Hao, Changwei Shao, Guofeng Zhao, Xiang-Dong Fu (2021). ZetaSuite, A Computational Method for Analyzing Multi-dimensional High-throughput Data, Reveals Genes with Opposite Roles in Cancer Dependency. Forthcoming* \n**in-house dataset** : *Changwei Shao, Yajing Hao, Jinsong Qiu, Bing Zhou, Hairi Li, Yu Zhou, Fan Meng, Li Jiang, Lan-Tao Gou, Jun Xu, Yuanjun Li,Hui Wang, Gene W. Yeo, Dong Wang, Xiong Ji, Christopher K. Glass, Pedro Aza-Blanc, Xiang-Dong Fu (2021). HTS2 Screen for Global Splicing Regulators Reveals a Key Role of the Pol II Subunit RPB9 in Coupling between Transcription and Pre-mRNA Splicing. Cell.  Forthcoming.* \n \n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download": [
    {
      "confidence": 1,
      "result": {
        "original_header": "5) GeneID transfer files: Transfer transcript name to GeneID. You can construct the file directly from the gtf files downloaded from <a href=\"https://www.gencodegenes.org/human/\">Gencode database</a>.",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail.",
          "step 4. remove off-targeting genes"
        ],
        "type": "Text_excerpt",
        "value": "  \n  You can find this file in **example** folder: *geneID_transcriptID_geneName_V28*\n   \n   ```\n   awk 'BEGIN{FS=OFS=\"\\t\"}{if($3==\"transcript\"){print $9}}' gencode.v28.annotation.gtf |sed 's/; /\\t/g'|sed 's/ \"/\\t/g'|cut -f 2,4,8|sed 's/\"//g' > geneID_transcriptID_geneName_V28\n   \n   ```\n  \n ##### 6) Normalized matrix from **step2**\n   \n   ` cd output_example/Zscore`\n   \n   file name is : *Example_Zscore.matrix*\n   \n   Run the following code to remove candidate off-targeting genes:\n   \n   ```\n   cd bin\n   sh OffTargeting.sh -b ../output_example/Hits -i ../output_example/Hits/Example_hits.txt -o OffT -m ../output_example/Zscore/Example_Zscore.matrix -t ../example/Example_siRNA.fa -l ../example/gencode.v28.annotation.bed -g ../example/Example_GlodenSet.txt -c ../example/geneID_transcriptID_geneName_V28\n   ```\n   The output files is in **../output_example/Hits** folder: *OffT_output.txt* ; the hits appear in this file were candidate off-targeting genes. In our example dataset, there were no candidate off-targeting hits.\n   "
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/YajingHao/ZetaSuite/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 2
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/YajingHao/ZetaSuite/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "YajingHao/ZetaSuite"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "has_script_file": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/Zeta_SVM.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/Function.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/Network.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/FindSVMcurve.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/command.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/SVM.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/chosingEdgeCutOff.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/FDR_cutoff.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/ZetaSuite_SC.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/EventCoverage_combine.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/PreProcess.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/Zeta.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/Zscore.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/OffTargeting.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/EventCoverage.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/FDR_cutoff_combine.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/ZetaSuit.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/FDR_cutoff_combine_V1.sh"
      },
      "technique": "file_exploration"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/QC.sh"
      },
      "technique": "file_exploration"
    }
  ],
  "images": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://user-images.githubusercontent.com/65927843/118019732-2b29b600-b30e-11eb-9ca0-5911dd82b608.jpg"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://user-images.githubusercontent.com/65927843/118020609-1ef22880-b30f-11eb-8e59-843c3eb4fe31.jpg"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://user-images.githubusercontent.com/65927843/118161936-06e4dc80-b3d5-11eb-880b-259f46b00543.png"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://user-images.githubusercontent.com/65927843/118415924-ef6e5380-b661-11eb-9a97-7354fca27158.png"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://user-images.githubusercontent.com/65927843/118417118-8689da00-b667-11eb-86eb-8a3813385110.png"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://user-images.githubusercontent.com/65927843/118415093-3148cb00-b65d-11eb-8e1c-448aaf00a173.png"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://user-images.githubusercontent.com/65927843/118530970-23955300-b6fa-11eb-9bfa-144149df4946.png"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://user-images.githubusercontent.com/65927843/118561319-abda1f00-b71f-11eb-9df4-53882e9ac9d2.png"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://user-images.githubusercontent.com/65927843/118563054-bb0e9c00-b722-11eb-9f33-d8299e5d2abc.png"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Installation",
        "type": "Text_excerpt",
        "value": "Since ZetaSuite is written in `Shell`, `R` and `Perl`, `R` and `Perl` are needed. \n\nOther R packages dependencies are:\n    \n    \n     library(foreach)\n     library(ggplot2)\n     library(parallel)\n     library(RColorBrewer)\n     library(reshape2)\n     library(DMwR)\n     library(scater)\n     library(e1071)\n     library(Rtsne)\n     library(clusterProfiler)\n     library(org.Hs.eg.db)\n     library(enrichplot)\n     library(DOSE)\n     library(bubbles)\n     library(colorRamps)\n     library(webshot)\n     library(htmlwidgets)\n     library(SC3)\n     library(SingleCellExperiment)\n     library(NbClust)\n     library(mixtools)\n     \nYou can just run the code below to install all the dependent R packages at once:\n\n`install.packages(c(\"foreach\", \"ggplot2\",\"parallel\",\"RColorBrewer\", \"reshape2\",\"DMwR\",\"e1071\", \"Rtsne\",\"clusterProfiler\",\"org.Hs.eg.db\",\"enrichplot\",\"DOSE\",\"bubbles\",\"colorRamps\",\"webshot\",\"htmlwidgets\",\"SC3\",\"SingleCellExperiment\",\"NbClust\",\"mixtools\"))`\n\nOther softwares dependencies are:\n\n- `Bedtools`(https://bioweb.pasteur.fr/docs/modules/bedtools/2.17.0/index.html)\n- `blast`(https://blast.ncbi.nlm.nih.gov/Blast.cgi)\n\n      \nThe installation procedure is extremely easy. \n1. clone the source code from git-hub.\n   \n   `git clone https://github.com/YajingHao/ZetaSuite.git`\n2. go into the directory in the command line. \n   \n   ```\n   cd ZetaSuite/bin\n   chmod 777 ./*\n   ```\n   \n3. go to website to download the annotation dataset\n   \n   `wget -c http://fugenome.ucsd.edu/HumanGenome/hg38_chr.fa `\n   \n   `mv ./hg38_chr.fa ./dataSets`\n   \n4. test the example data.\n\n   Go to ZetaSuite directory,and run the example.\n   \n   ```\n   cd ..\n   chmod 777 ZetaSuite.pl\n   perl ZetaSuite.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -p Example_postive_wells.list -n Example_negative_wells.list -ne Example_NonExp_wells.list -z yes -c yes -svm no\n   \n   ```\n   \n   If you want use ZetaSuite to deal with single cell RNA-seq, run the example code below:\n   ```\n   cd example\n   tar zxvf Example.matrix.tar.gz\n   cd ..\n   perl ZetaSuite_SC.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -n 10\n   ```\n    \nAnd it is done :v:!\n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "step 1. we started with the preprecessed data set which was already removed the low qulity rows and columns.",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail."
        ],
        "type": "Text_excerpt",
        "value": "Users can find the example data set in the [example](https://github.com/YajingHao/ZetaSuite/tree/master/example) directory.\nThe example input files include:\n   \n   1. input matrix file, [Example_matrix.txt](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_matrix.txt), Each row represents gene with specific knocking-down siRNA pool, each column is an AS event. The values in the matrix are the processed foldchange values between included exons and skipping exons read counts. \n   \n      (we randomly pick-up 2000 genes and 200 AS events as example matrix)\n   \n      <img width=\"390\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118161936-06e4dc80-b3d5-11eb-880b-259f46b00543.png\">\n\n   2. input negative file, the wells treated with non-specific siRNAs, [Example_negative_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_negative_wells.list). If users didn't have the build-in negative controls, the non-expressed genes should be provided here.\n   3. input positive file, the wells treated with siRNAs targeting to PTB, [Example_positive_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_postive_wells.list). If users didn't have the build-in positive controls, choose the parameters `-withoutsvm` and the filename can use any name such as 'NA'.\n   4. input internal negative control (non-expressed genes), genes which annotated as non-expressed (RPKM<1) in HeLa cells, [Example_NonExp_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_NonExp_wells.list).\n  "
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "2) Gloden gene sets",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail.",
          "step 4. remove off-targeting genes"
        ],
        "type": "Text_excerpt",
        "value": "   \n   You can find this file in **example** folder: [Example_GlodenSet.txt](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_GlodenSet.txt). This is constructed based on the priori knowledge.\n   \n   In the example data, we used the annotated spliceosome genes as golden sets.\n   "
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Guide of generating non-expressors",
        "type": "Text_excerpt",
        "value": "Users could retrieve the non-expressors from many known databases, such as GEPIA(http://gepia.cancer-pku.cn/), Expression Atlas (https://www.ebi.ac.uk/gxa/home), Gene Expression Barcode database (http://barcode.luhs.org), etc. Moreover, we also provided non-expressor profiles in 38 cancer tissues (from TCGA), 54 normal tissues (from GTEx) as well as 1393 popular cancer/matched normal cell lines (from CCLE) in our website (https://github.com/YajingHao/ZetaSuite/tree/master/Non-expressors_profile). As for some new/rare cell types, users can either search the GEO database or directly generate RNA-seq data and then use classical RNA-seq processing pipelines provided in Homer(http://homer.ucsd.edu/homer/ngs/rnaseq/index.html) to generate the list of non-expressed genes.\n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.899081136718468,
      "result": {
        "original_header": "Table of contents",
        "type": "Text_excerpt",
        "value": "- Installation\n- The overall workflow of ZetaSuite\n- Testing ZetaSuite using one example\n- Guide of generating non-expressors\n- Citations \n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9965874898603312,
      "result": {
        "original_header": "The input of ZetaSuite can be three types:",
        "type": "Text_excerpt",
        "value": "    `perl ZetaSuite.pl -id <input_dir> -od <output_dir> -in <input_matrix> -op <output_prefix> -p <positive.list> -n <negative.list> -ne <internatal_negative.list>`\n    \n    You can check the parameters for `ZetaSuite.pl` by simply type\n    \n    `perl ZetaSuite.pl -h`\n    \n    ```\n    Usage:    \n    -id  <STR>      input directory [require]\n    -od  <STR>      output directory [require]\n    -in  <STR>      input file name [require]\n    -op  <STR>      output file prefix [require]\n    -p   <STR>      positive control file [require]\n    -n   <STR>      negative control file [require]\n    -ne  <STR>      internal negative control file (non-expressed genes) [require]\n    -z   <STR>      zscore normalization(yes or no) [default yes]\n    -c   <STR>      combine two direction zeta together(yes or no) [default no] \n    -svm <STR>      svm calculation (yes or no) [dafault yes]\n    -h   <STR>      documents help\n    \n    ``` \n    `ZetaSuite.pl` includes the following steps:\n   \n    1). QC evaluation of the input matrix `<input_matrix>`. We just evaluate the QC but will not do any filterations.\n  \n    2). Calculating the Z-score to make the readouts are comparable.(option command `-z` yes or no,default: yes)\n    \n    3). Calculating the Event Coverage for each gene(row). \n    \n    4). Using the SVM curve to filter the genes which show similar responce with negative controls.(option command `-svm` yes or no , default: yes)\n    \n    5). Whether users need to directly compare the Zeta score in two directions and use the combined Zeta score to do hits' selection? (option command `-c` yes or no, default: no)\n    \n    6). Calculating the Zeta score.\n    \n    7). Drawing screen strength curve based on the internal negative control `<internatal_negative.list>`.\n \n  \n* #### If the input is already normalized matrix, you can directly run `ZetaSuite.pl` with parameter `-z no`.  \n   2. input negative file, the wells treated with non-specific siRNAs, [Example_negative_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_negative_wells.list). If users didn't have the build-in negative controls, the non-expressed genes should be provided here.\n   3. input positive file, the wells treated with siRNAs targeting to PTB, [Example_positive_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_postive_wells.list). If users didn't have the build-in positive controls, choose the parameters `-withoutsvm` and the filename can use any name such as 'NA'.\n   4. input internal negative control (non-expressed genes), genes which annotated as non-expressed (RPKM<1) in HeLa cells, [Example_NonExp_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_NonExp_wells.list).\n  \n#### step 2. run [ZetaSuite](https://github.com/YajingHao/ZetaSuite) main pipeline\n   \n  ```\n  perl ZetaSuite.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -p Example_postive_wells.list -n Example_negative_wells.list -ne Example_NonExp_wells.list -z yes -c yes -svm yes\n  ```\n     \nAfter finished processing, we will obtain the following files and figures in the corresponding directory: \n\n   6. ScreenStrength curve: `cd FDR_cutoff` Example_SS_cutOff.pdf\n  <img width=\"800\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118530970-23955300-b6fa-11eb-9bfa-144149df4946.png\"> \nUsers could retrieve the non-expressors from many known databases, such as GEPIA(http://gepia.cancer-pku.cn/), Expression Atlas (https://www.ebi.ac.uk/gxa/home), Gene Expression Barcode database (http://barcode.luhs.org), etc. Moreover, we also provided non-expressor profiles in 38 cancer tissues (from TCGA), 54 normal tissues (from GTEx) as well as 1393 popular cancer/matched normal cell lines (from CCLE) in our website (https://github.com/YajingHao/ZetaSuite/tree/master/Non-expressors_profile). As for some new/rare cell types, users can either search the GEO database or directly generate RNA-seq data and then use classical RNA-seq processing pipelines provided in Homer(http://homer.ucsd.edu/homer/ngs/rnaseq/index.html) to generate the list of non-expressed genes. \n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/YajingHao/ZetaSuite/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "type": "File_dump",
        "value": "Copyright (c) 2010-2014, Michael Bostock\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* The name Michael Bostock may not be used to endorse or promote products\n  derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\nOF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/bin/tmp_files/d3-3.5.3/LICENSE",
      "technique": "file_exploration"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "ZetaSuite"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "User",
        "value": "YajingHao"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "JavaScript",
        "size": 77519,
        "type": "Programming_language",
        "value": "JavaScript"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Shell",
        "size": 41644,
        "type": "Programming_language",
        "value": "Shell"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "R",
        "size": 23285,
        "type": "Programming_language",
        "value": "R"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Perl",
        "size": 13764,
        "type": "Programming_language",
        "value": "Perl"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "HTML",
        "size": 1635,
        "type": "Programming_language",
        "value": "HTML"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "CSS",
        "size": 369,
        "type": "Programming_language",
        "value": "CSS"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "run": [
    {
      "confidence": 1,
      "result": {
        "original_header": "If the input is the raw read count matrix without any processing, please run the `Preprocess.sh` first.",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "The input of ZetaSuite can be three types:"
        ],
        "type": "Text_excerpt",
        "value": "## ZetaSuite : A Computational Method for Analyzing High-dimensional High-throughput Data\n\n![Figure1-01](https://user-images.githubusercontent.com/65927843/118019732-2b29b600-b30e-11eb-9ca0-5911dd82b608.jpg)\nIf you have any questions, please contact Yajing Hao <yahao@health.ucsd.edu> in [Fu Lab](http://fugenome.ucsd.edu/).\n\n## Table of contents\n- Installation\n- The overall workflow of ZetaSuite\n- Testing ZetaSuite using one example\n- Guide of generating non-expressors\n- Citations\n## Installation\nSince ZetaSuite is written in `Shell`, `R` and `Perl`, `R` and `Perl` are needed. \n\nOther R packages dependencies are:\n    \n    \n     library(foreach)\n     library(ggplot2)\n     library(parallel)\n     library(RColorBrewer)\n     library(reshape2)\n     library(DMwR)\n     library(scater)\n     library(e1071)\n     library(Rtsne)\n     library(clusterProfiler)\n     library(org.Hs.eg.db)\n     library(enrichplot)\n     library(DOSE)\n     library(bubbles)\n     library(colorRamps)\n     library(webshot)\n     library(htmlwidgets)\n     library(SC3)\n     library(SingleCellExperiment)\n     library(NbClust)\n     library(mixtools)\n     \nYou can just run the code below to install all the dependent R packages at once:\n\n`install.packages(c(\"foreach\", \"ggplot2\",\"parallel\",\"RColorBrewer\", \"reshape2\",\"DMwR\",\"e1071\", \"Rtsne\",\"clusterProfiler\",\"org.Hs.eg.db\",\"enrichplot\",\"DOSE\",\"bubbles\",\"colorRamps\",\"webshot\",\"htmlwidgets\",\"SC3\",\"SingleCellExperiment\",\"NbClust\",\"mixtools\"))`\n\nOther softwares dependencies are:\n\n- `Bedtools`(https://bioweb.pasteur.fr/docs/modules/bedtools/2.17.0/index.html)\n- `blast`(https://blast.ncbi.nlm.nih.gov/Blast.cgi)\n\n      \nThe installation procedure is extremely easy. \n1. clone the source code from git-hub.\n   \n   `git clone https://github.com/YajingHao/ZetaSuite.git`\n2. go into the directory in the command line. \n   \n   ```\n   cd ZetaSuite/bin\n   chmod 777 ./*\n   ```\n   \n3. go to website to download the annotation dataset\n   \n   `wget -c http://fugenome.ucsd.edu/HumanGenome/hg38_chr.fa `\n   \n   `mv ./hg38_chr.fa ./dataSets`\n   \n4. test the example data.\n\n   Go to ZetaSuite directory,and run the example.\n   \n   ```\n   cd ..\n   chmod 777 ZetaSuite.pl\n   perl ZetaSuite.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -p Example_postive_wells.list -n Example_negative_wells.list -ne Example_NonExp_wells.list -z yes -c yes -svm no\n   \n   ```\n   \n   If you want use ZetaSuite to deal with single cell RNA-seq, run the example code below:\n   ```\n   cd example\n   tar zxvf Example.matrix.tar.gz\n   cd ..\n   perl ZetaSuite_SC.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -n 10\n   ```\n    \nAnd it is done :v:!\n\n## The overall workflow of ZetaSuite.\n![workflow-01](https://user-images.githubusercontent.com/65927843/118020609-1ef22880-b30f-11eb-8e59-843c3eb4fe31.jpg)\n\n\n### The input of ZetaSuite can be three types:\n      \n      - Raw read count matrix, in the example data: rows are the genes with targeting siRNAs, and columns are the AS events as readouts.\n      - Preprocess matrix, which means the low-quality rows and columns were already filtered by users.\n      - Normalized matrix, which means the value in the matrix can directly compare and do the accumulation.\n        \n\n* #### If the input is the raw read count matrix without any processing, please run the `Preprocess.sh` first.\n\n    `sh Preprocess.sh -a <Input_dir> -b <output_dir> -i <Input_File> -o <Output_Name>`\n    \n    `Preprocess.sh` includes the following two steps: \n    \n     1. Filtering low quailty samples(rows) and low quality readouts(columns).\n     \n     2. Using KNN to estimate the value of missing data points in the input matrix.\n\n* #### If the input is the already precessed matrix, you can directly run `ZetaSuite.pl`.\n\n    `perl ZetaSuite.pl -id <input_dir> -od <output_dir> -in <input_matrix> -op <output_prefix> -p <positive.list> -n <negative.list> -ne <internatal_negative.list>`\n    \n    You can check the parameters for `ZetaSuite.pl` by simply type\n    \n    `perl ZetaSuite.pl -h`\n    \n    ```\n    Usage:    \n    -id  <STR>      input directory [require]\n    -od  <STR>      output directory [require]\n    -in  <STR>      input file name [require]\n    -op  <STR>      output file prefix [require]\n    -p   <STR>      positive control file [require]\n    -n   <STR>      negative control file [require]\n    -ne  <STR>      internal negative control file (non-expressed genes) [require]\n    -z   <STR>      zscore normalization(yes or no) [default yes]\n    -c   <STR>      combine two direction zeta together(yes or no) [default no] \n    -svm <STR>      svm calculation (yes or no) [dafault yes]\n    -h   <STR>      documents help\n    \n    ```\n\n    `ZetaSuite.pl` includes the following steps:\n   \n    1). QC evaluation of the input matrix `<input_matrix>`. We just evaluate the QC but will not do any filterations.\n  \n    2). Calculating the Z-score to make the readouts are comparable.(option command `-z` yes or no,default: yes)\n    \n    3). Calculating the Event Coverage for each gene(row). \n    \n    4). Using the SVM curve to filter the genes which show similar responce with negative controls.(option command `-svm` yes or no , default: yes)\n    \n    5). Whether users need to directly compare the Zeta score in two directions and use the combined Zeta score to do hits' selection? (option command `-c` yes or no, default: no)\n    \n    6). Calculating the Zeta score.\n    \n    7). Drawing screen strength curve based on the internal negative control `<internatal_negative.list>`.\n \n  \n* #### If the input is already normalized matrix, you can directly run `ZetaSuite.pl` with parameter `-z no`. \n\n### Following steps were decided by the users, see example for detail.\n  1. Based on the screen strength curve, users can define their optimal threshold by considering both SS and balance points.\n  2. Based on the threshold to select hits.\n  3. Removing Off-targeting hits based on the regulation similarity and siRNA targeting.\n  4. Function interpretation of selected hits based on [ClusterProfiler](https://github.com/YuLab-SMU/clusterProfiler) and [CORUM complexes database](https://github.com/YuLab-SMU/clusterProfiler).The top 15 GO terms with lowest adjust p-values were presented and the top 15 complexes with highest hits\u2019 number were gave.If the complexes number were lower than 15, the complexes with hits\u2019 number larger than 3 would be outputted.\n  5. Constructing Network files for users' selected hits. Then directly used as input to [Gephi](https://gephi.org/) for visulization.\n \n ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n ## Testing ZetaSuite using one example (Large-scale RNAi screening)\nWe provided example data (our in-house HTS2 screening dataset) for using ZetaSuite to explore the hits and do futher functional interpretation. To save the testing time, we provided a subsampled dataset. While this test data may not yield reasonable results, it can be used to see how the workflow is configured and executed.\n\n#### step 1. we started with the preprecessed data set which was already removed the low qulity rows and columns.\nUsers can find the example data set in the [example](https://github.com/YajingHao/ZetaSuite/tree/master/example) directory.\nThe example input files include:\n   \n   1. input matrix file, [Example_matrix.txt](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_matrix.txt), Each row represents gene with specific knocking-down siRNA pool, each column is an AS event. The values in the matrix are the processed foldchange values between included exons and skipping exons read counts. \n   \n      (we randomly pick-up 2000 genes and 200 AS events as example matrix)\n   \n      <img width=\"390\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118161936-06e4dc80-b3d5-11eb-880b-259f46b00543.png\">\n\n   2. input negative file, the wells treated with non-specific siRNAs, [Example_negative_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_negative_wells.list). If users didn't have the build-in negative controls, the non-expressed genes should be provided here.\n   3. input positive file, the wells treated with siRNAs targeting to PTB, [Example_positive_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_postive_wells.list). If users didn't have the build-in positive controls, choose the parameters `-withoutsvm` and the filename can use any name such as 'NA'.\n   4. input internal negative control (non-expressed genes), genes which annotated as non-expressed (RPKM<1) in HeLa cells, [Example_NonExp_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_NonExp_wells.list).\n  \n#### step 2. run [ZetaSuite](https://github.com/YajingHao/ZetaSuite) main pipeline\n   \n  ```\n  perl ZetaSuite.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -p Example_postive_wells.list -n Example_negative_wells.list -ne Example_NonExp_wells.list -z yes -c yes -svm yes\n  ```\n     \nAfter finished processing, we will obtain the following files and figures in the corresponding directory:\n\nThe most time cosuming step is SVM in our pipeline. If you just want to test the pipeline, you can choose `-svm no`.\n  \n  `cd /output_example`\n  \n   1. QC figures : `cd QC`\n   \n   Example_tSNE_QC.pdf is the global evaluation based on all the readouts. This figure can evaluate whether the positive and negative samples are well separted based on current all readouts.\n   \n   The following 3 figures is the quality evaluation of the individual readouts.\n   \n![QC-01](https://user-images.githubusercontent.com/65927843/118415924-ef6e5380-b661-11eb-9a97-7354fca27158.png)\n\n\n\n   2. Normalized matrix:  `cd Zscore` **Example_Zscore.matrix** is the normalized matrix, each row represents each knocking-down condition and each column is a specific readout (AS event). The values in the matrix are the normalized values.\n   \n   3. EventCoverage figures for positive and negative samples: `cd EventCoverage`\n     \n   ![EC_figures-01](https://user-images.githubusercontent.com/65927843/118417118-8689da00-b667-11eb-86eb-8a3813385110.png)\n\n   \n   4. ZetaScore file: `cd Zeta` Example_Zeta.txt is the zeta values for all tested knockding-down genes including positive and negative controls. The first column is the direction which knockding-down gene will lead to exon inclusion, whereas the second column is the knock-down genes will lead to exon skipping.\n   \n   5. ZetaScore figure: `cd FDR_cutoff` Example_Zeta_type.pdf\n   <img width=\"990\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118415093-3148cb00-b65d-11eb-8e1c-448aaf00a173.png\">\n\n\n   6. ScreenStrength curve: `cd FDR_cutoff` Example_SS_cutOff.pdf\n  <img width=\"800\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118530970-23955300-b6fa-11eb-9bfa-144149df4946.png\">\n\n  \n#### step 3. selected the thresholds\n     \n   Users can check the Screenstrength curves (**Example_SS_cutOff.pdf**) and find the optimal threshold based on balance points and Screen strength.\n   \n   With our example data, we actually identified two BPs, thereby enabling us to define candidate hits after BP1 and high confidence hits after BP2, the latter of which maximally eliminate true false positives derived from non-expressors. To keep enough hits for further analysis, we selected the BP1 as threshold.\n   \n   Then obtain hits passed the threshold with the following command:\n   \n     ```\n      cd output_example\n      mkdir Hits\n      Cutoff=0.1211316\n      awk -v cutoff=${Cutoff} '{FS=OFS=\"\\t\"}{if(NR==1 || (($2+$3)>cutoff && $4==\"Gene\")){print}}' FDR_cutoff/Example_Zeta_anno.txt > Hits/Example_hits.txt\n      \n     ```\n#### step 4. remove off-targeting genes\n   \n   The input files for off-targeting removing are: \n   \n   \n##### 1) Targeting RNA sequences\n   \n   You can find this file in **example** folder: [Example_siRNA.fa](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_siRNA.fa).\n     \n##### 2) Gloden gene sets\n   \n   You can find this file in **example** folder: [Example_GlodenSet.txt](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_GlodenSet.txt). This is constructed based on the priori knowledge.\n   \n   In the example data, we used the annotated spliceosome genes as golden sets.\n   \n##### 3) Hits from **step3**\n     \n   file name is: *Example_hits.txt*\n   \n##### 4) Gene location files: [bed format](https://genome.ucsc.edu/FAQ/FAQformat.html#format1). The genome version should be human release 38(hg38).\n   \n   The default file is human gene locations downloaded from [Gencode database](https://www.gencodegenes.org/human/)(V28).\n   \n   You can find this file in **example** folder: *gencode.v28.annotation.bed.gz*\n   \n   Uncompress it.\n   \n   `unzip gencode.v28.annotation.bed.zip`\n   \n   \n##### 5) GeneID transfer files: Transfer transcript name to GeneID. You can construct the file directly from the gtf files downloaded from [Gencode database](https://www.gencodegenes.org/human/).\n  \n  You can find this file in **example** folder: *geneID_transcriptID_geneName_V28*\n   \n   ```\n   awk 'BEGIN{FS=OFS=\"\\t\"}{if($3==\"transcript\"){print $9}}' gencode.v28.annotation.gtf |sed 's/; /\\t/g'|sed 's/ \"/\\t/g'|cut -f 2,4,8|sed 's/\"//g' > geneID_transcriptID_geneName_V28\n   \n   ```\n  \n ##### 6) Normalized matrix from **step2**\n   \n   ` cd output_example/Zscore`\n   \n   file name is : *Example_Zscore.matrix*\n   \n   Run the following code to remove candidate off-targeting genes:\n   \n   ```\n   cd bin\n   sh OffTargeting.sh -b ../output_example/Hits -i ../output_example/Hits/Example_hits.txt -o OffT -m ../output_example/Zscore/Example_Zscore.matrix -t ../example/Example_siRNA.fa -l ../example/gencode.v28.annotation.bed -g ../example/Example_GlodenSet.txt -c ../example/geneID_transcriptID_geneName_V28\n   ```\n   The output files is in **../output_example/Hits** folder: *OffT_output.txt* ; the hits appear in this file were candidate off-targeting genes. In our example dataset, there were no candidate off-targeting hits.\n   \n#### step 5. functional interpretation of selected hits\n   The input file is hits file from **step3**\n    \n    ```\n    cd bin\n    sh Function.sh -a ../output_example/Hits -b ../output_example/Hits -i Example_hits.txt -o Example_Functions\n    \n    ``` \n   The output files are below:\n   \n   <img width=\"887\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118561319-abda1f00-b71f-11eb-9df4-53882e9ac9d2.png\">\n\n    \n#### step 6. constructe network files\n   The input files for Network construction are:\n   \n   1)Normalized matrix from **step2**\n    \n   2)Hits from **step3**\n    \n   3)consensus_score_cutoff: the threshold to choose edges in the network.\n   \n   ```\n     cd bin\n     sh Network.sh -b ../output_example/Hits -h ../output_example/Hits/Example_hits.txt -i ../output_example/Zscore/Example_Zscore.matrix -o Network -c 0.4\n   ```  \n The output files are below:\n      **Edge file**: *Network_Edges_filter.csv* and **Node file**: *Network_Network_node.csv*\n  \n Load these files to **Gephi** for visulization:\n \n ![Network](https://user-images.githubusercontent.com/65927843/118563054-bb0e9c00-b722-11eb-9f33-d8299e5d2abc.png)\n\n ## Testing ZetaSuite using one example (single-cell transcriptomics)\n \n In this part, we provide an example using the example datasets in our Manuscript Figure7andS7.\n \n ###step1. Obtain the cell x gene matrix. If the output files is 10x, you can directly obtain the matrix from their output files.\n ```\n    library(seurat)\n    sce<-CreateSeuratObject(counts = Read10X(file_path), project = \"fileName\" )\n    matrix<-t(as.data.frame(sce[[\"RNA\"]]@counts)) \n    write.table(matrixfilter,\"Placenta_input.matrix\",sep=\"\\t\",row.names=T,col.names=T)\n ```\n \n ###step2. Using ZetaSuite to filter the empty or broken cells. Note, we recommend to remove the mitochondria genes. \n ```\n    cut -f 1-27124,27138- ../example/Placenta_input.matrix > Placenta_rmMT.matrix\n    perl ZetaSuite_SC.pl -id ./  -od ./ -in Placenta_rmMT.matrix -op placenta\n ```\n\n###step3. Based on the output of ZetaSuite, we choose the cut-off (Zeta score = 1259) to filter cells.\n```\n   awk 'BEGIN{FS=OFS=\"\\t\"}NR==FNR{if($2>1259){A[$1]=\"yes\"}}NR>FNR{if(FNR==1 || A[$1]!=\"\"){print}}' placenta_Zeta  Placenta_rmMT.matrix > Placenta_rmMT_filter.matrix\n```\n\n###step4. The output file from step3 can be used as input for futher single-cell RNA-seq analysis. Following steps shows that how to used seurat for further analysis.\n```\n    stringsAsFactors = FALSE\n    set.seed(12345)\n    TableA <-read.table(\"Placenta_rmMT_filter.matrix\",sep=\"\\t\", header=T,row.names=1)\n    TableA<-t(TableA)\n    simple.merge.obj <- CreateSeuratObject(counts = TableA, project = \"placenta\")\n    #Log normalization\n    simple.merge.obj <- NormalizeData(simple.merge.obj)\n    #Find variable features\n    simple.merge.obj <- FindVariableFeatures(simple.merge.obj, nfeatures = 2000)\n    all.genes <- rownames(simple.merge.obj)\n    #scaling\n    simple.merge.obj <- ScaleData(simple.merge.obj, features = all.genes)\n    #run PCA analysis\n    simple.merge.obj <- RunPCA(simple.merge.obj)\n    simple.merge.obj <- FindNeighbors(simple.merge.obj, dims = 1:40)\n    #do cluster\n    simple.merge.obj <- FindClusters(simple.merge.obj, resolution = 0.5)\n    #run UMAP\n    simple.merge.obj <- RunUMAP(simple.merge.obj, dims = 1:40)\n\n```\n# Guide of generating non-expressors\n\nUsers could retrieve the non-expressors from many known databases, such as GEPIA(http://gepia.cancer-pku.cn/), Expression Atlas (https://www.ebi.ac.uk/gxa/home), Gene Expression Barcode database (http://barcode.luhs.org), etc. Moreover, we also provided non-expressor profiles in 38 cancer tissues (from TCGA), 54 normal tissues (from GTEx) as well as 1393 popular cancer/matched normal cell lines (from CCLE) in our website (https://github.com/YajingHao/ZetaSuite/tree/master/Non-expressors_profile). As for some new/rare cell types, users can either search the GEO database or directly generate RNA-seq data and then use classical RNA-seq processing pipelines provided in Homer(http://homer.ucsd.edu/homer/ngs/rnaseq/index.html) to generate the list of non-expressed genes.\n\n# Citations\n\n**software** : *Yajing Hao, Changwei Shao, Guofeng Zhao, Xiang-Dong Fu (2021). ZetaSuite, A Computational Method for Analyzing Multi-dimensional High-throughput Data, Reveals Genes with Opposite Roles in Cancer Dependency. Forthcoming*\n\n**in-house dataset** : *Changwei Shao, Yajing Hao, Jinsong Qiu, Bing Zhou, Hairi Li, Yu Zhou, Fan Meng, Li Jiang, Lan-Tao Gou, Jun Xu, Yuanjun Li,Hui Wang, Gene W. Yeo, Dong Wang, Xiong Ji, Christopher K. Glass, Pedro Aza-Blanc, Xiang-Dong Fu (2021). HTS2 Screen for Global Splicing Regulators Reveals a Key Role of the Pol II Subunit RPB9 in Coupling between Transcription and Pre-mRNA Splicing. Cell.  Forthcoming.* \n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "If the input is the already precessed matrix, you can directly run `ZetaSuite.pl`.",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "The input of ZetaSuite can be three types:"
        ],
        "type": "Text_excerpt",
        "value": "## ZetaSuite : A Computational Method for Analyzing High-dimensional High-throughput Data\n\n![Figure1-01](https://user-images.githubusercontent.com/65927843/118019732-2b29b600-b30e-11eb-9ca0-5911dd82b608.jpg)\nIf you have any questions, please contact Yajing Hao <yahao@health.ucsd.edu> in [Fu Lab](http://fugenome.ucsd.edu/).\n\n## Table of contents\n- Installation\n- The overall workflow of ZetaSuite\n- Testing ZetaSuite using one example\n- Guide of generating non-expressors\n- Citations\n## Installation\nSince ZetaSuite is written in `Shell`, `R` and `Perl`, `R` and `Perl` are needed. \n\nOther R packages dependencies are:\n    \n    \n     library(foreach)\n     library(ggplot2)\n     library(parallel)\n     library(RColorBrewer)\n     library(reshape2)\n     library(DMwR)\n     library(scater)\n     library(e1071)\n     library(Rtsne)\n     library(clusterProfiler)\n     library(org.Hs.eg.db)\n     library(enrichplot)\n     library(DOSE)\n     library(bubbles)\n     library(colorRamps)\n     library(webshot)\n     library(htmlwidgets)\n     library(SC3)\n     library(SingleCellExperiment)\n     library(NbClust)\n     library(mixtools)\n     \nYou can just run the code below to install all the dependent R packages at once:\n\n`install.packages(c(\"foreach\", \"ggplot2\",\"parallel\",\"RColorBrewer\", \"reshape2\",\"DMwR\",\"e1071\", \"Rtsne\",\"clusterProfiler\",\"org.Hs.eg.db\",\"enrichplot\",\"DOSE\",\"bubbles\",\"colorRamps\",\"webshot\",\"htmlwidgets\",\"SC3\",\"SingleCellExperiment\",\"NbClust\",\"mixtools\"))`\n\nOther softwares dependencies are:\n\n- `Bedtools`(https://bioweb.pasteur.fr/docs/modules/bedtools/2.17.0/index.html)\n- `blast`(https://blast.ncbi.nlm.nih.gov/Blast.cgi)\n\n      \nThe installation procedure is extremely easy. \n1. clone the source code from git-hub.\n   \n   `git clone https://github.com/YajingHao/ZetaSuite.git`\n2. go into the directory in the command line. \n   \n   ```\n   cd ZetaSuite/bin\n   chmod 777 ./*\n   ```\n   \n3. go to website to download the annotation dataset\n   \n   `wget -c http://fugenome.ucsd.edu/HumanGenome/hg38_chr.fa `\n   \n   `mv ./hg38_chr.fa ./dataSets`\n   \n4. test the example data.\n\n   Go to ZetaSuite directory,and run the example.\n   \n   ```\n   cd ..\n   chmod 777 ZetaSuite.pl\n   perl ZetaSuite.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -p Example_postive_wells.list -n Example_negative_wells.list -ne Example_NonExp_wells.list -z yes -c yes -svm no\n   \n   ```\n   \n   If you want use ZetaSuite to deal with single cell RNA-seq, run the example code below:\n   ```\n   cd example\n   tar zxvf Example.matrix.tar.gz\n   cd ..\n   perl ZetaSuite_SC.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -n 10\n   ```\n    \nAnd it is done :v:!\n\n## The overall workflow of ZetaSuite.\n![workflow-01](https://user-images.githubusercontent.com/65927843/118020609-1ef22880-b30f-11eb-8e59-843c3eb4fe31.jpg)\n\n\n### The input of ZetaSuite can be three types:\n      \n      - Raw read count matrix, in the example data: rows are the genes with targeting siRNAs, and columns are the AS events as readouts.\n      - Preprocess matrix, which means the low-quality rows and columns were already filtered by users.\n      - Normalized matrix, which means the value in the matrix can directly compare and do the accumulation.\n        \n\n* #### If the input is the raw read count matrix without any processing, please run the `Preprocess.sh` first.\n\n    `sh Preprocess.sh -a <Input_dir> -b <output_dir> -i <Input_File> -o <Output_Name>`\n    \n    `Preprocess.sh` includes the following two steps: \n    \n     1. Filtering low quailty samples(rows) and low quality readouts(columns).\n     \n     2. Using KNN to estimate the value of missing data points in the input matrix.\n\n* #### If the input is the already precessed matrix, you can directly run `ZetaSuite.pl`.\n\n    `perl ZetaSuite.pl -id <input_dir> -od <output_dir> -in <input_matrix> -op <output_prefix> -p <positive.list> -n <negative.list> -ne <internatal_negative.list>`\n    \n    You can check the parameters for `ZetaSuite.pl` by simply type\n    \n    `perl ZetaSuite.pl -h`\n    \n    ```\n    Usage:    \n    -id  <STR>      input directory [require]\n    -od  <STR>      output directory [require]\n    -in  <STR>      input file name [require]\n    -op  <STR>      output file prefix [require]\n    -p   <STR>      positive control file [require]\n    -n   <STR>      negative control file [require]\n    -ne  <STR>      internal negative control file (non-expressed genes) [require]\n    -z   <STR>      zscore normalization(yes or no) [default yes]\n    -c   <STR>      combine two direction zeta together(yes or no) [default no] \n    -svm <STR>      svm calculation (yes or no) [dafault yes]\n    -h   <STR>      documents help\n    \n    ```\n\n    `ZetaSuite.pl` includes the following steps:\n   \n    1). QC evaluation of the input matrix `<input_matrix>`. We just evaluate the QC but will not do any filterations.\n  \n    2). Calculating the Z-score to make the readouts are comparable.(option command `-z` yes or no,default: yes)\n    \n    3). Calculating the Event Coverage for each gene(row). \n    \n    4). Using the SVM curve to filter the genes which show similar responce with negative controls.(option command `-svm` yes or no , default: yes)\n    \n    5). Whether users need to directly compare the Zeta score in two directions and use the combined Zeta score to do hits' selection? (option command `-c` yes or no, default: no)\n    \n    6). Calculating the Zeta score.\n    \n    7). Drawing screen strength curve based on the internal negative control `<internatal_negative.list>`.\n \n  \n* #### If the input is already normalized matrix, you can directly run `ZetaSuite.pl` with parameter `-z no`. \n\n### Following steps were decided by the users, see example for detail.\n  1. Based on the screen strength curve, users can define their optimal threshold by considering both SS and balance points.\n  2. Based on the threshold to select hits.\n  3. Removing Off-targeting hits based on the regulation similarity and siRNA targeting.\n  4. Function interpretation of selected hits based on [ClusterProfiler](https://github.com/YuLab-SMU/clusterProfiler) and [CORUM complexes database](https://github.com/YuLab-SMU/clusterProfiler).The top 15 GO terms with lowest adjust p-values were presented and the top 15 complexes with highest hits\u2019 number were gave.If the complexes number were lower than 15, the complexes with hits\u2019 number larger than 3 would be outputted.\n  5. Constructing Network files for users' selected hits. Then directly used as input to [Gephi](https://gephi.org/) for visulization.\n \n ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n ## Testing ZetaSuite using one example (Large-scale RNAi screening)\nWe provided example data (our in-house HTS2 screening dataset) for using ZetaSuite to explore the hits and do futher functional interpretation. To save the testing time, we provided a subsampled dataset. While this test data may not yield reasonable results, it can be used to see how the workflow is configured and executed.\n\n#### step 1. we started with the preprecessed data set which was already removed the low qulity rows and columns.\nUsers can find the example data set in the [example](https://github.com/YajingHao/ZetaSuite/tree/master/example) directory.\nThe example input files include:\n   \n   1. input matrix file, [Example_matrix.txt](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_matrix.txt), Each row represents gene with specific knocking-down siRNA pool, each column is an AS event. The values in the matrix are the processed foldchange values between included exons and skipping exons read counts. \n   \n      (we randomly pick-up 2000 genes and 200 AS events as example matrix)\n   \n      <img width=\"390\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118161936-06e4dc80-b3d5-11eb-880b-259f46b00543.png\">\n\n   2. input negative file, the wells treated with non-specific siRNAs, [Example_negative_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_negative_wells.list). If users didn't have the build-in negative controls, the non-expressed genes should be provided here.\n   3. input positive file, the wells treated with siRNAs targeting to PTB, [Example_positive_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_postive_wells.list). If users didn't have the build-in positive controls, choose the parameters `-withoutsvm` and the filename can use any name such as 'NA'.\n   4. input internal negative control (non-expressed genes), genes which annotated as non-expressed (RPKM<1) in HeLa cells, [Example_NonExp_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_NonExp_wells.list).\n  \n#### step 2. run [ZetaSuite](https://github.com/YajingHao/ZetaSuite) main pipeline\n   \n  ```\n  perl ZetaSuite.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -p Example_postive_wells.list -n Example_negative_wells.list -ne Example_NonExp_wells.list -z yes -c yes -svm yes\n  ```\n     \nAfter finished processing, we will obtain the following files and figures in the corresponding directory:\n\nThe most time cosuming step is SVM in our pipeline. If you just want to test the pipeline, you can choose `-svm no`.\n  \n  `cd /output_example`\n  \n   1. QC figures : `cd QC`\n   \n   Example_tSNE_QC.pdf is the global evaluation based on all the readouts. This figure can evaluate whether the positive and negative samples are well separted based on current all readouts.\n   \n   The following 3 figures is the quality evaluation of the individual readouts.\n   \n![QC-01](https://user-images.githubusercontent.com/65927843/118415924-ef6e5380-b661-11eb-9a97-7354fca27158.png)\n\n\n\n   2. Normalized matrix:  `cd Zscore` **Example_Zscore.matrix** is the normalized matrix, each row represents each knocking-down condition and each column is a specific readout (AS event). The values in the matrix are the normalized values.\n   \n   3. EventCoverage figures for positive and negative samples: `cd EventCoverage`\n     \n   ![EC_figures-01](https://user-images.githubusercontent.com/65927843/118417118-8689da00-b667-11eb-86eb-8a3813385110.png)\n\n   \n   4. ZetaScore file: `cd Zeta` Example_Zeta.txt is the zeta values for all tested knockding-down genes including positive and negative controls. The first column is the direction which knockding-down gene will lead to exon inclusion, whereas the second column is the knock-down genes will lead to exon skipping.\n   \n   5. ZetaScore figure: `cd FDR_cutoff` Example_Zeta_type.pdf\n   <img width=\"990\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118415093-3148cb00-b65d-11eb-8e1c-448aaf00a173.png\">\n\n\n   6. ScreenStrength curve: `cd FDR_cutoff` Example_SS_cutOff.pdf\n  <img width=\"800\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118530970-23955300-b6fa-11eb-9bfa-144149df4946.png\">\n\n  \n#### step 3. selected the thresholds\n     \n   Users can check the Screenstrength curves (**Example_SS_cutOff.pdf**) and find the optimal threshold based on balance points and Screen strength.\n   \n   With our example data, we actually identified two BPs, thereby enabling us to define candidate hits after BP1 and high confidence hits after BP2, the latter of which maximally eliminate true false positives derived from non-expressors. To keep enough hits for further analysis, we selected the BP1 as threshold.\n   \n   Then obtain hits passed the threshold with the following command:\n   \n     ```\n      cd output_example\n      mkdir Hits\n      Cutoff=0.1211316\n      awk -v cutoff=${Cutoff} '{FS=OFS=\"\\t\"}{if(NR==1 || (($2+$3)>cutoff && $4==\"Gene\")){print}}' FDR_cutoff/Example_Zeta_anno.txt > Hits/Example_hits.txt\n      \n     ```\n#### step 4. remove off-targeting genes\n   \n   The input files for off-targeting removing are: \n   \n   \n##### 1) Targeting RNA sequences\n   \n   You can find this file in **example** folder: [Example_siRNA.fa](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_siRNA.fa).\n     \n##### 2) Gloden gene sets\n   \n   You can find this file in **example** folder: [Example_GlodenSet.txt](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_GlodenSet.txt). This is constructed based on the priori knowledge.\n   \n   In the example data, we used the annotated spliceosome genes as golden sets.\n   \n##### 3) Hits from **step3**\n     \n   file name is: *Example_hits.txt*\n   \n##### 4) Gene location files: [bed format](https://genome.ucsc.edu/FAQ/FAQformat.html#format1). The genome version should be human release 38(hg38).\n   \n   The default file is human gene locations downloaded from [Gencode database](https://www.gencodegenes.org/human/)(V28).\n   \n   You can find this file in **example** folder: *gencode.v28.annotation.bed.gz*\n   \n   Uncompress it.\n   \n   `unzip gencode.v28.annotation.bed.zip`\n   \n   \n##### 5) GeneID transfer files: Transfer transcript name to GeneID. You can construct the file directly from the gtf files downloaded from [Gencode database](https://www.gencodegenes.org/human/).\n  \n  You can find this file in **example** folder: *geneID_transcriptID_geneName_V28*\n   \n   ```\n   awk 'BEGIN{FS=OFS=\"\\t\"}{if($3==\"transcript\"){print $9}}' gencode.v28.annotation.gtf |sed 's/; /\\t/g'|sed 's/ \"/\\t/g'|cut -f 2,4,8|sed 's/\"//g' > geneID_transcriptID_geneName_V28\n   \n   ```\n  \n ##### 6) Normalized matrix from **step2**\n   \n   ` cd output_example/Zscore`\n   \n   file name is : *Example_Zscore.matrix*\n   \n   Run the following code to remove candidate off-targeting genes:\n   \n   ```\n   cd bin\n   sh OffTargeting.sh -b ../output_example/Hits -i ../output_example/Hits/Example_hits.txt -o OffT -m ../output_example/Zscore/Example_Zscore.matrix -t ../example/Example_siRNA.fa -l ../example/gencode.v28.annotation.bed -g ../example/Example_GlodenSet.txt -c ../example/geneID_transcriptID_geneName_V28\n   ```\n   The output files is in **../output_example/Hits** folder: *OffT_output.txt* ; the hits appear in this file were candidate off-targeting genes. In our example dataset, there were no candidate off-targeting hits.\n   \n#### step 5. functional interpretation of selected hits\n   The input file is hits file from **step3**\n    \n    ```\n    cd bin\n    sh Function.sh -a ../output_example/Hits -b ../output_example/Hits -i Example_hits.txt -o Example_Functions\n    \n    ``` \n   The output files are below:\n   \n   <img width=\"887\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118561319-abda1f00-b71f-11eb-9df4-53882e9ac9d2.png\">\n\n    \n#### step 6. constructe network files\n   The input files for Network construction are:\n   \n   1)Normalized matrix from **step2**\n    \n   2)Hits from **step3**\n    \n   3)consensus_score_cutoff: the threshold to choose edges in the network.\n   \n   ```\n     cd bin\n     sh Network.sh -b ../output_example/Hits -h ../output_example/Hits/Example_hits.txt -i ../output_example/Zscore/Example_Zscore.matrix -o Network -c 0.4\n   ```  \n The output files are below:\n      **Edge file**: *Network_Edges_filter.csv* and **Node file**: *Network_Network_node.csv*\n  \n Load these files to **Gephi** for visulization:\n \n ![Network](https://user-images.githubusercontent.com/65927843/118563054-bb0e9c00-b722-11eb-9f33-d8299e5d2abc.png)\n\n ## Testing ZetaSuite using one example (single-cell transcriptomics)\n \n In this part, we provide an example using the example datasets in our Manuscript Figure7andS7.\n \n ###step1. Obtain the cell x gene matrix. If the output files is 10x, you can directly obtain the matrix from their output files.\n ```\n    library(seurat)\n    sce<-CreateSeuratObject(counts = Read10X(file_path), project = \"fileName\" )\n    matrix<-t(as.data.frame(sce[[\"RNA\"]]@counts)) \n    write.table(matrixfilter,\"Placenta_input.matrix\",sep=\"\\t\",row.names=T,col.names=T)\n ```\n \n ###step2. Using ZetaSuite to filter the empty or broken cells. Note, we recommend to remove the mitochondria genes. \n ```\n    cut -f 1-27124,27138- ../example/Placenta_input.matrix > Placenta_rmMT.matrix\n    perl ZetaSuite_SC.pl -id ./  -od ./ -in Placenta_rmMT.matrix -op placenta\n ```\n\n###step3. Based on the output of ZetaSuite, we choose the cut-off (Zeta score = 1259) to filter cells.\n```\n   awk 'BEGIN{FS=OFS=\"\\t\"}NR==FNR{if($2>1259){A[$1]=\"yes\"}}NR>FNR{if(FNR==1 || A[$1]!=\"\"){print}}' placenta_Zeta  Placenta_rmMT.matrix > Placenta_rmMT_filter.matrix\n```\n\n###step4. The output file from step3 can be used as input for futher single-cell RNA-seq analysis. Following steps shows that how to used seurat for further analysis.\n```\n    stringsAsFactors = FALSE\n    set.seed(12345)\n    TableA <-read.table(\"Placenta_rmMT_filter.matrix\",sep=\"\\t\", header=T,row.names=1)\n    TableA<-t(TableA)\n    simple.merge.obj <- CreateSeuratObject(counts = TableA, project = \"placenta\")\n    #Log normalization\n    simple.merge.obj <- NormalizeData(simple.merge.obj)\n    #Find variable features\n    simple.merge.obj <- FindVariableFeatures(simple.merge.obj, nfeatures = 2000)\n    all.genes <- rownames(simple.merge.obj)\n    #scaling\n    simple.merge.obj <- ScaleData(simple.merge.obj, features = all.genes)\n    #run PCA analysis\n    simple.merge.obj <- RunPCA(simple.merge.obj)\n    simple.merge.obj <- FindNeighbors(simple.merge.obj, dims = 1:40)\n    #do cluster\n    simple.merge.obj <- FindClusters(simple.merge.obj, resolution = 0.5)\n    #run UMAP\n    simple.merge.obj <- RunUMAP(simple.merge.obj, dims = 1:40)\n\n```\n# Guide of generating non-expressors\n\nUsers could retrieve the non-expressors from many known databases, such as GEPIA(http://gepia.cancer-pku.cn/), Expression Atlas (https://www.ebi.ac.uk/gxa/home), Gene Expression Barcode database (http://barcode.luhs.org), etc. Moreover, we also provided non-expressor profiles in 38 cancer tissues (from TCGA), 54 normal tissues (from GTEx) as well as 1393 popular cancer/matched normal cell lines (from CCLE) in our website (https://github.com/YajingHao/ZetaSuite/tree/master/Non-expressors_profile). As for some new/rare cell types, users can either search the GEO database or directly generate RNA-seq data and then use classical RNA-seq processing pipelines provided in Homer(http://homer.ucsd.edu/homer/ngs/rnaseq/index.html) to generate the list of non-expressed genes.\n\n# Citations\n\n**software** : *Yajing Hao, Changwei Shao, Guofeng Zhao, Xiang-Dong Fu (2021). ZetaSuite, A Computational Method for Analyzing Multi-dimensional High-throughput Data, Reveals Genes with Opposite Roles in Cancer Dependency. Forthcoming*\n\n**in-house dataset** : *Changwei Shao, Yajing Hao, Jinsong Qiu, Bing Zhou, Hairi Li, Yu Zhou, Fan Meng, Li Jiang, Lan-Tao Gou, Jun Xu, Yuanjun Li,Hui Wang, Gene W. Yeo, Dong Wang, Xiong Ji, Christopher K. Glass, Pedro Aza-Blanc, Xiang-Dong Fu (2021). HTS2 Screen for Global Splicing Regulators Reveals a Key Role of the Pol II Subunit RPB9 in Coupling between Transcription and Pre-mRNA Splicing. Cell.  Forthcoming.* \n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "If the input is already normalized matrix, you can directly run `ZetaSuite.pl` with parameter `-z no`.",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "The input of ZetaSuite can be three types:"
        ],
        "type": "Text_excerpt",
        "value": "## ZetaSuite : A Computational Method for Analyzing High-dimensional High-throughput Data\n\n![Figure1-01](https://user-images.githubusercontent.com/65927843/118019732-2b29b600-b30e-11eb-9ca0-5911dd82b608.jpg)\nIf you have any questions, please contact Yajing Hao <yahao@health.ucsd.edu> in [Fu Lab](http://fugenome.ucsd.edu/).\n\n## Table of contents\n- Installation\n- The overall workflow of ZetaSuite\n- Testing ZetaSuite using one example\n- Guide of generating non-expressors\n- Citations\n## Installation\nSince ZetaSuite is written in `Shell`, `R` and `Perl`, `R` and `Perl` are needed. \n\nOther R packages dependencies are:\n    \n    \n     library(foreach)\n     library(ggplot2)\n     library(parallel)\n     library(RColorBrewer)\n     library(reshape2)\n     library(DMwR)\n     library(scater)\n     library(e1071)\n     library(Rtsne)\n     library(clusterProfiler)\n     library(org.Hs.eg.db)\n     library(enrichplot)\n     library(DOSE)\n     library(bubbles)\n     library(colorRamps)\n     library(webshot)\n     library(htmlwidgets)\n     library(SC3)\n     library(SingleCellExperiment)\n     library(NbClust)\n     library(mixtools)\n     \nYou can just run the code below to install all the dependent R packages at once:\n\n`install.packages(c(\"foreach\", \"ggplot2\",\"parallel\",\"RColorBrewer\", \"reshape2\",\"DMwR\",\"e1071\", \"Rtsne\",\"clusterProfiler\",\"org.Hs.eg.db\",\"enrichplot\",\"DOSE\",\"bubbles\",\"colorRamps\",\"webshot\",\"htmlwidgets\",\"SC3\",\"SingleCellExperiment\",\"NbClust\",\"mixtools\"))`\n\nOther softwares dependencies are:\n\n- `Bedtools`(https://bioweb.pasteur.fr/docs/modules/bedtools/2.17.0/index.html)\n- `blast`(https://blast.ncbi.nlm.nih.gov/Blast.cgi)\n\n      \nThe installation procedure is extremely easy. \n1. clone the source code from git-hub.\n   \n   `git clone https://github.com/YajingHao/ZetaSuite.git`\n2. go into the directory in the command line. \n   \n   ```\n   cd ZetaSuite/bin\n   chmod 777 ./*\n   ```\n   \n3. go to website to download the annotation dataset\n   \n   `wget -c http://fugenome.ucsd.edu/HumanGenome/hg38_chr.fa `\n   \n   `mv ./hg38_chr.fa ./dataSets`\n   \n4. test the example data.\n\n   Go to ZetaSuite directory,and run the example.\n   \n   ```\n   cd ..\n   chmod 777 ZetaSuite.pl\n   perl ZetaSuite.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -p Example_postive_wells.list -n Example_negative_wells.list -ne Example_NonExp_wells.list -z yes -c yes -svm no\n   \n   ```\n   \n   If you want use ZetaSuite to deal with single cell RNA-seq, run the example code below:\n   ```\n   cd example\n   tar zxvf Example.matrix.tar.gz\n   cd ..\n   perl ZetaSuite_SC.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -n 10\n   ```\n    \nAnd it is done :v:!\n\n## The overall workflow of ZetaSuite.\n![workflow-01](https://user-images.githubusercontent.com/65927843/118020609-1ef22880-b30f-11eb-8e59-843c3eb4fe31.jpg)\n\n\n### The input of ZetaSuite can be three types:\n      \n      - Raw read count matrix, in the example data: rows are the genes with targeting siRNAs, and columns are the AS events as readouts.\n      - Preprocess matrix, which means the low-quality rows and columns were already filtered by users.\n      - Normalized matrix, which means the value in the matrix can directly compare and do the accumulation.\n        \n\n* #### If the input is the raw read count matrix without any processing, please run the `Preprocess.sh` first.\n\n    `sh Preprocess.sh -a <Input_dir> -b <output_dir> -i <Input_File> -o <Output_Name>`\n    \n    `Preprocess.sh` includes the following two steps: \n    \n     1. Filtering low quailty samples(rows) and low quality readouts(columns).\n     \n     2. Using KNN to estimate the value of missing data points in the input matrix.\n\n* #### If the input is the already precessed matrix, you can directly run `ZetaSuite.pl`.\n\n    `perl ZetaSuite.pl -id <input_dir> -od <output_dir> -in <input_matrix> -op <output_prefix> -p <positive.list> -n <negative.list> -ne <internatal_negative.list>`\n    \n    You can check the parameters for `ZetaSuite.pl` by simply type\n    \n    `perl ZetaSuite.pl -h`\n    \n    ```\n    Usage:    \n    -id  <STR>      input directory [require]\n    -od  <STR>      output directory [require]\n    -in  <STR>      input file name [require]\n    -op  <STR>      output file prefix [require]\n    -p   <STR>      positive control file [require]\n    -n   <STR>      negative control file [require]\n    -ne  <STR>      internal negative control file (non-expressed genes) [require]\n    -z   <STR>      zscore normalization(yes or no) [default yes]\n    -c   <STR>      combine two direction zeta together(yes or no) [default no] \n    -svm <STR>      svm calculation (yes or no) [dafault yes]\n    -h   <STR>      documents help\n    \n    ```\n\n    `ZetaSuite.pl` includes the following steps:\n   \n    1). QC evaluation of the input matrix `<input_matrix>`. We just evaluate the QC but will not do any filterations.\n  \n    2). Calculating the Z-score to make the readouts are comparable.(option command `-z` yes or no,default: yes)\n    \n    3). Calculating the Event Coverage for each gene(row). \n    \n    4). Using the SVM curve to filter the genes which show similar responce with negative controls.(option command `-svm` yes or no , default: yes)\n    \n    5). Whether users need to directly compare the Zeta score in two directions and use the combined Zeta score to do hits' selection? (option command `-c` yes or no, default: no)\n    \n    6). Calculating the Zeta score.\n    \n    7). Drawing screen strength curve based on the internal negative control `<internatal_negative.list>`.\n \n  \n* #### If the input is already normalized matrix, you can directly run `ZetaSuite.pl` with parameter `-z no`. \n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "step 2. run <a href=\"https://github.com/YajingHao/ZetaSuite\">ZetaSuite</a> main pipeline",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail."
        ],
        "type": "Text_excerpt",
        "value": "   \n  ```\n  perl ZetaSuite.pl -id ./example -od ./output_example -in Example_matrix.txt -op Example -p Example_postive_wells.list -n Example_negative_wells.list -ne Example_NonExp_wells.list -z yes -c yes -svm yes\n  ```\n     \nAfter finished processing, we will obtain the following files and figures in the corresponding directory:\n\nThe most time cosuming step is SVM in our pipeline. If you just want to test the pipeline, you can choose `-svm no`.\n  \n  `cd /output_example`\n  \n   1. QC figures : `cd QC`\n   \n   Example_tSNE_QC.pdf is the global evaluation based on all the readouts. This figure can evaluate whether the positive and negative samples are well separted based on current all readouts.\n   \n   The following 3 figures is the quality evaluation of the individual readouts.\n   \n![QC-01](https://user-images.githubusercontent.com/65927843/118415924-ef6e5380-b661-11eb-9a97-7354fca27158.png)\n\n\n\n   2. Normalized matrix:  `cd Zscore` **Example_Zscore.matrix** is the normalized matrix, each row represents each knocking-down condition and each column is a specific readout (AS event). The values in the matrix are the normalized values.\n   \n   3. EventCoverage figures for positive and negative samples: `cd EventCoverage`\n     \n   ![EC_figures-01](https://user-images.githubusercontent.com/65927843/118417118-8689da00-b667-11eb-86eb-8a3813385110.png)\n\n   \n   4. ZetaScore file: `cd Zeta` Example_Zeta.txt is the zeta values for all tested knockding-down genes including positive and negative controls. The first column is the direction which knockding-down gene will lead to exon inclusion, whereas the second column is the knock-down genes will lead to exon skipping.\n   \n   5. ZetaScore figure: `cd FDR_cutoff` Example_Zeta_type.pdf\n   <img width=\"990\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118415093-3148cb00-b65d-11eb-8e1c-448aaf00a173.png\">\n\n\n   6. ScreenStrength curve: `cd FDR_cutoff` Example_SS_cutOff.pdf\n  <img width=\"800\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118530970-23955300-b6fa-11eb-9bfa-144149df4946.png\">\n\n  "
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "somef_missing_categories": [
    "acknowledgement",
    "requirements",
    "contact",
    "contributors",
    "documentation",
    "faq",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-10-04 13:50:56",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 4
      },
      "technique": "GitHub_API"
    }
  ],
  "type": [
    {
      "confidence": 0.82,
      "result": {
        "type": "String",
        "value": "commandline-application"
      },
      "technique": "software_type_heuristics"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Following steps were decided by the users, see example for detail.",
        "parent_header": [
          "The overall workflow of ZetaSuite."
        ],
        "type": "Text_excerpt",
        "value": "  1. Based on the screen strength curve, users can define their optimal threshold by considering both SS and balance points.\n  2. Based on the threshold to select hits.\n  3. Removing Off-targeting hits based on the regulation similarity and siRNA targeting.\n  4. Function interpretation of selected hits based on [ClusterProfiler](https://github.com/YuLab-SMU/clusterProfiler) and [CORUM complexes database](https://github.com/YuLab-SMU/clusterProfiler).The top 15 GO terms with lowest adjust p-values were presented and the top 15 complexes with highest hits\u2019 number were gave.If the complexes number were lower than 15, the complexes with hits\u2019 number larger than 3 would be outputted.\n  5. Constructing Network files for users' selected hits. Then directly used as input to [Gephi](https://gephi.org/) for visulization.\n \n ----------------------------------------------------------------------------------------------------------------------------------------------------------------\n ## Testing ZetaSuite using one example (Large-scale RNAi screening)\nWe provided example data (our in-house HTS2 screening dataset) for using ZetaSuite to explore the hits and do futher functional interpretation. To save the testing time, we provided a subsampled dataset. While this test data may not yield reasonable results, it can be used to see how the workflow is configured and executed.\n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "step 1. we started with the preprecessed data set which was already removed the low qulity rows and columns.",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail."
        ],
        "type": "Text_excerpt",
        "value": "Users can find the example data set in the [example](https://github.com/YajingHao/ZetaSuite/tree/master/example) directory.\nThe example input files include:\n   \n   1. input matrix file, [Example_matrix.txt](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_matrix.txt), Each row represents gene with specific knocking-down siRNA pool, each column is an AS event. The values in the matrix are the processed foldchange values between included exons and skipping exons read counts. \n   \n      (we randomly pick-up 2000 genes and 200 AS events as example matrix)\n   \n      <img width=\"390\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118161936-06e4dc80-b3d5-11eb-880b-259f46b00543.png\">\n\n   2. input negative file, the wells treated with non-specific siRNAs, [Example_negative_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_negative_wells.list). If users didn't have the build-in negative controls, the non-expressed genes should be provided here.\n   3. input positive file, the wells treated with siRNAs targeting to PTB, [Example_positive_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_postive_wells.list). If users didn't have the build-in positive controls, choose the parameters `-withoutsvm` and the filename can use any name such as 'NA'.\n   4. input internal negative control (non-expressed genes), genes which annotated as non-expressed (RPKM<1) in HeLa cells, [Example_NonExp_wells.list](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_NonExp_wells.list).\n  "
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "step 3. selected the thresholds",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail."
        ],
        "type": "Text_excerpt",
        "value": "     \n   Users can check the Screenstrength curves (**Example_SS_cutOff.pdf**) and find the optimal threshold based on balance points and Screen strength.\n   \n   With our example data, we actually identified two BPs, thereby enabling us to define candidate hits after BP1 and high confidence hits after BP2, the latter of which maximally eliminate true false positives derived from non-expressors. To keep enough hits for further analysis, we selected the BP1 as threshold.\n   \n   Then obtain hits passed the threshold with the following command:\n   \n     ```\n      cd output_example\n      mkdir Hits\n      Cutoff=0.1211316\n      awk -v cutoff=${Cutoff} '{FS=OFS=\"\\t\"}{if(NR==1 || (($2+$3)>cutoff && $4==\"Gene\")){print}}' FDR_cutoff/Example_Zeta_anno.txt > Hits/Example_hits.txt\n      \n     ```"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "step 4. remove off-targeting genes",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail."
        ],
        "type": "Text_excerpt",
        "value": "   \n   The input files for off-targeting removing are: \n   \n   "
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "1) Targeting RNA sequences",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail.",
          "step 4. remove off-targeting genes"
        ],
        "type": "Text_excerpt",
        "value": "   \n   You can find this file in **example** folder: [Example_siRNA.fa](https://github.com/YajingHao/ZetaSuite/blob/master/example/Example_siRNA.fa).\n     "
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "3) Hits from **step3**",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail.",
          "step 4. remove off-targeting genes"
        ],
        "type": "Text_excerpt",
        "value": "     \n   file name is: *Example_hits.txt*\n   "
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "4) Gene location files: <a href=\"https://genome.ucsc.edu/FAQ/FAQformat.html#format1\">bed format</a>. The genome version should be human release 38(hg38).",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail.",
          "step 4. remove off-targeting genes"
        ],
        "type": "Text_excerpt",
        "value": "   \n   The default file is human gene locations downloaded from [Gencode database](https://www.gencodegenes.org/human/)(V28).\n   \n   You can find this file in **example** folder: *gencode.v28.annotation.bed.gz*\n   \n   Uncompress it.\n   \n   `unzip gencode.v28.annotation.bed.zip`\n   \n   "
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "step 5. functional interpretation of selected hits",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail."
        ],
        "type": "Text_excerpt",
        "value": "   The input file is hits file from **step3**\n    \n    ```\n    cd bin\n    sh Function.sh -a ../output_example/Hits -b ../output_example/Hits -i Example_hits.txt -o Example_Functions\n    \n    ``` \n   The output files are below:\n   \n   <img width=\"887\" alt=\"image\" src=\"https://user-images.githubusercontent.com/65927843/118561319-abda1f00-b71f-11eb-9df4-53882e9ac9d2.png\">\n\n    "
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "step 6. constructe network files",
        "parent_header": [
          "The overall workflow of ZetaSuite.",
          "Following steps were decided by the users, see example for detail."
        ],
        "type": "Text_excerpt",
        "value": "   The input files for Network construction are:\n   \n   1)Normalized matrix from **step2**\n    \n   2)Hits from **step3**\n    \n   3)consensus_score_cutoff: the threshold to choose edges in the network.\n   \n   ```\n     cd bin\n     sh Network.sh -b ../output_example/Hits -h ../output_example/Hits/Example_hits.txt -i ../output_example/Zscore/Example_Zscore.matrix -o Network -c 0.4\n   ```  \n The output files are below:\n      **Edge file**: *Network_Edges_filter.csv* and **Node file**: *Network_Network_node.csv*\n  \n Load these files to **Gephi** for visulization:\n \n ![Network](https://user-images.githubusercontent.com/65927843/118563054-bb0e9c00-b722-11eb-9f33-d8299e5d2abc.png)\n\n ## Testing ZetaSuite using one example (single-cell transcriptomics)\n \n In this part, we provide an example using the example datasets in our Manuscript Figure7andS7.\n \n ###step1. Obtain the cell x gene matrix. If the output files is 10x, you can directly obtain the matrix from their output files.\n ```\n    library(seurat)\n    sce<-CreateSeuratObject(counts = Read10X(file_path), project = \"fileName\" )\n    matrix<-t(as.data.frame(sce[[\"RNA\"]]@counts)) \n    write.table(matrixfilter,\"Placenta_input.matrix\",sep=\"\\t\",row.names=T,col.names=T)\n ```\n \n ###step2. Using ZetaSuite to filter the empty or broken cells. Note, we recommend to remove the mitochondria genes. \n ```\n    cut -f 1-27124,27138- ../example/Placenta_input.matrix > Placenta_rmMT.matrix\n    perl ZetaSuite_SC.pl -id ./  -od ./ -in Placenta_rmMT.matrix -op placenta\n ```\n"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "step4. The output file from step3 can be used as input for futher single-cell RNA-seq analysis. Following steps shows that how to used seurat for further analysis.",
        "parent_header": [
          "The overall workflow of ZetaSuite."
        ],
        "type": "Text_excerpt",
        "value": "```\n    stringsAsFactors = FALSE\n    set.seed(12345)\n    TableA <-read.table(\"Placenta_rmMT_filter.matrix\",sep=\"\\t\", header=T,row.names=1)\n    TableA<-t(TableA)\n    simple.merge.obj <- CreateSeuratObject(counts = TableA, project = \"placenta\")\n    #Log normalization\n    simple.merge.obj <- NormalizeData(simple.merge.obj)\n    #Find variable features\n    simple.merge.obj <- FindVariableFeatures(simple.merge.obj, nfeatures = 2000)\n    all.genes <- rownames(simple.merge.obj)\n    #scaling\n    simple.merge.obj <- ScaleData(simple.merge.obj, features = all.genes)\n    #run PCA analysis\n    simple.merge.obj <- RunPCA(simple.merge.obj)\n    simple.merge.obj <- FindNeighbors(simple.merge.obj, dims = 1:40)\n    #do cluster\n    simple.merge.obj <- FindClusters(simple.merge.obj, resolution = 0.5)\n    #run UMAP\n    simple.merge.obj <- RunUMAP(simple.merge.obj, dims = 1:40)\n\n```"
      },
      "source": "https://raw.githubusercontent.com/YajingHao/ZetaSuite/master/README.md",
      "technique": "header_analysis"
    }
  ]
}
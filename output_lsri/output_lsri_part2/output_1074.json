{
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/biocore/zebra_filter"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2019-10-02T20:14:05Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-06-29T05:39:19Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "Filtering out false taxonomic hits from shotgun sequencing based on genome coverage"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 0.890878323925697,
      "result": {
        "original_header": "Zebra Filter",
        "type": "Text_excerpt",
        "value": "Filtering out false taxonomic hits from shotgun sequencing based on aggregated genome coverage of all samples in dataset.   \n_When you hear hoofs, think horse, not zebra._  \n-_Theodore Woodward_ \n"
      },
      "source": "https://raw.githubusercontent.com/biocore/zebra_filter/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9628429979252869,
      "result": {
        "original_header": "Overview",
        "type": "Text_excerpt",
        "value": "False positives are common in metagenomic sequencing because databases are incomplete and do not represent many of the microbes actually in our samples. Short shotgun sequencing reads will incorrectly map to short common motifs and transposable elements, making it look like an microbe is present when it actually isn't. One way to distinguish these false positives is by looking at genome coverage; microbes that are actually present will have high genome coverage, while mis-mappings to short motifs will have low genome coverage. A problem with this coverage approach is that shotgun sequencing is often shallow for each sample, so coverage of all microbes will be low whether it is acually there or not.   \nThe logic behind this method is that datasets often have many samples from the same environment, and those samples are likely to have very similar microbes. With that assumption, we aggregate the genome coverage of all samples in the dataset to create \"artificially deep\" shotgun sequencing. Note that only unique coverage is counted, multiple reads covering the same location of the genome will not increase the coverage. At this deeper sequencing, true positives will have higher genome coverage and will be easier to distinguish from false positives, which will still have low genome coverage.  \n___ \n"
      },
      "source": "https://raw.githubusercontent.com/biocore/zebra_filter/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/biocore/zebra_filter/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "executable_example": [
    {
      "confidence": 1,
      "result": {
        "format": "jupyter_notebook",
        "type": "Url",
        "value": "https://raw.githubusercontent.com/biocore/zebra_filter/master/databases/WoL/.ipynb_checkpoints/make_wol_database-checkpoint.ipynb"
      },
      "source": "https://raw.githubusercontent.com/biocore/zebra_filter/master/databases/WoL/.ipynb_checkpoints/make_wol_database-checkpoint.ipynb",
      "technique": "file_exploration"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 6
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/biocore/zebra_filter/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "biocore/zebra_filter"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "Zebra Filter"
      },
      "source": "https://raw.githubusercontent.com/biocore/zebra_filter/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/biocore/zebra_filter/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "zebra_filter"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "Organization",
        "value": "biocore"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "Python",
        "size": 11221,
        "type": "Programming_language",
        "value": "Python"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Jupyter Notebook",
        "size": 3109,
        "type": "Programming_language",
        "value": "Jupyter Notebook"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/biocore/zebra_filter/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "somef_missing_categories": [
    "installation",
    "citation",
    "acknowledgement",
    "run",
    "download",
    "requirements",
    "contact",
    "contributors",
    "documentation",
    "license",
    "faq",
    "support",
    "identifier",
    "has_build_file"
  ],
  "somef_provenance": {
    "date": "2024-10-04 13:06:07",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 7
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Usage",
        "parent_header": [
          "Zebra Filter"
        ],
        "type": "Text_excerpt",
        "value": "This repository contains 2 scripts, the first, _calculate_coverages.py_, calculates the genome coverage from .sam alignments. The second script, _filter_sam.py_, filters .sam alignments based on a coverage threshhold that can be determined by the user based on the output from _calculate_coverages.py_.  \n\n__Note__: _calculate_coverages.py_ can be used alone to look at the coverage of each genome in the dataset. You can use this coverage information to filter your abundance table.\n"
      },
      "source": "https://raw.githubusercontent.com/biocore/zebra_filter/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "calculate_coverages.py",
        "parent_header": [
          "Zebra Filter",
          "Usage"
        ],
        "type": "Text_excerpt",
        "value": "Calculates the aggregated unique coverage of each target genome from all the input alignments together. It is designed to work with alignments generated by bowtie2 or SHOGUN (using the bowtie2 alignment option). The input is a directory of .sam alignment files. Currently only works with the Web of Life database (https://biocore.github.io/wol/). The Web of Life metadata file is also required and provided in this repository at _databases/WoL/metadata.tsv_.\n```\nUsage: calculate_coverages.py [OPTIONS]\n\nOptions:\n  -i, --input TEXT     Input: Directory of sam files (files must end in .sam).\n                       [required]\n  -o, --output TEXT    Output: file name for list of coverages.  [required]\n  -d, --database TEXT  WoL genome metadata file.  [default:\n                       databases/WoL/metadata.tsv]\n  --help               Show this message and exit.\n```\nThe output .tsv contains information about the coverage of each genome in the dataset. This alone can be used to decide which genomes to filter out of your abundance table, without using _filter_sam.py_. However, _this is not recommended_ as it will decrease the apparent number of reads rather than redistributing these to the other hits when using WoLTKA. \n\nInstead, we recommend that you remove the false positive hits from your alignments, using the _filter_sam.py_ script and then provide these alignments to WoLTKA to regenerate your abundance table.\n___"
      },
      "source": "https://raw.githubusercontent.com/biocore/zebra_filter/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "filter_sam.py",
        "parent_header": [
          "Zebra Filter",
          "Usage"
        ],
        "type": "Text_excerpt",
        "value": "Filters alignments from .sam files based on a user-set coverage threshhold, creating new .sam files. Takes in the output .tsv from _calculate_coverages.py_, the directory of .sam alignments, a coverage threshhold, and an output folder. Outputs one filtered .sam alignment for each input alignment. The coverage threshhold is based on the _coverage_rato_ column of the input .tsv, which is the portion of the genome with unique coverage in the dataset.\n```\nUsage: filter_sam.py [OPTIONS]\n\nOptions:\n  -i, --input TEXT    Input coverage .tsv file generated from\n                      calculate_coverages.py.  [required]\n  -s, --sam TEXT      Sam file to filter or directory of sam files to filter.\n                      [required]\n  -c, --cutoff FLOAT  Minimum % genome coverage.  [default: 0.1]\n  -o, --output TEXT   Output directory to write output files. Will be created\n                      if does not exist.  [required]\n  --help              Show this message and exit.\n  ```\n___"
      },
      "source": "https://raw.githubusercontent.com/biocore/zebra_filter/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Example",
        "parent_header": [
          "Zebra Filter"
        ],
        "type": "Text_excerpt",
        "value": "Example you can run using the test_data provided in this repo (_test_data/sample_alignments_). The test data is 5 .sam alignment files with 100 alignments in each file.  \n\nFirst run the first script: _calcualte_coverages.py_\n```\n$ python calculate_coverages.py -i test_data/ -o test_data/sample_output.tsv -d databases/WoL/metadata.tsv\n```\nView output\n```\n$head test_data/sample_output.tsv\ngotu\tcovered_length\ttotal_length\tcoverage_ratio\tstrain\nG001578205\t20963\t3878815\t0.005404485648323006\tBacillus pumilus SH-B9\nG001017485\t3366\t3795691\t0.0008867950526004356\tBacillus pumilus 15.1\nG001653905\t3292\t3670170\t0.0008969611761852994\tBacillus safensis S9\nG900119345\t3218\t3706009\t0.0008683195318737758\tBacillus sp. ru9509.4 RU9509.4\nG000986655\t3152\t3634690\t0.0008671991283988456\tBacillus sp. L_1B0_12 ASM98665v1\nG000701305\t2848\t3718149\t0.0007659725309555911\tBacillus sp. UNC125MFCrub1.1 ASM70130v1\nG001457015\t2775\t3615064\t0.0007676212647964185\tBacillus cellulasensis NIO-1130\nG900094985\t2773\t3615064\t0.0007670680242452139\tBacillus sp. nio-1130 NIO-1130\nG000715205\t2344\t3736192\t0.0006273767515159821\tBacillus zhangzhouensis DW5-4\n```\nThe columns in the output tsv:\n- gotu: genome id of hit organism\n- covered_length: Length of total unique genome coverage in base pairs from all samples combined\n- total_length: Total length of genome in base pairs\n- coverage_ratio: Portion of hit genome covered. Calculated by covered_length / total_length\n\nSince this is a tiny dataset, so coverages are extremely low. Looking at the data we choose 0.0008 as our coverage_ratio cutoff.  \n\nWe run the second script, _filter_sam.py_ to filter all GOTUs with a coverage_ratio less than 0.008 from our .sam alignments. This will create a new folder of .sam alignments with only hits from genomes with over 0.008 coverage_ratio.\n```\n$ python filter_sam.py -i test_data/sample_output.tsv -s test_data/sample_alignments/ -c .0008 -o test_data/filtered_sample_alignments\n```\nIf we look in the folder that was created, _test_data/filtered_sample_alignments_, we see that new filtered alignments have been created.\n```\n$ ls test_data/filtered_sample_alignments\nalignment1_filtered.sam\nalignment2_filtered.sam\nalignment3_filtered.sam\nalignment4_filtered.sam\nalignment5_filtered.sam\n```\nThese alignments can be used to create a biom table using Woltka (https://github.com/qiyunzhu/woltka).\n"
      },
      "source": "https://raw.githubusercontent.com/biocore/zebra_filter/master/README.md",
      "technique": "header_analysis"
    }
  ]
}
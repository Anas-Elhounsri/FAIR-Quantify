{
  "citation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "reference",
        "type": "Text_excerpt",
        "value": "kmc: https://github.com/refresh-bio/KMC\n"
      },
      "source": "https://raw.githubusercontent.com/lzhLab/kmcEx/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/lzhLab/kmcEx"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2018-06-23T02:52:37Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2020-05-03T18:24:00Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 0.999552384962604,
      "result": {
        "original_header": "kmcEx",
        "type": "Text_excerpt",
        "value": "K-mers along with their frequency have served as an elementary building block for error correction, repeat detection, multiple sequence alignment, genome assembly, etc., attracting intensive studies in k-mer counting. However, the output of k-mer counters itself is large; very often, it is too large to fit into main memory, leading to highly narrowed usability. We introduce a novel idea of encoding k- mers as well as their frequency, achieving good memory saving and retrieval efficiency. Specifically, we propose a Bloom Filter-like data structure to encode counted k-mers by coupled-bit arrays\u2014 one for k-mer representation and the other for frequency encoding. Experiments on five real data sets show that the average memory- saving ratio on all 31-mers is as high as 13.81 as compared with raw input, with 7 hash functions. At the same time, the retrieval time complexity is well controlled (effectively constant), and the false-positive rate is decreased by two orders of magnitude.\n \n"
      },
      "source": "https://raw.githubusercontent.com/lzhLab/kmcEx/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/lzhLab/kmcEx/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 2
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/lzhLab/kmcEx/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "lzhLab/kmcEx"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "kmcEx"
      },
      "source": "https://raw.githubusercontent.com/lzhLab/kmcEx/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "installation",
        "type": "Text_excerpt",
        "value": "kmcEx is based on **C++11**\uff0cand the installation step is very simple, in the kmodel main directory run 'make'  command, then you can get the executable kmodel.\n```\nmake # run in the main directory \n```"
      },
      "source": "https://raw.githubusercontent.com/lzhLab/kmcEx/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/lzhLab/kmcEx/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "encoding-kmers, kmer, ngs"
      },
      "technique": "GitHub_API"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "kmcEx"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "User",
        "value": "lzhLab"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "C++",
        "size": 118043,
        "type": "Programming_language",
        "value": "C++"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "Makefile",
        "size": 417,
        "type": "Programming_language",
        "value": "Makefile"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/lzhLab/kmcEx/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "somef_missing_categories": [
    "acknowledgement",
    "run",
    "download",
    "requirements",
    "contact",
    "contributors",
    "documentation",
    "license",
    "faq",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-11-04 05:16:52",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 4
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "usage",
        "type": "Text_excerpt",
        "value": "how to use  the executable kmcEx for testing\n```\n1. USAGE\n     kmcEx [options] <input_file_name> <output_file_name> <working_directory>\n     kmcEx [options] <@input_file_names> <output_file_name> <working_directory>\n2. OPTIONS\n     1) REQUIRED\n        input_file_name    - single file in FASTQ format (gziped or not)\n        @input_file_names  - file name with list of input files in FASTQ format (gziped or not)\n        working_directory  - save temporary files\n     2) OPTIONAL\n        -k<len>            - k-mer length (default: 31) \n        -t<value>          - total number of threads (default: 4)\n        -ci<value>         - exclude k-mers occurring less than <value> times (default: 1)\n        -cs<value>         - maximal value of a counter (default: 1023)\n        -nh<value>         - number of hash (default: 7)\n        -nb<value>         - number of bit array (default: 5)\n3. EXAMPLES\n     kmcEx -k31 -nh7 -nb5  rs.fastq rs.res /tmp\n     kmcEx -k31 -nh7 -nb5  @rs.lst rs.res /tmp\n```\n"
      },
      "source": "https://raw.githubusercontent.com/lzhLab/kmcEx/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "usage demo",
        "type": "Text_excerpt",
        "value": "```\n#!/bin/bash\nkn=31\nout_dir=/tmp \nci=1\ncs=1023\n./kmcEx -ci${ci} -cs${cs} -k${kn} -t8 @sa.lst $out_dir/SA_k${kn}_f${ci}-${cs}.res /tmp\n./kmcEx -ci${ci} -cs${cs} -k${kn} -t8 @rs.lst $out_dir/RS_k${kn}_f${ci}-${cs}.res /tmp\n./kmcEx -ci${ci} -cs${cs} -k${kn} -t8 @hc14.lst $out_dir/HC14_k${kn}_f${ci}-${cs}.res /tmp\n./kmcEx -ci${ci} -cs${cs} -k${kn} -t8 @bi.lst $out_dir/BI_k${kn}_f${ci}-${cs}.res /tmp\n./kmcEx -ci${ci} -cs${cs} -k${kn} -t8 @na12878_1.lst $out_dir/NA12878_k${kn}_f${ci}-${cs}.res /tmp\n```\nthe file **rs.lst**  is the list of pathes of fastq files, one line per file, e.g.:\n```\n/share/share/data/NGS/GAGE/RS/rs_frag_1.fastq\n/share/share/data/NGS/GAGE/RS/rs_frag_2.fastq\n```\nafter running the command, in the $out_dir\uff0cyou will get kmc_database files:\n```\nRS_k31_f1-1023.res.kmc_pre\nRS_k31_f1-1023.res.kmc_suf\n```\nthe model saved  in  /tmp/RS_k31_f1-1023.res  (working_directory)\uff0ci.e.:\n\n```\nheader  km.bin  rest.bin\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/lzhLab/kmcEx/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "API usage",
        "type": "Text_excerpt",
        "value": "create a kmodel and save it to the disk\uff0csince the number of kmers having count of 1 (counter=1) is very huge\uff0cwe distinguish this two situations that counter>1 and counter>=1. you can pass the parameter 'ci' to get different model (if ci=1, then the model uses counter>=1; else the counter>1 is used)\n1) create a model, and save it to a disk\n```c\n#include \"kmodel.hpp\"\n//some arguments\nint n_hash = 7, n_bit = 4, ci=1, cs=1023;\n//kmc_database is the kmc database file,such as 'RS_k31_f1-1000.res'\nstring kmc_database = \"/tmp/RS_k31_f2-1000.res\";\n//get a model with ci... \nKModel* kmodel = get_model(ci, cs, n_hash, n_bit);\n//initialize the model\nkmodel->init_KModel(kmc_database);\n//save model to an existing directory \"model_dir\",\nkmodel->save_model(\"/tmp/rs_f2-1000_model\");\n```\n\n2) load a model from  a disk, and retrieve the occurrence of kmers\n```c\n#include \"kmodel.hpp\"\n//some arguments\nstring save_dir = \"/tmp/rs_f2-1000_model\";\nKModel* kmodel = get_model(save_dir);\n//query one kmer \nstring kmer = ...;\nint occ = kmodel->kmer_to_occ(kmer)\n//query multiple kmer with multiple threads\nvector<string> kmer_v = ...;\nvector<int> out = kmodel->kmer_to_occ(kmer_v);\n```\n"
      },
      "source": "https://raw.githubusercontent.com/lzhLab/kmcEx/master/README.md",
      "technique": "header_analysis"
    }
  ]
}
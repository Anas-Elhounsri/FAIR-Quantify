{
  "citation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Getting Reference Sequence",
        "parent_header": [
          "Tutorial",
          "Working with BAM files"
        ],
        "type": "Text_excerpt",
        "value": "Retrieving the reference can only be done if the reference has been loaded, which isn't done automatically in order to save memory. Reference need only be loaded once, and is accessed using reference name, start, end in 1-based co-ordinates. A standard Ruby String object is returned.\n\n\tbam.load_reference \n\tsequence_fragment = bam.fetch_reference(\"Chr1\", 1, 500)\n\t"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "code_repository": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/rjpbonnal/bioruby-samtools"
      },
      "technique": "GitHub_API"
    }
  ],
  "contributing_guidelines": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Contributing to bio-samtools",
        "parent_header": [
          "VCF methods"
        ],
        "type": "Text_excerpt",
        "value": " \n* Check out the latest master to make sure the feature hasn't been implemented or the bug hasn't been fixed yet\n* Check out the issue tracker to make sure someone already hasn't requested it and/or contributed it\n* Fork the project\n* Start a feature/bugfix branch\n* Commit and push until you are happy with your contribution\n* Make sure to add tests for it. This is important so I don't break it in a future version unintentionally.\n* Please try not to mess with the Rakefile, version, or history. If you want to have your own version, or is otherwise necessary, that is fine, but please isolate to its own commit so I can cherry-pick around it.\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "TODO",
        "parent_header": [
          "VCF methods",
          "Contributing to bio-samtools"
        ],
        "type": "Text_excerpt",
        "value": "1. Filter to the fetching algorithm (give a condition that has to be satisfied to add the alignment to the list)\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "To whom do I complain?",
        "parent_header": [
          "VCF methods",
          "Contributing to bio-samtools"
        ],
        "type": "Text_excerpt",
        "value": "Try [Ricardo.Ramirez-Gonzalez@jic.ac.uk](Ricardo.Ramirez-Gonzalez@jic.ac.uk)\n and [dan.maclean@tsl.ac.uk](dan.maclean@tsl.ac.uk)\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Important Notes",
        "parent_header": [
          "VCF methods",
          "Contributing to bio-samtools"
        ],
        "type": "Text_excerpt",
        "value": "* samtools is downloaded, compiled and installed inside the gem at install time on the host system\n\n* If you use this tool for publication, please cite http://dx.doi.org/10.1186/1751-0473-7-6\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Important Notes for developers",
        "parent_header": [
          "VCF methods",
          "Contributing to bio-samtools"
        ],
        "type": "Text_excerpt",
        "value": "Remember that you must compile and install samtools for you host system. In order to do that there are two possible solutions:\n\n* download, compile and install the library in bioruby-samtools-your_clone/lib/bio/db/sam/external/samtools and\n bioruby-samtools-your_clone/lib/bio/db/sam/external/bcftools by yourself\n* in your bioruby-samtools-your_clone create the Rakefile typing `cd ext; ruby mkrf_conf.rb; rake -f Rakefile`\n\nThe latest I think is the easiest way, cause you are replicating the automatic process.\n\nFor testing just run `rake test`. Tests must be improved.\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Travis integration",
        "parent_header": [
          "VCF methods",
          "Contributing to bio-samtools",
          "Important Notes for developers"
        ],
        "type": "Text_excerpt",
        "value": "If you are integrating this library into another tool and testing it with travis, add the follwing in ```.travis.yml```:\n\n```yml\naddons:\n  apt:\n    packages:\n    - zlib1g-dev\n    - libncurses5-dev\n    - libtinfo-dev\n```\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "date_created": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2011-01-31T08:52:04Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "date_updated": [
    {
      "confidence": 1,
      "result": {
        "type": "Date",
        "value": "2024-09-03T11:48:58Z"
      },
      "technique": "GitHub_API"
    }
  ],
  "description": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "Porting of samtools-ruby to BioRuby. Binder of samtools for ruby, on the top of FFI -from original project-"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Introduction",
        "parent_header": [
          "bio-samtools"
        ],
        "type": "Text_excerpt",
        "value": "Documentation and code come from that project and we'll adapt it for a better integration in BioRuby.\n\nBinder of samtools for ruby, on the top of FFI. \n\nThis project was born from the need to add support of BAM files to \nthe [gee_fu genome browser] (http://github.com/danmaclean/gee_fu). \n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.9483450110310492,
      "result": {
        "original_header": "VCF methods",
        "type": "Text_excerpt",
        "value": "For enhanced snp calling, we've included a VCF class which reflects each non-metadata line of a VCF file.\nThe VCF class returns the eight fixed fields present in VCF files, namely chromosome, position, ID, reference base, alt bases, alt quality score, filter and info along with the genotype fields, format and samples. This information allows the comparison of variants and their genotypes across any number of samples.\nThe following code takes a number of VCF objects and examines them for homozygous alt (1/1) SNPs\n```ruby\nvcfs = []\nvcfs << vcf1 = Bio::DB::Vcf.new(\"20\t14370\trs6054257\tG\tA\t29\t0\tNS=3;DP=14;AF=0.5;DB;H2\tGT:GQ:DP:HQ\t0|0:48:1:51,51\t1|0:48:8:51,51\t1/1:43:5:-1,-1\") #from a 3.3 vcf file\nvcfs << vcf2 = Bio::DB::Vcf.new(\"19\t111\t.\tA\tC\t9.6\t.\t.\tGT:HQ\t0|0:10,10\t0/0:10,10\t0/1:3,3\") #from a 4.0 vcf file\nvcfs << vcf3 = Bio::DB::Vcf.new(\"20\t14380\trs6054257\tG\tA\t29\tPASS\tNS=3;DP=14;AF=0.5;DB;H2\tGT:GQ:DP:HQ\t0|0:48:1:51,51\t1|0:48:8:51,51\t1/1:43:5:.,\") #from a 4.0 vcf file\n\nvcfs.each do |vcf|\n\tvcf.samples.each do |sample|\n    \tgenotype = sample[1]['GT']\n    \tif genotype == '1/1' or genotype == '1|1'\n        \tprint vcf.chrom, \" \"\n        \tputs vcf.pos\n    \tend\n\tend\nend\n\n=> 20 14370\n=> 20 14380\n```\n \n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "download_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://github.com/helios/bioruby-samtools/releases"
      },
      "technique": "GitHub_API"
    }
  ],
  "faq": [
    {
      "confidence": 1,
      "result": {
        "original_header": "FAQ",
        "parent_header": [
          "VCF methods"
        ],
        "type": "Text_excerpt",
        "value": "* I want to use Ruby 1.x, what can I do? \n\nWe try to ensure backwards compatibility with old rubies. However we only officially support current versions of [https://www.ruby-lang.org/en/downloads/](Ruby). The code should work however the testing suites used in earlier versions are not currently supported and don't work in modern rubies. This decision ensures compatibility with maintained versions of Ruby.  \n\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "forks_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 23
      },
      "technique": "GitHub_API"
    }
  ],
  "forks_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/rjpbonnal/bioruby-samtools/forks"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "rjpbonnal/bioruby-samtools"
      },
      "technique": "GitHub_API"
    }
  ],
  "full_title": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "bio-samtools"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "images": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "http://ethering.github.io/bio-samtools/images/out2.svg"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "http://ethering.github.io/bio-samtools/images/out.svg"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "regular_expression"
    },
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "http://ethering.github.io/bio-samtools/images/out3.svg"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "regular_expression"
    }
  ],
  "installation": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Installation",
        "parent_header": [
          "bio-samtools"
        ],
        "type": "Text_excerpt",
        "value": "Add this line to your application's Gemfile:\n\n    gem 'bio-samtools'\n    \nAnd then execute:\n \n    bundle\n    \nOr install it yourself as:\n\n    $ gem install bio-samtools\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 0.999984824179524,
      "result": {
        "original_header": "bio-samtools",
        "type": "Text_excerpt",
        "value": "The original project samtools-ruby belongs to Ricardo H. Ramirez @ [https://github.com/homonecloco/samtools-ruby] (https://github.com/homonecloco/samtools-ruby)\n \n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "supervised_classification"
    },
    {
      "confidence": 0.9265856847129019,
      "result": {
        "original_header": "Copyright",
        "type": "Text_excerpt",
        "value": "Copyright (c) 2011 Raoul J.P. Bonnal. See LICENSE.txt for\nfurther details. \n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "supervised_classification"
    }
  ],
  "issue_tracker": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://api.github.com/repos/rjpbonnal/bioruby-samtools/issues"
      },
      "technique": "GitHub_API"
    }
  ],
  "keywords": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": ""
      },
      "technique": "GitHub_API"
    }
  ],
  "license": [
    {
      "confidence": 1,
      "result": {
        "name": "Other",
        "spdx_id": "NOASSERTION",
        "type": "License",
        "url": null,
        "value": null
      },
      "technique": "GitHub_API"
    }
  ],
  "name": [
    {
      "confidence": 1,
      "result": {
        "type": "String",
        "value": "bioruby-samtools"
      },
      "technique": "GitHub_API"
    }
  ],
  "owner": [
    {
      "confidence": 1,
      "result": {
        "type": "User",
        "value": "rjpbonnal"
      },
      "technique": "GitHub_API"
    }
  ],
  "programming_languages": [
    {
      "confidence": 1,
      "result": {
        "name": "Ruby",
        "size": 97518,
        "type": "Programming_language",
        "value": "Ruby"
      },
      "technique": "GitHub_API"
    },
    {
      "confidence": 1,
      "result": {
        "name": "HTML",
        "size": 16460,
        "type": "Programming_language",
        "value": "HTML"
      },
      "technique": "GitHub_API"
    }
  ],
  "readme_url": [
    {
      "confidence": 1,
      "result": {
        "type": "Url",
        "value": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md"
      },
      "technique": "file_exploration"
    }
  ],
  "requirements": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Dependencies",
        "parent_header": [
          "VCF methods"
        ],
        "type": "Text_excerpt",
        "value": "* BioRuby >= 1.5 [https://github.com/bioruby/bioruby](https://github.com/bioruby/bioruby)\n* Ruby 2.1.10 and above. \n\n\t"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    }
  ],
  "somef_missing_categories": [
    "acknowledgement",
    "run",
    "download",
    "contact",
    "contributors",
    "documentation",
    "support",
    "identifier",
    "has_build_file",
    "executable_example"
  ],
  "somef_provenance": {
    "date": "2024-11-04 06:59:21",
    "somef_schema_version": "1.0.0",
    "somef_version": "0.9.5"
  },
  "stargazers_count": [
    {
      "confidence": 1,
      "result": {
        "type": "Number",
        "value": 33
      },
      "technique": "GitHub_API"
    }
  ],
  "usage": [
    {
      "confidence": 1,
      "result": {
        "original_header": "Creating a new SAM object",
        "parent_header": [
          "Tutorial",
          "Working with BAM files"
        ],
        "type": "Text_excerpt",
        "value": "A SAM object represents the alignments in the BAM file, and is very straightforward to create, you will need a sorted BAM file, to access the alignments and a reference sequence in FASTA format to use the reference sequence. The object can be created and opened as follows:\n\n\trequire 'bio-samtools'\n\t\n\tbam = Bio::DB::Sam.new(:bam=>\"my_sorted.bam\", :fasta=>'ref.fasta')\n\tbam.open\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Getting Reference Sequence",
        "parent_header": [
          "Tutorial",
          "Working with BAM files"
        ],
        "type": "Text_excerpt",
        "value": "Retrieving the reference can only be done if the reference has been loaded, which isn't done automatically in order to save memory. Reference need only be loaded once, and is accessed using reference name, start, end in 1-based co-ordinates. A standard Ruby String object is returned.\n\n\tbam.load_reference \n\tsequence_fragment = bam.fetch_reference(\"Chr1\", 1, 500)\n\t"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Getting Alignments",
        "parent_header": [
          "Tutorial",
          "Working with BAM files"
        ],
        "type": "Text_excerpt",
        "value": "Alignments can be obtained one at a time by looping over a specified region using the fetch() function.\n\n\tbam.load_reference \n\tbam.fetch(\"1\",3000,4000).each do |alignment|\n\t\t#do something with the alignment...\n\tend\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Creating a BAM file",
        "parent_header": [
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "Often, the output from a next-generation sequence alignment tool will be a file in the [SAM format](http://samtools.github.io/hts-specs/SAMv1.pdf).\n\nTypically, we'd create a compressed, indexed binary version of the SAM file, which would allow us to operate on it in a quicker and more efficient manner, being able to randomly access various parts of the alignment. We'd use the `view` to do this. This step would involve takeing our sam file, sorting it and indexing it.\n\n```ruby\n#create the sam object\nsam = Bio::DB::Sam.new(:bam => 'my.sam', :fasta => 'ref.fasta')\n\n#create a bam file from the sam file\nsam.view(:b=>true, :S=>true, :o=>'bam.bam')\n\n#create a new sam object from the bam file\nunsortedBam = Bio::DB::Sam.new(:bam => 'bam.bam', :fasta => 'ref.fasta')\n\n#the bam file might not be sorted (necessary for samtools), so sort it\nunsortedBam.sort(:prefix=>'sortedBam')\n\n#create a new sam object\nbam = Bio::DB::Sam.new(:bam => 'sortedBam.bam', :fasta => 'ref.fasta')\n#create a new index\nbam.index()\n\n#creates index file sortedBam.bam.bai\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Concatenating BAM files",
        "parent_header": [
          "Tutorial",
          "Working with BAM files"
        ],
        "type": "Text_excerpt",
        "value": "BAM files may be concatenated using the `cat` command. The sequence dictionary of each input BAM must be identical, although the `cat` method does not check this.\n\n```ruby\n#create an array of BAM files to cat\nbam_files = [bam1, bam2]\ncat_file = \"maps_cated.bam\" #the outfile\n#cat the files\n@sam.cat(:out=>cat_file, :bams=>bam_files)\n#create a new Bio::DB::Sam object from the new cat file\ncat_bam = Bio::DB::Sam.new(:fasta => \"ref.fasta\", :bam => cat_file)\n\n```\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Removing duplicate reads",
        "parent_header": [
          "Tutorial",
          "Working with BAM files"
        ],
        "type": "Text_excerpt",
        "value": "The `remove_duplicates` method removes potential PCR duplicates: if multiple read pairs have identical external coordinates it only retain the pair with highest mapping quality. It does not work for unpaired reads (e.g. two ends mapped to different chromosomes or orphan reads).\n```ruby\n\nunduped = \"dupes_rmdup.bam\" #an outfile for the removed duplicates bam\n#remove single-end duplicates\nbam.remove_duplicates(:s=>true, :out=>unduped)\n#create new Bio::DB::Sam object\nunduped_bam = Bio::DB::Sam.new(:fasta => \"ref.fasta\", :bam => unduped)\n\n```\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Alignment Objects",
        "parent_header": [
          "Tutorial",
          "Working with BAM files"
        ],
        "type": "Text_excerpt",
        "value": "The individual alignments represent a single read and are returned as\nBio::DB::Alignment objects. These have numerous methods of their own,\nusing `require 'pp'` will allow you to check the attributes contained in\neach object. Here is an example alignment object. Remember `@`\nrepresents a Ruby instance variable and can be accessed as any other\nmethod. Thus the `@is_mapped` attribute of an object `a` is accessed\n`a.is_mapped`\n\n```ruby\nrequire 'pp'\npp an_alignment_object ##some Bio::DB::Alignment object\n#<Bio::DB::Alignment:0x101113f80\n@al=#<Bio::DB::SAM::Tools::Bam1T:0x101116a50>,\n@calend=4067,\n@cigar=\"76M\",\n@failed_quality=false,\n@first_in_pair=false,\n@flag=163,\n@is_duplicate=false,\n@is_mapped=true,\n@is_paired=true,\n@isize=180,\n@mapq=60,\n@mate_strand=false,\n@mate_unmapped=false,\n@mpos=4096,\n@mrnm=\"=\",\n@pos=3992,\n@primary=true,\n@qlen=76,\n@qname=\"HWI-EAS396_0001:7:115:17904:15958#0\",\n@qual=\"IIIIIIIIIIIIHHIHGIHIDGGGG...\",\n@query_strand=true,\n@query_unmapped=false,\n@rname=\"1\",\n@second_in_pair=true,\n@seq=\"ACAGTCCAGTCAAAGTACAAATCGAG...\",\n@tags=\n    {\"MD\"=>#<Bio::DB::Tag:0x101114ed0 @tag=\"MD\", @type=\"Z\", @value=\"76\">,\n     \"XO\"=>#<Bio::DB::Tag:0x1011155d8 @tag=\"XO\", @type=\"i\", @value=\"0\">,\n     \"AM\"=>#<Bio::DB::Tag:0x101116280 @tag=\"AM\", @type=\"i\", @value=\"37\">,\n     \"X0\"=>#<Bio::DB::Tag:0x101115fb0 @tag=\"X0\", @type=\"i\", @value=\"1\">,\n     \"X1\"=>#<Bio::DB::Tag:0x101115c68 @tag=\"X1\", @type=\"i\", @value=\"0\">,\n     \"XG\"=>#<Bio::DB::Tag:0x101115240 @tag=\"XG\", @type=\"i\", @value=\"0\">,\n     \"SM\"=>#<Bio::DB::Tag:0x1011162f8 @tag=\"SM\", @type=\"i\", @value=\"37\">,\n     \"XT\"=>#<Bio::DB::Tag:0x1011162a8 @tag=\"XT\", @type=\"A\", @value=\"U\">,\n     \"NM\"=>#<Bio::DB::Tag:0x101116348 @tag=\"NM\", @type=\"i\", @value=\"0\">,\n     \"XM\"=>#<Bio::DB::Tag:0x101115948 @tag=\"XM\", @type=\"i\", @value=\"0\">}>\n```\n\n### Getting Alignments\n\nAlignments can be obtained one at a time by looping over a specified region using the `fetch()` function.\n\n```ruby\nbam.fetch(\"Chr1\",3000,4000).each do |alignment|\n\t#do something with the alignment...\nend\n```\n\nA separate method `fetch_with_function()` allows you to pass a block (or\na Proc object) to the function for efficient calculation. This example takes\nan alignment object and returns an array of sequences which exactly match the reference.\n\n```ruby\n#an array to hold the matching sequences\nexact_matches = []\n\nmatches = Proc.new do |a|\n\t#get the length of each read\n\tlen = a.seq.length\n\t#get the cigar string\n\tcigar = a.cigar\n\t#create a cigar string which represents a full-length match\n\tcstr = len.to_s << \"M\"\n\tif cigar == cstr\n\t\t#add the current sequence to the array if it qualifies\n\t\texact_matches << a.seq\n\tend\nend\n\nbam.fetch_with_function(\"Chr1\", 100, 500, &matches) \n\nputs exact_matches\n```\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Alignment stats",
        "parent_header": [
          "Tutorial",
          "Working with BAM files"
        ],
        "type": "Text_excerpt",
        "value": "The SAMtools flagstat method is implemented in bio-samtools to quickly examine the number of reads mapped to the reference. This includes the number of paired and singleton reads mapped and also the number of paired-reads that map to different chromosomes/contigs.\n\n```ruby\nbam.flag_stats()\n```\n\nAn example output would be\n```ruby\n34672 + 0 in total (QC-passed reads + QC-failed reads)\n0 + 0 duplicates\n33196 + 0 mapped (95.74%:nan%)\n34672 + 0 paired in sequencing\n17335 + 0 read1\n17337 + 0 read2\n31392 + 0 properly paired (90.54%:nan%)\n31728 + 0 with itself and mate mapped\n1468 + 0 singletons (4.23%:nan%)\n0 + 0 with mate mapped to a different chr\n0 + 0 with mate mapped to a different chr (mapQ>=5)\n```\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Per Base Coverage",
        "parent_header": [
          "Tutorial",
          "Getting Coverage Information"
        ],
        "type": "Text_excerpt",
        "value": "It is easy to get the total depth of reads at a given position, the\n`chromosome_coverage` function is used. This differs from the previous\nfunctions in that a start position and length (rather than end position)\nare passed to the function. An array of coverages is returned, the first\nposition in the array gives the depth of coverage at the given start\nposition in the genome, the last position in the array gives the depth\nof coverage at the given start position plus the length given\n\n```ruby\ncoverages = bam.chromosome_coverage(\"Chr1\", 3000, 1000)  #=> [16,16,25,25...]\n```\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Average Coverage In A Region",
        "parent_header": [
          "Tutorial",
          "Getting Coverage Information"
        ],
        "type": "Text_excerpt",
        "value": "Similarly, average (arithmetic mean) of coverage can be retrieved with the `average_coverage` method.\n\n```ruby\ncoverages = bam.average_coverage(\"Chr1\", 3000, 1000)  #=> 20.287\n```\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Coverage from a BED file",
        "parent_header": [
          "Tutorial",
          "Getting Coverage Information"
        ],
        "type": "Text_excerpt",
        "value": "It is possible to count the number of nucleotides mapped to a given region of a BAM file by providing a [BED formatted](http://genome.ucsc.edu/FAQ/FAQformat.html#format1) file and using the `bedcov` method. The output is the BED file with an extra column providing the number of nucleotides mapped to that region.\n\n```ruby\nbed_file =  \"test.bed\"\nbam.bedcov(:bed=>bed_file)\n\n=> chr_1\t1\t30\t6\n=> chr_1\t40\t45\t8\n\n```\nAlternatively, the `depth` method can be used to get per-position depth information (any unmapped positions will be ignored).\n```ruby\nbed_file =  \"test.bed\"\n@sam.depth(:b=>bed_file)\n\n=> chr_1\t25\t1\n=> chr_1\t26\t1\n=> chr_1\t27\t1\n=> chr_1\t28\t1\n=> chr_1\t29\t1\n=> chr_1\t30\t1\n=> chr_1\t41\t1\n=> chr_1\t42\t1\n=> chr_1\t43\t2\n=> chr_1\t44\t2\n=> chr_1\t45\t2\n```"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Getting Pileup Information",
        "parent_header": [
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "Pileup format represents the coverage of reads over a single base in the\nreference. Getting a Pileup over a region is very easy. Note that this\nis done with `mpileup` and NOT the now deprecated SAMtools `pileup`\nfunction. Calling the `mpileup` method creates an iterator that yields a\nPileup object for each base.\n\n```ruby\nbam.mpileup do |pileup|\n    puts pileup.consensus #gives the consensus base from the reads for that position\nend \n```\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Caching pileups",
        "parent_header": [
          "Tutorial",
          "Getting Pileup Information"
        ],
        "type": "Text_excerpt",
        "value": "A pileup can be cached, so if you want to execute several operations on the same set of regions, mpilup won't be executed several times. Whenever you finish using a region, call mpileup_clear_cache to free the cache. The argument 'Region' is required, as it will be the key for the underlying hash. We assume that the options (other than the region) are constant. If they are not, the cache mechanism may not be consistent. \n\n```ruby\n#create an mpileup\nreg = Bio::DB::Fasta::Region.new\nreg.entry = \"Chr1\"\nreg.start = 1\nreg.end = 334\n\nbam.mpileup_cached(:r=>reg,:g => false, :min_cov => 1, :min_per =>0.2) do |pileup|\n\tputs pileup.consensus\nend\nbam.mpileup_clear_cache(reg)\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Pileup options",
        "parent_header": [
          "Tutorial",
          "Getting Pileup Information",
          "Caching pileups"
        ],
        "type": "Text_excerpt",
        "value": "The `mpileup` function takes a range of parameters to allow SAMtools\nlevel filtering of reads and alignments. They are specified as key =\\>\nvalue pairs eg\n\n```ruby\nbam.mpileup(:r => \"Chr1:1000-2000\", :Q => 50) do |pileup|\n    ##only pileups on Chr1 between positions 1000-2000 are considered, \n    ##bases with Quality Score < 50 are excluded\n    ...\nend \n```\n\nNot all the options SAMtools allows you to pass to mpileup will return a\nPileup object, The table below lists the SAMtools flags supported and the symbols you can use to call them in\nthe mpileup command.\n\n<table><tr><th>SAMtools options</th><th>description</th><th>short symbol</th><th>long symbol</th><th>default</th><th>example</th></tr>\n<tr><td>r</td><td>limit retrieval to a region</td><td>:r</td><td>:region</td><td>all positions</td><td>:r => \"Chr1:1000-2000\"</td></tr>\n<tr><td>6</td><td>assume Illumina scaled quality scores</td><td>:six</td><td>:illumina_quals</td><td>false</td><td>:six => true</td></tr>\n<tr><td>A</td><td>count anomalous read pairs scores</td><td>:A</td><td>:count_anomalous</td><td>false</td><td>:A => true</td></tr>\n<tr><td>B</td><td>disable BAQ computation</td><td>:B</td><td>:no_baq</td><td>false</td><td>:no_baq => true</td></tr>\n<tr><td>C</td><td>parameter for adjusting mapQ</td><td>:C</td><td>:adjust_mapq</td><td>0</td><td>:C => 25</td></tr>\n<tr><td>d</td><td>max per-BAM depth to avoid excessive memory usage</td><td>:d</td><td>:max_per_bam_depth</td><td>250</td><td>:d => 123</td></tr>\n<tr><td>E</td><td>extended BAQ for higher sensitivity but lower specificity</td><td>:E</td><td>:extended_baq</td><td>false</td><td>:E => true</td></tr>\n<tr><td>G</td><td>exclude read groups listed in FILE</td><td>:G</td><td>:exclude_reads_file</td><td>false</td><td>:G => my_file.txt</td></tr>\n<tr><td>l</td><td>list of positions (chr pos) or regions (BED)</td><td>:l</td><td>:list_of_positions</td><td>false</td><td>:l => my_posns.bed</td></tr>\n<tr><td>M</td><td>cap mapping quality at value</td><td>:M</td><td>:mapping_quality_cap</td><td>60</td><td>:M => 40 </td></tr>\n<tr><td>R</td><td>ignore RG tags</td><td>:R</td><td>:ignore_rg</td><td>false</td><td>:R => true </td></tr>\n<tr><td>q</td><td>skip alignments with mapping quality smaller than value</td><td>:q</td><td>:min_mapping_quality</td><td>0</td><td>:q => 30 </td></tr>\n<tr><td>Q</td><td>skip bases with base quality smaller than value</td><td>:Q</td><td>:imin_base_quality</td><td>13</td><td>:Q => 30</td></tr>\n</table>\n\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    },
    {
      "confidence": 1,
      "result": {
        "original_header": "Coverage Plots",
        "parent_header": [
          "Tutorial"
        ],
        "type": "Text_excerpt",
        "value": "You can create images that represent read coverage over binned regions of the reference sequence. The output format is svg. A number of parameters can be changed to alter the style of the plot. In the examples below the bin size and fill_color have been used to create plots with different colours and bar widths.   \n\nThe following lines of code...\n\n```ruby\nbam.plot_coverage(\"Chr1\", 201, 2000, :bin=>20, :svg => \"out2.svg\", :fill_color => '#F1A1B1')\nbam.plot_coverage(\"Chr1\", 201, 2000, :bin=>50, :svg => \"out.svg\", :fill_color => '#99CCFF')\nbam.plot_coverage(\"Chr1\", 201, 1000, :bin=>250, :svg => \"out3.svg\", :fill_color => '#33AD5C', :stroke => '#33AD5C')\n```\n\n![Coverage plot 1](http://ethering.github.io/bio-samtools/images/out2.svg)\n![Coverage plot 2](http://ethering.github.io/bio-samtools/images/out.svg)\n![Coverage plot 2](http://ethering.github.io/bio-samtools/images/out3.svg)\n\nThe `plot_coverage` method will also return the raw svg code, for further use. Simply leave out a file name and assign the method to a variable.\n\n```ruby\nsvg = bam.plot_coverage(\"Chr1\", 201, 2000, :bin=>50, :fill_color => '#99CCFF')\n\n```\n\n"
      },
      "source": "https://raw.githubusercontent.com/helios/bioruby-samtools/master/README.md",
      "technique": "header_analysis"
    }
  ]
}